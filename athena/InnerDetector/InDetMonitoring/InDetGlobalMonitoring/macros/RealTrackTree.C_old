#define RealTrackTree_cxx
#include "RealTrackTree.h"
#include <iostream>
#include <bitset>

#include <TAxis.h>
#include <TCanvas.h>
#include <TH1.h>
#include <TH2.h>
#include <TF1.h>
#include <TMath.h>
#include <TGraphErrors.h>
#include <TText.h>
#include <TString.h>
#include <TLatex.h>

void ATLAS_PRELIMINARY_LABEL(Double_t x,Double_t y,bool Preliminary=true,Color_t color=1) 
{
  TLatex l;
  
  l.SetNDC();
  
  l.SetTextFont(72);
  
  l.SetTextColor(color);
  
  double delx = 0.115*696*gPad->GetWh()/(472*gPad->GetWw());
  
  l.DrawLatex(x,y,"ATLAS");
  
  if (Preliminary) 
  {   
    TLatex p;
     
    p.SetNDC();
    
    p.SetTextFont(42);
    
    p.SetTextColor(color);
    
    p.DrawLatex(x+delx,y,"Preliminary");
    
    TLatex u;
    
    u.SetNDC();
    
    u.SetTextFont(42);

    u.SetTextColor(color);
    
    u.DrawLatex(x,y-0.065,"#sqrt{s} = 7 TeV");
  }
}//end of preliminary label method


RealTrackTree::RealTrackTree(TTree *tree) : InDetTrackTree(tree) {}

/*
//function to work with the helper file
void getValueAndError(double & value, double & error, TFile* file, bool pt, bool xdir, double x_input)
{
  if (file==0) return;
   
  TF1* function=0;
  TH1D* histoError=0;
  
  
//choosing the function and histogram: is it pt or ntrk? X direction or Z??  
  if (pt)
  {  
    if (xdir) //chhosing whether we are dealing with X or Z directions
    {
      function=(TF1*)file->Get("functionCorrectionX_vsPt_bin");
      histoError=(TH1D*)file->Get("functionCorrectionX_vsPt_binmatrix");
    }else{
      function=(TF1*)file->Get("functionCorrectionZ_vsPt_bin");
      histoError=(TH1D*)file->Get("functionCorrectionZ_vsPt_binmatrix");
    }
  
  }else{

    if (xdir)
    {
      function=(TF1*)file->Get("functionCorrectionX_Ntrk_bin");
      histoError=(TH1D*)file->Get("functionCorrectionX_Ntrk_binmatrix");
   
    }else{
   
      function=(TF1*)file->Get("functionCorrectionZ_Ntrk_bin");
      histoError=(TH1D*)file->Get("functionCorrectionZ_Ntrk_binmatrix");
    }
  }//end of check whether we're working with pt..


//protection for the case one cannot get the function back
  if (function==0) 
  {
    std::cout << " Cannot open file with fit result";
    return;
  }

  if ((pt) && (value>10.))
  {
    std::cout << " fatal error " << std::endl;
    throw;
  }
  
  double K    = function->GetParameter(0);
  double K_err = function->GetParError(0);
  
  double x0     = function->GetParameter(1);
  double x0_err = function->GetParError(1);
  double sigma     = function->GetParameter(2);
  double sigma_err = function->GetParError(2);
  
//  std::cout << " K " << K << " x0 " << x0 << " sigma " << sigma << std::endl;
//  std::cout << " Err K " << K_err << " " << sqrt(histoError->GetBinContent(1)) << " x0 " << 
//      x0_err << " " << sqrt(histoError->GetBinContent(2)) << 
//      " sigma " << sigma_err << " " << sqrt(histoError->GetBinContent(3)) << std::endl;

// std::cout << " K_err " << K_err << " cov[0][0] " << sqrt(histoError->GetBinContent(1)) << std::endl;

  value = function->Eval(x_input);

//  std::cout << " val: " << x_input << " eval: " << value;

  double EXP = exp(-(x_input-x0)*(x_input-x0)/2./sigma/sigma);
  
//  double value_check=K / (1 + EXP);
 // std::cout << " check: " << value_check << std::endl;

  double par_K = 1./(1. + EXP) * K_err;
  par_K = par_K * par_K;
  
  double par_x0 = K*(x_input-x0)*EXP/(1.+EXP)/(1.+EXP)/sigma/sigma*x0_err;
  par_x0=par_x0*par_x0;
  
  double par_s = EXP*K*(x_input-x0)*(x_input-x0)/(1.+EXP)/(1.+EXP)/sigma/sigma/sigma*sigma_err;
  par_s=par_s*par_s;
  
//  std::cout << " matrix[1][2] " << histoError->GetBinContent(6) << std::endl;

//  double par_x0s = (4 * EXP * K * (2. * (1.+ EXP) * sigma * sigma - (- 1. + EXP) * (x_input -x0) * 
//                                   (x_input - x0)) * (x_input - x0)) /
//      (2*2*(1.+EXP)*(1.+EXP)*(1.+EXP)*sigma*sigma*sigma*sigma*sigma) * histoError->GetBinContent(6);


  double par_x0s = 
      K*(x_input-x0)*EXP/(1.+EXP)/(1.+EXP)/sigma/sigma*
      EXP*K*(x_input-x0)*(x_input-x0)/(1.+EXP)/(1.+EXP)/sigma/sigma/sigma*
      histoError->GetBinContent(6);
  

  double par_x0K = K*(x_input-x0)*EXP/(1.+EXP)/(1.+EXP)/sigma/sigma*
      1./(1. + EXP) * histoError->GetBinContent(4);
  
  double par_Ks =1./(1. + EXP) *
      EXP*K*(x_input-x0)*(x_input-x0)/(1.+EXP)/(1.+EXP)/sigma/sigma/sigma*
      histoError->GetBinContent(5);

  error=sqrt(par_K+par_x0+par_s+2*par_x0s+2*par_x0K+2*par_Ks);

//  std::cout << " par_K " << par_K << " par_x0 " << par_x0 << " par_s " << par_s << 
//      " par_x0s " << par_x0s << " par_x0K " << par_x0K << " par_Ks " << par_Ks << std::endl;

//  std::cout << " error: " << error << std::endl;


}//end of getValueAndError method

*/

void RealTrackTree::Loop()
{

  double maxPT=10.;

  TFile* fileFunction=new TFile("outputFile_processed.root");

  TFile* outputFile=new TFile("outputFile.root","recreate");

   if (fChain == 0) return;

   Long64_t nentries(fChain->GetEntries());
   fChain->SetBranchStatus("*",0);  // disable all branches
   fChain->SetBranchStatus("ei_EventNumber",1);  // activate branchname
   fChain->SetBranchStatus("vx_n",1); 
   fChain->SetBranchStatus("vx_x",1);  
   fChain->SetBranchStatus("vx_y",1);  
   fChain->SetBranchStatus("vx_z",1);
   
   fChain->SetBranchStatus("vx_err_x",1);  
   fChain->SetBranchStatus("vx_err_y",1);   
   fChain->SetBranchStatus("vx_err_z",1);  
   
   fChain->SetBranchStatus("vx_trk_index",1);
   fChain->SetBranchStatus("trk_pt",1);
   fChain->SetBranchStatus("vx_trk_n",1); 
   
   fChain->SetBranchStatus("vxbc_n",1); 
   fChain->SetBranchStatus("vxbc_x",1);
   fChain->SetBranchStatus("vxbc_y",1);
   fChain->SetBranchStatus("vxbc_z",1);
   fChain->SetBranchStatus("vxbc_trk_n",1);  
   
//split vertices and stuff related to the reslutions
   fChain->SetBranchStatus("vxsplit_n",1);
   fChain->SetBranchStatus("vxsplit_x",1);
   fChain->SetBranchStatus("vxsplit_y",1);
   fChain->SetBranchStatus("vxsplit_z",1);
   fChain->SetBranchStatus("vxsplit_trk_n",1);
   fChain->SetBranchStatus("vxsplit_err_x",1);
   fChain->SetBranchStatus("vxsplit_err_y",1);
   fChain->SetBranchStatus("vxsplit_err_z",1);
   fChain->SetBranchStatus("vxsplit_trk_n",1);
   fChain->SetBranchStatus("vxsplit_trk_index",1);
   
   
   fChain->SetBranchStatus("ei_bcid",1);
   fChain->SetBranchStatus("ctp_decisionItems",1);
   fChain->SetBranchStatus("ei_RunNumber",1);
   
   
//histograms for the reconstructed vertices
   TH1F* h_vx_n      = defineHistogram("Vrt_vx_n", 10, 0., 10., "Number of Primary Vertices", "Entries");
   TH1F* h_Vrt_X_rec = defineHistogram("Vrt_X_rec", 100, -1.5, 1.,  "Primary Vertex x [mm]", "Entries");
   TH1F* h_Vrt_Y_rec = defineHistogram("Vrt_Y_rec", 100, -0.5, 1.5,  "Primary Vertex y [mm]", "Entries");
   TH1F* h_Vrt_Z_rec = defineHistogram("Vrt_Z_rec", 100, -200., 200.,  "Primary Vertex z [mm]", "Entries");
 
   TH2F* h_Vrt_XY_rec = define2DHistogram("Vrt_XY_rec", 100, -2., 2., 100, -2., 4., "Primary Vertex x [mm]", "Primary Vertex y [mm]");
   TH2F* h_Vrt_ZX_rec = define2DHistogram("Vrt_ZX_rec", 100, -200., 200., 100, -3., 3., "Primary Vertex z [mm]", "Primary Vertex y [mm]");
   TH2F* h_Vrt_ZY_rec = define2DHistogram("Vrt_ZY_rec", 100, -200., 200., 100, -3., 3., "Primary Vertex z [mm]", "Primary Vertex y [mm]");
  
   TH1F* h_Vrt_ntracksPV  = defineHistogram("h_Vrt_ntracksPV", 100, 0., 100.,  "Number of tracks per vertex", "Entries");
   TH1F* h_Vrt_ntracksSV = defineHistogram("h_Vrt_ntracksSV", 100, 0., 100.,  "Number of tracks per vertex", "Entries");
   TH1F* h_Vrt_ntracksPU1 = defineHistogram("h_Vrt_ntracksPU1", 100, 0., 100.,  "Number of tracks per vertex", "Entries");
   
// delta z and related histograms
   TH1F* pu_DeltaZ  = defineHistogram("Pile up Delta Z 1-2 ", 200, -100., 100.,  "Pile up Delta Z 1-2", "Entries");
   TH1F* pu_DeltaZ_cut3  = defineHistogram("Pile up Delta Z 1-2 (cut3)", 200, -100., 100.,  "Pile up Delta Z 1-2 (cut3)", "Entries");
   TH1F* pu_DeltaZ_cut4  = defineHistogram("Pile up Delta Z 1-2 (cut4)", 200, -100., 100.,  "Pile up Delta Z 1-2 (cut4)", "Entries");
 
   TH2F* deltaZ_vs_2ndmult = define2DHistogram("deltaZ_vs_2ndmult", 30, 0., 30., 100, -100., 100., "N Tracks Vertex 2", "Delta Z vertices 1-2");

   TH2F* sum_pt2_vs_mult = define2DHistogram("sum_pt2_vs_mult", 70, 0., 70., 1000, 0., 1000000000, "N Tracks Vertex", "sum_pt_2");
   TH2F* sum_pt2_vs_mult_all = define2DHistogram("sum_pt2_vs_mult_all", 70, 0., 70., 1000, 0., 1000000000, "N Tracks Vertex", "sum_pt_2");
   
// vertex errors vs number of tracks and pt
   TH2F* h_Vrt_err_vs_ntrk = define2DHistogram("Vrt_err_vs_ntrk", 70, 0., 70., 50000, 0., 150.,"Number of Tracks", "x vertex Error [mm]");
   TH2F* h_Vrt_err_vs_pt2 = define2DHistogram("Vrt_err_vs_pt2",  100, 0., maxPT, 50000, 0., 150.,"#sqrt{#sum p_{T}^{2}} [GeV]", "x vertex Error [mm]");  
   
   TH2F* h_Vrt_err_z_vs_ntrk = define2DHistogram("Vrt_err_z_vs_ntrk", 70, 0., 70., 50000, 0., 150.,"Number of Tracks", "z vertex Error [mm]");
   TH2F* h_Vrt_err_z_vs_pt2 = define2DHistogram("Vrt_err_z_vs_pt2",  100, 0., maxPT, 50000, 0., 150.," #sqrt{#sum p_{T}^{2}} [GeV]", "z vertex Error [mm]");  
  
   TH2F* h_Vrt_err2_vs_ntrk = define2DHistogram("Vrt_err2_vs_ntrk", 70, 0., 70., 5000, 0., 5000.,"Number of Tracks", "Vertex Error2 , mm2");
   TH2F* h_Vrt_err2_vs_pt2 = define2DHistogram("Vrt_err2_vs_pt2",  100, 0., maxPT, 5000, 0., 5000.,"#sqrt{#sum p_{T}^{2}} [GeV]", "Vertex Error2, mm2"); 
   
//split vertices histograms
   TH1F* h_vx_n_split	= defineHistogram("Vrt_vx_n_split", 10, 0., 10., "Number of Primary Vertices", "Entries");
   TH1F* h_Vrt_X_pull_split = defineHistogram("Vrt_X_pull_split", 100, -5., 5.,  "Split x Pull", "Entries");
   TH1F* h_Vrt_Y_pull_split = defineHistogram("Vrt_Y_pull_split", 100, -5., 5.,  "Split y Pull", "Entries");
   TH1F* h_Vrt_Z_pull_split = defineHistogram("Vrt_Z_pull_split", 100, -5., 5.,  "Split z Pull", "Entries");
   
   TH1F* h_Vrt_ntracksPV_split  = defineHistogram("h_Vrt_ntracksPV_split", 100, 0., 100.,  "Number of tracks per vertex", "Entries");
   TH1F* h_Vrt_ntracksPV_av_split  = defineHistogram("h_Vrt_ntracksPV_av_split", 100, 0., 100.,  "Number of tracks per vertex", "Entries");
  
   TH2F* h_Vrt_XpullVsNtrk_split = define2DHistogram("h_Vrt_XpullVsNtrk_split", 100, -5., 5., 70, 0., 70., "x Pull value", "N Tracks average");
   TH2F* h_Vrt_XpullVsPt2_split = define2DHistogram("h_Vrt_XpullVsPt2_split", 100, -5., 5., 100, 0., maxPT, "x Pull value", "Sqrt(#sum P_{T}^{2}) average [GeV]");
   
   TH2F* h_Vrt_ZpullVsNtrk_split = define2DHistogram("h_Vrt_ZpullVsNtrk_split", 100, -5., 5., 70, 0., 70., "z Pull value", "N Tracks average");
   TH2F* h_Vrt_ZpullVsPt2_split = define2DHistogram("h_Vrt_ZpullVsPt2_split", 100, -5., 5., 100, 0., maxPT, "z Pull value", "Sqrt(#sum P_{T}^{2}) [GeV]");
   
// beam constraint histograms
   TH1F* h_vx_n_bc      = defineHistogram("Vrt_vx_n_bc", 10, 0., 10., "Number of Primary Vertices", "Entries");
   TH1F* h_Vrt_X_rec_bc = defineHistogram("Vrt_X_rec_bc", 100, -1.5, 1.0,   "Primary Vertex x [mm]", "Vertices");
   TH1F* h_Vrt_Y_rec_bc = defineHistogram("Vrt_Y_rec_bc", 100, -0.5, 1.5,   "Primary Vertex y [mm]", "Vertices");
   TH1F* h_Vrt_Z_rec_bc = defineHistogram("Vrt_Z_rec_bc", 100, -200., 200., "Primary Vertex z [mm]", "Vertices");
  
   TH2F* h_Vrt_XY_rec_bc = define2DHistogram("Vrt_XY_rec_bc", 200, -1., 0.5, 200, 0., 1.5, "Primary Vertex x [mm]", "Primary Vertex y [mm]");
   TH2F* h_Vrt_ZX_rec_bc = define2DHistogram("Vrt_ZX_rec_bc", 200, -200., 200., 200, -1., 0.5, "Primary Vertex z [mm]", "Primary Vertex x [mm]");
   TH2F* h_Vrt_ZY_rec_bc = define2DHistogram("Vrt_ZY_rec_bc", 200, -200., 200., 200, 0., 1.5, "Primary Vertex z [mm]", "Primary Vertex y [mm]");
 
   TH1F* h_Vrt_ntracksPV_bc  = defineHistogram("h_Vrt_ntracksPV_bc", 100, 0., 100.,  "Number of tracks per vertex", "Entries");
   TH1F* h_Vrt_ntracksSV_bc = defineHistogram("h_Vrt_ntracksSV_bc", 100, 0., 100.,  "Number of tracks per vertex", "Entries");
   TH1F* h_Vrt_ntracksPU1_bc = defineHistogram("h_Vrt_ntracksPU1_bc", 100, 0., 100.,  "Number of tracks per vertex", "Entries");
   
   TH2F* h_Vrt_nTracksPVvsPU1 = define2DHistogram("h_Vrt_nTracksPVvsPU1", 50, 0., 50., 30, 0., 50., "N Tracks Vertex 1", "N Tracks Vertex 2");
  
   TH1F* h_Vrt_deltaZ_bc = defineHistogram("Delta_Z_bc", 100, 0., 300.,  "Primary Vertex Delta z [mm]", "Entries");
   TH1F* h_Vrt_deltaZ_bc_cut = defineHistogram("Delta_Z_bc_cut", 100, 0., 300.,  "Primary Vertex Delta z (cut) [mm]", "Entries");
   
   
   TH2F* h_Vrt_deltaZ_bc_vs_nvx = define2DHistogram("Delta z vs Nvx", 10, 0., 10., 100, 0., 300., "Number of Vertices", "Nearest delta z");
   TH2F* h_Vrt_deltaZ_bc_vs_nvx_cut = define2DHistogram("Delta z vs Nvx (cut) [mm]", 10, 0., 10., 100, 0., 300., "Number of Vertices", "Nearest delta z");
  
   TH2F* h_Vrt_ntracksPV_bc_vs_nvx = define2DHistogram("h_Vrt_nTracksPVvsNvx", 15, 0., 15., 200, 0., 200., "Number of the Vertex", "N Tracks at Vertex");
   TH1F* h_Vrt_Ntrk_bc_one = defineHistogram("Ntrk single collision", 100, 0., 100.,  "Number of tracks at  vertex", "Entries");
  
   std::cout<<"Working with a d3pd with entries: "<<nentries<<std::endl;
    
   for (Long64_t jentry=0; jentry<nentries;jentry++) 
   {
     Long64_t ientry = this->LoadTree(jentry);
     if (ientry < 0) break;
     fChain->GetEntry(jentry);

     if (vxsplit_n!=3) continue;
     
     if (jentry % 100000 == 0) cout << " Processed: " << jentry << " / total " << nentries << endl;

//checking  trigger and good run list 
     if (trigger_L1_MBTS_1() && good_run() )
     {

//split vertices block
      if(vxsplit_n > 1)
      {
       h_vx_n_split->Fill(vxsplit_n); 
       
//loop over all the vertices in the split container  
//       int half_size  = vxsplit_n/2;
       int half_size  = 1;
                  
       for(int spvx = 0; spvx < half_size; ++spvx)
       {
        
//taking the 2xith  and 2xith +1 vertices	
	float x_distance = vxsplit_x->at(2*spvx) - vxsplit_x->at(2*spvx+1);
	float y_distance = vxsplit_y->at(2*spvx) - vxsplit_y->at(2*spvx+1);
	float z_distance = vxsplit_z->at(2*spvx) - vxsplit_z->at(2*spvx+1);

        int ntrk_odd  =  vxsplit_trk_n->at(2*spvx+1);
	int ntrk_even =  vxsplit_trk_n->at(2*spvx);
	int ntrk_av = (ntrk_odd + ntrk_even)/2;
	
	h_Vrt_ntracksPV_split->Fill(ntrk_odd);
	h_Vrt_ntracksPV_split->Fill(ntrk_even);
	h_Vrt_ntracksPV_av_split->Fill(ntrk_av);

//calculation of the vertex errors
	float x_error = TMath::Sqrt(TMath::Power(vxsplit_err_x->at(2*spvx),2) + TMath::Power(vxsplit_err_x->at(2*spvx+1),2));
	float y_error = TMath::Sqrt(TMath::Power(vxsplit_err_y->at(2*spvx),2) + TMath::Power(vxsplit_err_y->at(2*spvx+1),2));
	float z_error = TMath::Sqrt(TMath::Power(vxsplit_err_z->at(2*spvx),2) + TMath::Power(vxsplit_err_z->at(2*spvx+1),2));
     
        float x_split_pull = x_distance/x_error;
 	float y_split_pull = y_distance/y_error;
 	float z_split_pull = z_distance/z_error;
     
	h_Vrt_X_pull_split->Fill(x_split_pull);
	h_Vrt_Y_pull_split->Fill(y_split_pull);
	h_Vrt_Z_pull_split->Fill(z_split_pull);
	
	h_Vrt_XpullVsNtrk_split->Fill(x_split_pull, ntrk_av);
	h_Vrt_ZpullVsNtrk_split->Fill(z_split_pull, ntrk_av);
	
//calculation of the  average sum of pt2
       float sum_pt2_1 = 0.;
       float sum_pt2_2 = 0.;
       for(int trk = 0; trk < vxsplit_trk_n->at(2*spvx); ++trk) 
           sum_pt2_1 += TMath::Power(trk_pt->at(vxsplit_trk_index->at(2*spvx)[trk])/1e3,2); //end of loop over all tracks at vertex	   
       
       for(int trk = 0; trk < vxsplit_trk_n->at(2*spvx+1); ++trk) 
           sum_pt2_2 += TMath::Power(trk_pt->at(vxsplit_trk_index->at(2*spvx+1)[trk] )/1e3,2); //end of loop over all tracks at vertex
     	
       h_Vrt_XpullVsPt2_split->Fill(x_split_pull, TMath::Sqrt((sum_pt2_1 + sum_pt2_2)/2.));
       
       h_Vrt_ZpullVsPt2_split->Fill(z_split_pull, TMath::Sqrt((sum_pt2_1 + sum_pt2_2)/2.));  
      }//end of loop over all split vertx pairs
     }//end of check that there are split vertices for this event
 
// beam- constrained vertcies---------------------------------------------------------------------      
//vertex with bc block
      h_vx_n_bc->Fill(vxbc_n-1);
     
      if (vxbc_n > 1)
      { 
       if(vxbc_trk_n->at(0)>3)
       { 
        h_Vrt_X_rec_bc->Fill(vxbc_x->at(0));
        h_Vrt_Y_rec_bc->Fill(vxbc_y->at(0));
        h_Vrt_Z_rec_bc->Fill(vxbc_z->at(0));
 
       
        h_Vrt_XY_rec_bc->Fill(vxbc_x->at(0), vxbc_y->at(0));
        h_Vrt_ZX_rec_bc->Fill(vxbc_z->at(0), vxbc_x->at(0));
        h_Vrt_ZY_rec_bc->Fill(vxbc_z->at(0), vxbc_y->at(0));
       }
  
       h_Vrt_ntracksPV_bc->Fill(vxbc_trk_n->at(0));

//       h_Vrt_ntracksPV_bc_vs_nvx->Fill(vxbc_trk_n->at(0), vxbc_n-1);
       

// filling the number of tracks for exactly one collision
       if(vxbc_n == 2) h_Vrt_Ntrk_bc_one->Fill(vxbc_trk_n->at(0));
       
  
//filling the dependence for the cases of > 1 collision
       if(vxbc_n > 2)
       {       
        int ntrk_temp[vxbc_n-1];
        for(int i=0; i<vxbc_n-1;++i) ntrk_temp[i] = vxbc_trk_n->at(i);
        const int n = sizeof(ntrk_temp) / sizeof(int);
        std::sort(ntrk_temp, ntrk_temp+n);
	
//now the numbers  of tracks are filled in the acsending order
//writing them into the histogram in the reverse order..	
        for(int i =  0; i <vxbc_n-1 ;++i) h_Vrt_ntracksPV_bc_vs_nvx->Fill(i, ntrk_temp[vxbc_n-2 - i]);
       }

// loop over the vertices in the container excluding the dummy
       if(vxbc_n > 2)// there is signal, dummy and something else
       {
           
//z cord of all vertices       
        float z_coord[vxbc_n-1];
	 
        for(int vtx_it = 0; vtx_it<vxbc_n-1 ; ++vtx_it) z_coord[vtx_it]  = vxbc_z->at(vtx_it) ;      //end of loop over all pileup vertices
        const int n = sizeof(z_coord) / sizeof(float);
        std::sort(z_coord, z_coord+n);	
	
//getting the inter-vertex distances if any
//and filling them into the corresponding histogram
        for(int vtx_it =0; vtx_it< vxbc_n-2;++vtx_it) 
	{
	  h_Vrt_deltaZ_bc->Fill(z_coord[vtx_it+1] - z_coord[vtx_it]);//end of loop over all the vertices	
          h_Vrt_deltaZ_bc_vs_nvx->Fill(vxbc_n-1,z_coord[vtx_it+1] - z_coord[vtx_it]);	
	}//end of loop over all the vertices reconstructed in the event
       
// selected z coordinate of vertices (vertices after the track selection cut )
// not the most elegant, but working solution.
//counting the vertices after the pile up cut
        std::vector<float> cut_vrt_z;
	
        cut_vrt_z.push_back(vxbc_z->at(0));
        for(int vtx_it = 1; vtx_it<vxbc_n-1 ; ++vtx_it)	
	{
	 if(vxbc_trk_n->at(vtx_it)>3) cut_vrt_z.push_back(vxbc_z->at(vtx_it));      
	}//end of loop over pile up vertices
	 
        if(cut_vrt_z.size()>1)
	{

//now sorting the z coordinate of verices to identify siblings	
         int n_after_cut  = cut_vrt_z.size();
	 float z_coord_cut[n_after_cut];
	 for(int i = 0; i<n_after_cut;++i)z_coord_cut[i] = cut_vrt_z[i];
	 const int n = sizeof(z_coord) / sizeof(float);
	 std::sort(z_coord_cut, z_coord_cut+n);	
	
	 for(int vtx_it =0; vtx_it<n_after_cut-1; ++vtx_it) 
	 {
	  h_Vrt_deltaZ_bc_cut->Fill(z_coord_cut[vtx_it+1] - z_coord_cut[vtx_it]);//end of loop over all the vertices	
          h_Vrt_deltaZ_bc_vs_nvx_cut->Fill(n_after_cut,z_coord_cut[vtx_it+1] - z_coord_cut[vtx_it]);
	 } //end of loop over all the vertices reconstructed in the event
	}//end of check whether the pile up vertices after the cut are there.
       }//end of selection of events with several pile up vertices
      }//end of vertex with bc block   

//-------------------------------------------------------------------------------------
// vertex block without the beam constraint
      h_vx_n->Fill(vx_n-1);
      if (vx_n > 1)
      {
       h_Vrt_X_rec->Fill(vx_x->at(0));
       h_Vrt_Y_rec->Fill(vx_y->at(0));
       h_Vrt_Z_rec->Fill(vx_z->at(0));
	  
       h_Vrt_XY_rec->Fill(vx_x->at(0), vx_y->at(0));
       h_Vrt_ZX_rec->Fill(vx_z->at(0), vx_x->at(0));
       h_Vrt_ZY_rec->Fill(vx_z->at(0), vx_y->at(0));

       h_Vrt_ntracksPV->Fill(vx_trk_n->at(0));
	   
// reconstructed vertex error as a function of Ntrk and pt2	   
       for(int vx_it =0;  vx_it !=vx_n-1; ++vx_it)
       {
        float ntrk = (float)vx_trk_n->at(vx_it);
	float sum_pt2 = 0.;
        for(int trk = 0; trk < vx_trk_n->at(vx_it); ++trk) sum_pt2 += TMath::Power(trk_pt->at(vx_trk_index->at(vx_it)[trk] )/1e3,2); 	   

 //       std::cout<<"Sum pt 2 "<<TMath::Sqrt(sum_pt2) <<std::endl;
        h_Vrt_err_vs_ntrk->Fill(ntrk,vx_err_x->at(vx_it));
        h_Vrt_err_vs_pt2->Fill(TMath::Sqrt(sum_pt2),vx_err_x->at(vx_it)); 
       
        h_Vrt_err_z_vs_ntrk->Fill(ntrk,vx_err_z->at(vx_it));
        h_Vrt_err_z_vs_pt2->Fill(TMath::Sqrt(sum_pt2),vx_err_z->at(vx_it)); 
       
       
//histograms for errors squared
        h_Vrt_err2_vs_ntrk->Fill(ntrk,TMath::Power(vx_err_x->at(vx_it),2.));
        h_Vrt_err2_vs_pt2->Fill(TMath::Sqrt(sum_pt2),TMath::Power(vx_err_x->at(vx_it),2.)); 
       }//end of loop over all the vertices	   
	
	
	
	   
//calculating sum of pt2 for the signal vertex
       float sum_pt2 = 0.;
       for(int trk = 0; trk < vx_trk_n->at(0); ++trk) sum_pt2 += TMath::Power(trk_pt->at(vx_trk_index->at(0)[trk] )/1e3,2); //end of loop over all tracks at vertex	   

// a single reconstructed vertex 	
       if(vx_n == 2)
       {
        h_Vrt_ntracksSV->Fill(vx_trk_n->at(0)); 
        sum_pt2_vs_mult->Fill(  vx_trk_n->at(0), sum_pt2);
       }
       sum_pt2_vs_mult_all->Fill(  vx_trk_n->at(0), sum_pt2);
       
//sum pt and sum pt^2	
	
//events with  2 and  more vertices	
	if (vx_n == 3)
	{
	 h_Vrt_ntracksPU1->Fill(vx_trk_n->at(1));
	 h_Vrt_nTracksPVvsPU1->Fill(vx_trk_n->at(0), vx_trk_n->at(1));
	 
//delta Z between vertices 
 	 double delta_z = vx_z->at(0) - vx_z->at(1);
	 pu_DeltaZ->Fill(delta_z);
	 deltaZ_vs_2ndmult->Fill(vx_trk_n->at(1),delta_z);
	  
//cut on the 2nd reconstructed vertex	 
	 if(vx_trk_n->at(1)>3)
	 {
	  pu_DeltaZ_cut3->Fill(delta_z);
	  if (vx_trk_n->at(1)>4) pu_DeltaZ_cut4->Fill(delta_z);
	 }//end of cut on th 2nd reconstructed verte
	}//end of pile up check
       }//end of vertex presence check
      }//end of trigger selection
   }//end of loop over all the entries

//creating various graphs for the split vertices-----------------------------------------------------
//analysing the 2d histogram which was created during the 
//split vertex scan. First getting number of bins       
       
   int ntrk_z_bin = h_Vrt_ZpullVsNtrk_split->GetNbinsY();
   std::vector<float> rms_z;
   std::vector<float> rms_z_er;
   std::vector<float> sigma_z;
   std::vector<float> sigma_z_er;
   
   std::vector<float> bins_z_nt;
   std::vector<float> bins_z_nt_er;
    
   outputFile->cd();

   TString profileZ_bin("profileZ_Ntrk_bin");

   for(int bin_count= 0; bin_count <ntrk_z_bin;++bin_count)
   {
   
     TString use=profileZ_bin;
     use+=bin_count;

    bins_z_nt.push_back((float)bin_count);
    bins_z_nt_er.push_back(1.);    
    TH1D * profileZ = h_Vrt_ZpullVsNtrk_split->ProjectionX("_pz",bin_count,bin_count);
 
    profileZ->SetName(use);
    profileZ->Write();

    rms_z.push_back(profileZ->GetRMS());
    rms_z_er.push_back(profileZ->GetRMSError());   
    
    //making a gaussian fit if there is anough entries 
    if(profileZ->GetEntries() > 50.)
    {
     
     profileZ->Fit("gaus");
 
     Double_t data_z[3];
     Double_t * data_z_er;
     profileZ->GetFunction("gaus")->GetParameters(data_z);
     data_z_er = profileZ->GetFunction("gaus")->GetParErrors();
     sigma_z.push_back(data_z[2]);
     sigma_z_er.push_back(data_z_er[2]);
    }else{
     sigma_z.push_back(0.);
     sigma_z_er.push_back(0.);
    }//end of good number of bins selection
 
    delete profileZ;
        
   }//end of loop over all the ntrk bins   
    
   TGraphErrors * krms_z_vs_ntrk = new TGraphErrors(ntrk_z_bin, &(bins_z_nt[0]),&(rms_z[0]),&(bins_z_nt_er[0]), &(rms_z_er[0]) );
   krms_z_vs_ntrk->GetYaxis()->SetTitle("z scale factor");
   krms_z_vs_ntrk->GetXaxis()->SetTitle("Number of fitted tracks");
   krms_z_vs_ntrk->SetName("scaleFactorZ_RMS");
   krms_z_vs_ntrk->Write();


   TGraphErrors * kgs_z_vs_ntrk = new TGraphErrors(ntrk_z_bin, &(bins_z_nt[0]),&(sigma_z[0]),&(bins_z_nt_er[0]), &(sigma_z_er[0]) );
   kgs_z_vs_ntrk->GetYaxis()->SetTitle("z scale factor");
   kgs_z_vs_ntrk->GetXaxis()->SetTitle("Number of fitted tracks"); 
   kgs_z_vs_ntrk->SetName("scaleFactorZ_Fit");
   kgs_z_vs_ntrk->Write();
    
    
// approximating the graph with 2nd order polinomial.
   kgs_z_vs_ntrk->Fit("pol2","","",2.,50.);
   kgs_z_vs_ntrk->GetFunction("pol2")->SetLineColor(kRed); 
   TF1 * kgs_z_ntrk_fit = kgs_z_vs_ntrk->GetFunction("pol2");

//getting the fitted parameter errors    
   Double_t * kgs_z_ntrk_fit_er = kgs_z_ntrk_fit->GetParErrors(); 
    
  
//playing with the pt2 dependence
   int pt2_z_bin    =  h_Vrt_ZpullVsPt2_split->GetNbinsY();
   
//getting the bin size in Y  
   
   float bin_z_size =  h_Vrt_ZpullVsPt2_split->GetYaxis()->GetBinWidth(2);
   
   std::vector<float> pt_z_rms;
   std::vector<float> pt_z_rms_er;
   std::vector<float> pt_z_sigma;
   std::vector<float> pt_z_sigma_er;
   
   std::vector<float> pt_z_bins_nt;
   std::vector<float> pt_z_bins_nt_er;
 
   TString profileZ2_bin("profileZ_vsPt_bin");

   for(int bin_count= 1; bin_count <= pt2_z_bin;++bin_count)
   {
   
     TString use=profileZ2_bin;
     use+=bin_count;

    pt_z_bins_nt.push_back((float)bin_count*bin_z_size);
    pt_z_bins_nt_er.push_back(1.);
   
    TH1D * profileX = h_Vrt_ZpullVsPt2_split->ProjectionX("_px",bin_count,bin_count);
    profileX->SetName(use);
    profileX->Write();
    
    pt_z_rms.push_back(profileX->GetRMS());
    pt_z_rms_er.push_back(profileX->GetRMSError());
	
//making a gaussina fit if there is enough entries 
    if(profileX->GetEntries() > 50.)
    {
     profileX->Fit("gaus");
 
     Double_t data_z[3];
     Double_t * data_z_er;
     profileX->GetFunction("gaus")->GetParameters(data_z);
     data_z_er = profileX->GetFunction("gaus")->GetParErrors();
     pt_z_sigma.push_back(data_z[2]);
     pt_z_sigma_er.push_back(data_z_er[2]);
    
    }else{
    
     pt_z_sigma.push_back(0.);
     pt_z_sigma_er.push_back(0.);
    
    }//end of checking enough entries
    
    
    delete profileX; 
   }//end of loop over all the pt2 bins
   
   TGraphErrors * krms_z_vs_pt= new TGraphErrors(pt2_z_bin, &(pt_z_bins_nt[0]),&(pt_z_rms[0]),&(pt_z_bins_nt_er[0]), &(pt_z_rms_er[0]) );
   krms_z_vs_pt->GetYaxis()->SetTitle("z scale factor");
   krms_z_vs_pt->GetXaxis()->SetTitle("#sqrt{#sum p_{T}^{2}} (average) [GeV]");
   krms_z_vs_pt->SetName("scaleFactorZvsPt_RMS");
   krms_z_vs_pt->Write();

   TGraphErrors * kgs_z_vs_pt = new TGraphErrors(pt2_z_bin, &(pt_z_bins_nt[0]),&(pt_z_sigma[0]),&(pt_z_bins_nt_er[0]), &(pt_z_sigma_er[0]) );
   kgs_z_vs_pt->GetYaxis()->SetTitle("z scale factor");
   kgs_z_vs_pt->GetXaxis()->SetTitle("#sqrt{#sum p_{T}^{2}} (average) [GeV] ");
   kgs_z_vs_pt->SetName("scaleFactorZvsPt_Fit");
   kgs_z_vs_pt->Write();
      
// approximating the graph with 2nd order polinomial.
   kgs_z_vs_pt->Fit("pol2","","",0.2,8.);
   kgs_z_vs_pt->GetFunction("pol2")->SetLineColor(kRed); 
   TF1 * kgs_z_pt_fit = kgs_z_vs_pt->GetFunction("pol2");

//getting the fitted parameter errors    
   Double_t * kgs_z_pt_fit_er = kgs_z_pt_fit->GetParErrors();
       
      
//-------------------------------------------------------------------------------------------------------------------------------------   
//X -pull dependence..-----------------------------------------------------------------------------------------------------------------       
   int ntrk_bin = h_Vrt_XpullVsNtrk_split->GetNbinsY();
   std::vector<float> rms;
   std::vector<float> rms_er;
   std::vector<float> sigma;
   std::vector<float> sigma_er;
   
   std::vector<float> bins_nt;
   std::vector<float> bins_nt_er;

   TString profileX_bin("profileX_Ntrk_bin");

   for(int bin_count= 0; bin_count <ntrk_bin;++bin_count)
   {
   
    TString use=profileX_bin;
    use+=bin_count;

    bins_nt.push_back((float)bin_count);
    bins_nt_er.push_back(1.);
   
    TH1D * profileX = h_Vrt_XpullVsNtrk_split->ProjectionX("_px",bin_count,bin_count);
 
    profileX->SetName(use);
    profileX->Write();

    rms.push_back(profileX->GetRMS());
    rms_er.push_back(profileX->GetRMSError());
	
//making a gaussian fit if there is anough entries 
    if(profileX->GetEntries() > 50.)
    {
     
     profileX->Fit("gaus");
 
     Double_t data[3];
     Double_t * data_er;
     profileX->GetFunction("gaus")->GetParameters(data);
     data_er = profileX->GetFunction("gaus")->GetParErrors();
     sigma.push_back(data[2]);
     sigma_er.push_back(data_er[2]);
    }else{
     sigma.push_back(0.);
     sigma_er.push_back(0.);
    }//end of good number of bins selection
 
    delete profileX;
   }//end of loop over all the bins in ntrk

   TGraphErrors * krms_vs_ntrk = new TGraphErrors(ntrk_bin, &(bins_nt[0]),&(rms[0]),&(bins_nt_er[0]), &(rms_er[0]) );
   krms_vs_ntrk->GetYaxis()->SetTitle("x scale factor");
   krms_vs_ntrk->GetXaxis()->SetTitle("Number of fitted tracks");
   krms_vs_ntrk->SetName("scaleFactorX_RMS");
   krms_vs_ntrk->Write();
   
   TGraphErrors * kgs_vs_ntrk = new TGraphErrors(ntrk_bin, &(bins_nt[0]),&(sigma[0]),&(bins_nt_er[0]), &(sigma_er[0]) );
   kgs_vs_ntrk->GetYaxis()->SetTitle("x scale factor");
   kgs_vs_ntrk->GetXaxis()->SetTitle("Number of fitted tracks");
   kgs_vs_ntrk->SetName("scaleFactorX_Fit");
   kgs_vs_ntrk->Write();

//approximating the dependence with the 2nd order polinomial
   kgs_vs_ntrk->Fit("pol2","","",2.,50.);
   kgs_vs_ntrk->GetFunction("pol2")->SetLineColor(kRed); 
   TF1 * kgs_ntrk_fit = kgs_vs_ntrk->GetFunction("pol2");

//getting the fitted parameter errors    
   Double_t * kgs_ntrk_fit_er = kgs_ntrk_fit->GetParErrors();

//playing with the pt2 dependence
   int pt2_bin    =  h_Vrt_XpullVsPt2_split->GetNbinsY();
   
//getting the bin size in Y  
   
   float bin_size =  h_Vrt_XpullVsPt2_split->GetYaxis()->GetBinWidth(2);
   
   std::vector<float> pt_rms;
   std::vector<float> pt_rms_er;
   std::vector<float> pt_sigma;
   std::vector<float> pt_sigma_er;
   
   std::vector<float> pt_bins_nt;
   std::vector<float> pt_bins_nt_er;

   TString profileX2_bin("profileX_vsPt_bin");

   for(int bin_count= 1; bin_count <=pt2_bin;++bin_count)
   {
   
     TString use=profileX2_bin;
     use+=bin_count;

    pt_bins_nt.push_back((float)bin_count*bin_size);
    pt_bins_nt_er.push_back(1.);
   
    TH1D * profileX = h_Vrt_XpullVsPt2_split->ProjectionX("_px",bin_count,bin_count);
    profileX->SetName(use);
    profileX->Write();
    
    pt_rms.push_back(profileX->GetRMS());
    pt_rms_er.push_back(profileX->GetRMSError());
	
//making a gaussina fit if there is enough entries 
    if(profileX->GetEntries() > 50.)
    {
     profileX->Fit("gaus");
 
     Double_t data[3];
     Double_t * data_er;
     profileX->GetFunction("gaus")->GetParameters(data);
     data_er = profileX->GetFunction("gaus")->GetParErrors();
     pt_sigma.push_back(data[2]);
     pt_sigma_er.push_back(data_er[2]);
    
    }else{
    
     pt_sigma.push_back(0.);
     pt_sigma_er.push_back(0.);
    
    }//end of checking enough entries
    
    
    delete profileX; 
   }//end of loop over all the pt2 bins
   
   TGraphErrors * krms_vs_pt= new TGraphErrors(pt2_bin, &(pt_bins_nt[0]),&(pt_rms[0]),&(pt_bins_nt_er[0]), &(pt_rms_er[0]) );
   krms_vs_pt->GetYaxis()->SetTitle("x scale factor");
   krms_vs_pt->GetXaxis()->SetTitle("#sqrt{#sum p_{T}^{2}} (average) [GeV]");
   krms_vs_pt->SetName("scaleFactorXvsPt_RMS");
   krms_vs_pt->Write();

   
   TGraphErrors * kgs_vs_pt = new TGraphErrors(pt2_bin, &(pt_bins_nt[0]),&(pt_sigma[0]),&(pt_bins_nt_er[0]), &(pt_sigma_er[0]) );
   kgs_vs_pt->GetYaxis()->SetTitle("x scale factor");
   kgs_vs_pt->GetXaxis()->SetTitle("#sqrt{#sum p_{T}^{2}} (average) [GeV]");
   kgs_vs_pt->SetName("scaleFactorXvsPt_Fit");
   kgs_vs_pt->Write();
    
   kgs_vs_pt->Fit("pol2","","",0.2,8.);
   kgs_vs_pt->GetFunction("pol2")->SetLineColor(kRed); 
   TF1 * kgs_fit = kgs_vs_pt->GetFunction("pol2");
   
//getting the fitted parameter errors    
   Double_t * kgs_fit_er = kgs_fit->GetParErrors();
        
// playing with the averaged errors
   int nbins_z_err_ntrk = h_Vrt_err_z_vs_ntrk->GetNbinsX();  
   
   h_Vrt_err_z_vs_ntrk->SetName("error_z_vs_ntrk");
   h_Vrt_err_z_vs_ntrk->Write();
   
   std::vector<float> av_err_z;
   std::vector<float> av_err_z_er;
   
   std::vector<float> err_bins_z_nt;
   std::vector<float> err_bins_z_nt_er;
   
   std::vector<float> res_z;
   std::vector<float> res_z_er;
    
   for(int bin_count= 1; bin_count <=nbins_z_err_ntrk; ++bin_count)
   {
   
    err_bins_z_nt.push_back((float)bin_count);
    err_bins_z_nt_er.push_back(1.);
   
    TH1D * profileY = h_Vrt_err_z_vs_ntrk->ProjectionY("_py",bin_count,bin_count);
    
    float mean = profileY->GetMean();
    float mean_error = profileY->GetMeanError();
     
    av_err_z.push_back(mean);
    av_err_z_er.push_back(mean_error);
   
   
//estimating the approximate k-factor and the error value   

//    double valueFunction=0;
//    double pr_er = 0;
//    double x_input=bin_count;
    
 //   getValueAndError(valueFunction,
 //                    pr_er,
 //                    fileFunction,
 //                    false,
 //                    false,
 //                    x_input);

//    std::cout << " Inflating error from : " << pr_er << " to : " << sqrt(pr_er*pr_er+0.01*0.01*valueFunction*valueFunction) << std::endl;
 // pr_er=sqrt(pr_er*pr_er+0.01*0.01*valueFunction*valueFunction);

    double pr_er  =  error_func( bin_count, kgs_z_ntrk_fit_er); 

    res_z.push_back(mean * kgs_z_ntrk_fit->Eval(bin_count));  
//    res_z.push_back(mean * valueFunction);
   
    res_z_er.push_back(TMath::Sqrt(TMath::Power(mean_error * kgs_z_ntrk_fit->Eval(bin_count),2) + TMath::Power( pr_er * mean ,2)));   
//    res_z_er.push_back(TMath::Sqrt(TMath::Power(mean_error * valueFunction,2) + TMath::Power( pr_er * mean ,2)));   
   }
   
   
   TGraphErrors * res_z_vs_ntrk = new TGraphErrors(nbins_z_err_ntrk, &(err_bins_z_nt[0]),&(res_z[0]),&(err_bins_z_nt_er[0]), &(res_z_er[0]) );
   res_z_vs_ntrk->GetYaxis()->SetTitle("z Vertex Resolution [mm]");
   res_z_vs_ntrk->GetXaxis()->SetTitle("Number of fitted tracks");
   
   
//resolution versus pt2
   int nbins_z_err_pt = h_Vrt_err_z_vs_pt2->GetNbinsX(); 
   float bin_size_z_pt =  h_Vrt_err_z_vs_pt2->GetXaxis()->GetBinWidth(2);
    
   h_Vrt_err_z_vs_pt2->SetName("error_z_vs_pt2");
   h_Vrt_err_z_vs_pt2->Write();

   std::vector<float> av_z_err_pt;
   std::vector<float> av_z_err_pt_er;
   
   std::vector<float> err_z_bins_pt;
   std::vector<float> err_z_bins_pt_er;
   
   std::vector<float> res_z_pt;
   std::vector<float> res_z_pt_er;
  
  
   for(int bin_count= 1; bin_count <=nbins_z_err_pt; ++bin_count)
   {
    err_z_bins_pt.push_back((float)bin_count*bin_size_z_pt);
    err_z_bins_pt_er.push_back(bin_size_z_pt);
    
    TH1D * profileY = h_Vrt_err_z_vs_pt2->ProjectionY("_py",bin_count,bin_count);
    
    float mean = profileY->GetMean();
    float mean_error = profileY->GetMeanError();
     
    av_z_err_pt.push_back(mean);
    av_z_err_pt_er.push_back(mean_error);
    
   // res_z_pt.push_back(mean * pt_z_sigma[bin_count]);
   
//estimating the approximate k-factor and the error value   

//    double valueFunction=0;
//    double pr_er = 0;
//    double x_input=pt_bins_nt[bin_count];
    //h_Vrt_err_z_vs_pt2->GetXaxis()->GetBinCenter(bin_count);
    
//    getValueAndError(valueFunction,
//                     pr_er,
//                     fileFunction,
//                     true,
//                     false,
//                     x_input);

//    std::cout << " Inflating error from : " << pr_er << " to : " << sqrt(pr_er*pr_er+0.01*0.01*valueFunction*valueFunction) << std::endl;

//    pr_er=sqrt(pr_er*pr_er+0.01*0.01*valueFunction*valueFunction);

    res_z_pt.push_back(mean *  kgs_z_pt_fit->Eval(pt_bins_nt[bin_count]));
//    res_z_pt.push_back(mean *  valueFunction);
      
    double pr_er = error_func( pt_bins_nt[bin_count]  , kgs_z_pt_fit_er); 
 
    res_z_pt_er.push_back(TMath::Sqrt(TMath::Power(mean_error * kgs_z_pt_fit->Eval(pt_bins_nt[bin_count]),2) + TMath::Power( pr_er * mean ,2))); 
//    res_z_pt_er.push_back(TMath::Sqrt(TMath::Power(mean_error * valueFunction,2) + TMath::Power( pr_er * mean ,2))); 
   } 
   
   TGraphErrors * mean_er_z_vs_pt= new TGraphErrors(nbins_z_err_pt, &(err_z_bins_pt[0]),&(av_z_err_pt[0]),&(err_z_bins_pt_er[0]), &(av_z_err_pt_er[0]) );
   mean_er_z_vs_pt->GetYaxis()->SetTitle("Average Vertex Error ");
   mean_er_z_vs_pt->GetXaxis()->SetTitle("#sqrt{#sum p_{T}^{2}} [GeV]");
   
   
   TGraphErrors * res_z_vs_pt = new TGraphErrors(nbins_z_err_pt, &(err_z_bins_pt[0]),&(res_z_pt[0]),&(err_z_bins_pt_er[0]), &(res_z_pt_er[0]) );
   res_z_vs_pt->GetYaxis()->SetTitle("z Vertex Resolution [mm]");
   res_z_vs_pt->GetXaxis()->SetTitle("#sqrt{#sum p_{T}^{2}} [GeV]");
   
      
   int nbins_err_ntrk = h_Vrt_err_vs_ntrk->GetNbinsX();  
   
   h_Vrt_err_vs_ntrk->SetName("error_vs_ntrk");
   h_Vrt_err_vs_ntrk->Write();

   std::vector<float> av_err;
   std::vector<float> av_err_er;
   
   std::vector<float> err_bins_nt;
   std::vector<float> err_bins_nt_er;
   
   std::vector<float> res;
   std::vector<float> res_er;
   
   for(int bin_count= 1; bin_count <=nbins_err_ntrk; ++bin_count)
   {
   
    err_bins_nt.push_back((float)bin_count);
    err_bins_nt_er.push_back(1.);
   
    TH1D * profileY = h_Vrt_err_vs_ntrk->ProjectionY("_py",bin_count,bin_count);
    
    float mean = profileY->GetMean();
    float mean_error = profileY->GetMeanError();
     
    av_err.push_back(mean);
    av_err_er.push_back(mean_error);
   
    res.push_back(mean * sigma[bin_count]);

//estimating the approximate k-factor and the error value   

//    double valueFunction=0;
//    double pr_er = 0;
//    double x_input=bin_count;
        //kgs_ntrk_fit->GetXaxis()->GetBinCenter(bin_count);

    
//    getValueAndError(valueFunction,
//                     pr_er,
//                     fileFunction,
//                     false,
//                     true,
 //                    x_input);

//    std::cout << " Inflating error from : " << pr_er << " to : " << sqrt(pr_er*pr_er+0.01*0.01*valueFunction*valueFunction) << std::endl;

   
//    res.push_back(mean * valueFunction);  
    
//    res_er.push_back(TMath::Sqrt( TMath::Power( mean_error *sigma[bin_count] ,2) +  TMath::Power( sigma_er[bin_count] * mean,2)));   
 
     double pr_er = error_func( bin_count, kgs_ntrk_fit_er); 
 
//    res_er.push_back(TMath::Sqrt( TMath::Power( mean_error * valueFunction ,2) +   TMath::Power(mean,2))* pr_er);
    res_er.push_back(TMath::Sqrt( TMath::Power( mean_error *kgs_ntrk_fit->Eval(bin_count),2) +   TMath::Power(mean,2))* pr_er);
   }//end of loop over all the X bins of the vertex error vs ntrk histo 
   
   TGraphErrors * mean_er_vs_ntrk= new TGraphErrors(nbins_err_ntrk, &(err_bins_nt[0]),&(av_err[0]),&(err_bins_nt_er[0]), &(av_err_er[0]) );
   mean_er_vs_ntrk->GetYaxis()->SetTitle("Average Vertex Error ");
   mean_er_vs_ntrk->GetXaxis()->SetTitle("Number of fitted tracks");
   
   
   TGraphErrors * res_vs_ntrk= new TGraphErrors(nbins_err_ntrk, &(err_bins_nt[0]),&(res[0]),&(err_bins_nt_er[0]), &(res_er[0]) );
   res_vs_ntrk->GetYaxis()->SetTitle("x Vertex Resolution [mm]");
   res_vs_ntrk->GetXaxis()->SetTitle("Number of fitted tracks");
   
   
//resolution versus pt2
   int nbins_err_pt = h_Vrt_err_vs_pt2->GetNbinsX(); 
   float bin_size_pt =  h_Vrt_err_vs_pt2->GetXaxis()->GetBinWidth(2);
   
   h_Vrt_err_vs_pt2->SetName("error_vs_pt2");
   h_Vrt_err_vs_pt2->Write();

   std::vector<float> av_err_pt;
   std::vector<float> av_err_pt_er;
   
   std::vector<float> err_bins_pt;
   std::vector<float> err_bins_pt_er;
   
   std::vector<float> res_pt;
   std::vector<float> res_pt_er;
   
//   std::cout<<"number of bins "<< nbins_err_pt<<std::endl;
   
   for(int bin_count= 1; bin_count <=nbins_err_pt; ++bin_count)
   {
    err_bins_pt.push_back((float)bin_count*bin_size_pt);
    err_bins_pt_er.push_back(bin_size_pt);
    
    TH1D * profileY = h_Vrt_err_vs_pt2->ProjectionY("_py",bin_count,bin_count);
    
    float mean = profileY->GetMean();
    float mean_error = profileY->GetMeanError();
     
    av_err_pt.push_back(mean);
    av_err_pt_er.push_back(mean_error);
    
    res_pt.push_back(mean * pt_sigma[bin_count]);
   
//estimating the approximate k-factor and the error value   

//    double valueFunction=0;
//    double pr_er = 0;
//    double x_input=pt_bins_nt[bin_count];
    
//    getValueAndError(valueFunction,
//                     pr_er,
//                     fileFunction,
//                     true,
//                     true,
//                     x_input);

//    std::cout << " Inflating error from : " << pr_er << " to : " << sqrt(pr_er*pr_er+0.01*0.01*valueFunction*valueFunction) << std::endl;

 
//    res_pt.push_back(mean * kgs_fit->Eval(pt_bins_nt[bin_count] ) );
//    res_pt.push_back(mean *valueFunction );
      
    double pr_er = error_func( pt_bins_nt[bin_count]  , kgs_fit_er); 
      
   // res_pt_er.push_back(TMath::Sqrt(TMath::Power(mean_error * pt_sigma[bin_count],2) + TMath::Power(pt_sigma_er[bin_count] * mean ,2))); 
    res_pt_er.push_back(TMath::Sqrt(TMath::Power(mean_error * kgs_fit->Eval(pt_bins_nt[bin_count] ),2) + TMath::Power(mean ,2) * pr_er )); 
//    res_pt_er.push_back(TMath::Sqrt(TMath::Power(mean_error * valueFunction,2) + TMath::Power(mean ,2) * pr_er )); 
  
   }
   
   TGraphErrors * mean_er_vs_pt= new TGraphErrors(nbins_err_pt, &(err_bins_pt[0]),&(av_err_pt[0]),&(err_bins_pt_er[0]), &(av_err_pt_er[0]) );
   mean_er_vs_pt->GetYaxis()->SetTitle("Average Vertex Error ");
   mean_er_vs_pt->GetXaxis()->SetTitle("#sqrt{#sum p_{T}^{2}} [GeV]");
   
   
   TGraphErrors * res_vs_pt= new TGraphErrors(nbins_err_pt, &(err_bins_pt[0]),&(res_pt[0]),&(err_bins_pt_er[0]), &(res_pt_er[0]) );
   res_vs_pt->GetYaxis()->SetTitle("x Vertex Resolution [mm]");
   res_vs_pt->GetXaxis()->SetTitle("#sqrt{#sum p_{T}^{2}} [GeV]");
   
// Plotting section--------------------------------------------------------------
// canvas and plots



//without beam constraint
   TCanvas* c_Vrt_1 = new TCanvas("VtxCanvas1", "VtxCanvas1", 1000, 600);
   c_Vrt_1->Divide(2,2);
   c_Vrt_1->cd(1) ;  
//   c_Vrt_1->cd(1)->SetGrid();  
//   h_Vrt_X_rec->Fit("gaus");
//   h_Vrt_X_rec->GetFunction("gaus")->SetLineColor(kBlue);
   h_Vrt_X_rec->Draw();
   
   c_Vrt_1->cd(2) ; 
//   c_Vrt_1->cd(2)->SetGrid();
 //  h_Vrt_Y_rec->Fit("gaus");
 //  h_Vrt_Y_rec->GetFunction("gaus")->SetLineColor(kBlue);
   h_Vrt_Y_rec->Draw();
  
   c_Vrt_1->cd(3) ;
//   c_Vrt_1->cd(3)->SetGrid();

 //  h_Vrt_Z_rec->Fit("gaus");
 //  h_Vrt_Z_rec->GetFunction("gaus")->SetLineColor(kBlue);
   h_Vrt_Z_rec->Draw();
   
   c_Vrt_1->cd(4);  
   c_Vrt_1->cd(4)->SetLogy();  
   h_vx_n->Draw();
   

//with beam constraint
   TCanvas* c_Vrt_1_bc = new TCanvas("VtxCanvas1_bc", "VtxCanvas1_bc", 1000, 600);
   c_Vrt_1_bc->Divide(2,2);
   c_Vrt_1_bc->cd(1) ;  
//   c_Vrt_1->cd(1)->SetGrid();  
//   h_Vrt_X_rec->Fit("gaus");
//   h_Vrt_X_rec->GetFunction("gaus")->SetLineColor(kBlue);
   h_Vrt_X_rec_bc->Draw();
   
   c_Vrt_1_bc->cd(2) ; 
//   c_Vrt_1->cd(2)->SetGrid();
 //  h_Vrt_Y_rec->Fit("gaus");
 //  h_Vrt_Y_rec->GetFunction("gaus")->SetLineColor(kBlue);
   h_Vrt_Y_rec_bc->Draw();
  
   c_Vrt_1_bc->cd(3) ;
//   c_Vrt_1->cd(3)->SetGrid();

 //  h_Vrt_Z_rec->Fit("gaus");
 //  h_Vrt_Z_rec->GetFunction("gaus")->SetLineColor(kBlue);
   h_Vrt_Z_rec_bc->Draw();
   
   c_Vrt_1_bc->cd(4);  
   c_Vrt_1_bc->cd(4)->SetLogy();  
   h_vx_n_bc->Draw();

   TCanvas* c_Vrt_2 = new TCanvas("VtxCanvas2", "VtxCanvas2", 900, 300);
   c_Vrt_2->Divide(2,2);
   c_Vrt_2->cd(1) ;  
   c_Vrt_2->cd(1)->SetGrid();
   h_Vrt_XY_rec->Draw("COLZ");
   
   c_Vrt_2->cd(2) ;  
   c_Vrt_2->cd(2)->SetGrid();
   h_Vrt_ZX_rec->Draw("COLZ");
   
   c_Vrt_2->cd(3) ; 
   c_Vrt_2->cd(3)->SetGrid();
   h_Vrt_ZY_rec->Draw("COLZ");
   
   TCanvas* pileUpCanvas = new TCanvas("PileUpCanvas", "PileUpCanvas", 1000, 600);
   pileUpCanvas->Divide(2,2);
   
   pileUpCanvas->cd(1)->SetLogy();
   h_Vrt_ntracksSV->Draw();
  
   pileUpCanvas->cd(2)->SetLogy();
   h_Vrt_ntracksPV->Draw();
   
   pileUpCanvas->cd(3)->SetLogy();  
   h_Vrt_ntracksPU1->SetLineColor(2);
   h_Vrt_ntracksPU1->Draw();
   
   pileUpCanvas->cd(4)->SetGrid(); 
   h_Vrt_nTracksPVvsPU1->Draw("COLZ"); 
   
   TCanvas* pileUpCanvas1 = new TCanvas("PileUpCanvas1", "PileUpCanvas1", 1000, 600);
   pileUpCanvas1->Divide(2,2);
   
   pileUpCanvas1->cd(1)->SetGrid();
   deltaZ_vs_2ndmult->Draw("COLZ");
   
   pileUpCanvas1->cd(2)->SetLogy();
//  pu_DeltaZ->Fit("gaus");
//  pu_DeltaZ->GetFunction("gaus")->SetLineColor(kBlue);
   pu_DeltaZ->Draw(); 
   
  
   pileUpCanvas1->cd(3)->SetLogy();
//  pu_DeltaZ_cut3->Fit("gaus");
//  pu_DeltaZ_cut3->GetFunction("gaus")->SetLineColor(kBlue);
   pu_DeltaZ_cut3->Draw();
   
   pileUpCanvas1->cd(4)->SetLogy();
//  pu_DeltaZ_cut4->Fit("gaus");
//  pu_DeltaZ_cut4->GetFunction("gaus")->SetLineColor(kBlue);
   pu_DeltaZ_cut4->Draw();

   TCanvas* pileUpCanvas2 = new TCanvas("PileUpCanvas2", "PileUpCanvas2", 1000, 600);
   pileUpCanvas2->Divide(2,2);
   pileUpCanvas2->cd(1)->SetLogy();
   sum_pt2_vs_mult->Draw("COLZ"); 
   pileUpCanvas2->cd(2)->SetLogy();
   sum_pt2_vs_mult_all->Draw("COLZ");
   
   
   TCanvas* splitCanvas = new TCanvas("splitCanvas", "splitCanvas", 1000, 600);
   splitCanvas->Divide(2,3);
   splitCanvas->cd(1);
   
   h_vx_n_split->Draw();
   splitCanvas->cd(2);
   h_Vrt_X_pull_split->Fit("gaus");
   h_Vrt_X_pull_split->Draw();
   splitCanvas->cd(3);
   h_Vrt_Y_pull_split->Fit("gaus");
   h_Vrt_Y_pull_split->Draw();
   splitCanvas->cd(4);
   h_Vrt_Z_pull_split->Fit("gaus");
   h_Vrt_Z_pull_split->Draw();
   splitCanvas->cd(5);
   h_Vrt_ntracksPV_split->Draw();
   splitCanvas->cd(6);
   h_Vrt_ntracksPV_av_split->Draw();
 
   TCanvas* splitCanvas1 = new TCanvas("splitCanvas1", "splitCanvas1", 1000, 600);
   splitCanvas1->Divide(2,3);
   splitCanvas1->cd(1);
 

   h_Vrt_XpullVsNtrk_split->Draw("COLZ");
   
   splitCanvas1->cd(2)->SetGrid();
  // splitCanvas1->cd(2)->SetLogy();
   krms_vs_ntrk->Draw("AP");

   splitCanvas1->cd(3)->SetGrid();
  // splitCanvas1->cd(3)->SetLogy();
   kgs_vs_ntrk->Draw("AP");
   
   splitCanvas1->cd(4)->SetLogy();
   h_Vrt_XpullVsPt2_split->Draw("COLZ");
   
   splitCanvas1->cd(5)->SetGrid();
  // splitCanvas1->cd(5)->SetLogy();
   krms_vs_pt->Draw("AP");

   splitCanvas1->cd(6)->SetGrid();
  // splitCanvas1->cd(6)->SetLogy();
   kgs_vs_pt->Draw("AP");
   
   
// split results for the Z coordiate
   TCanvas* splitCanvas2 = new TCanvas("splitCanvas2", "splitCanvas2", 1000, 600);
   splitCanvas2->Divide(2,3);
   splitCanvas2->cd(1);
 
   h_Vrt_ZpullVsNtrk_split->Draw("COLZ");
 
   splitCanvas2->cd(2)->SetLogy();
   h_Vrt_ZpullVsPt2_split->Draw("COLZ");
   
   splitCanvas2->cd(3);
   krms_z_vs_ntrk->Draw("AP");
   
   splitCanvas2->cd(4);
   kgs_z_vs_ntrk->Draw("AP");

   splitCanvas2->cd(5);
   krms_z_vs_pt->Draw("AP");

   splitCanvas2->cd(6);
   kgs_z_vs_pt->Draw("AP");

   
   TCanvas* errorCanvas1 = new TCanvas("errorCanvas1", "errorCanvas1", 1000, 600);
   errorCanvas1->Divide(2,3);
   errorCanvas1->cd(1)->SetLogy();
   h_Vrt_err_vs_ntrk->Draw("COLZ");

   errorCanvas1->cd(2)->SetLogy();
   h_Vrt_err_vs_pt2->Draw("COLZ");
   
 //  errorCanvas1->cd(3)->SetLogy();
 //  h_Vrt_err2_vs_ntrk->Draw("COLZ");
   
 //  errorCanvas1->cd(4)->SetLogy();
 //  h_Vrt_err2_vs_pt2->Draw("COLZ");
   
   errorCanvas1->cd(3)->SetLogy();
   errorCanvas1->cd(3)->SetGrid();
   mean_er_vs_ntrk->Draw("AP");

   errorCanvas1->cd(4)->SetLogy();
   errorCanvas1->cd(4)->SetGrid();
   res_vs_ntrk->Draw("AP");
   
   errorCanvas1->cd(5)->SetLogy();
   errorCanvas1->cd(5)->SetGrid();
   mean_er_vs_pt->Draw("AP");

   errorCanvas1->cd(6)->SetLogy();
   errorCanvas1->cd(6)->SetGrid();
   res_vs_pt->GetHistogram()->GetYaxis()->SetRangeUser(0.001, 1.5); 
   res_vs_pt->Draw("AP");
   
   TCanvas* errorCanvas2 = new TCanvas("errorCanvas2", "errorCanvas2", 1000, 600);
   errorCanvas2->Divide(2,3);
   errorCanvas2->cd(1)->SetLogy();
   h_Vrt_err_z_vs_ntrk->Draw("COLZ");
   
   errorCanvas2->cd(2)->SetLogy();
   h_Vrt_err_z_vs_pt2->Draw("COLZ");
  
   errorCanvas2->cd(3)->SetLogy();
   errorCanvas2->cd(3)->SetGrid();
   res_z_vs_ntrk->Draw("AP");
   
   errorCanvas2->cd(4)->SetLogy();
   errorCanvas2->cd(4)->SetGrid();
   res_z_vs_pt->GetHistogram()->GetYaxis()->SetRangeUser(-0.5, 4.); 
   res_z_vs_pt->Draw("AP");
 
   TCanvas* puCanvas1 = new TCanvas("puCanvas1", "puCanvas1", 1000, 600);
   puCanvas1->Divide(2,3);
   puCanvas1->cd(1);
   TF1 * fit_g = new TF1("half_gaus","gaus", 0.,300.);
   fit_g->FixParameter(1,0.);
//   h_Vrt_deltaZ_bc->Fit("half_gaus", "", "", 6.,300.);
   h_Vrt_deltaZ_bc->Draw();
   puCanvas1->cd(2);
   h_Vrt_deltaZ_bc_vs_nvx->Draw("COLZ");
   
   puCanvas1->cd(3);
   h_Vrt_deltaZ_bc_cut->Draw();
   
   puCanvas1->cd(4);
   h_Vrt_deltaZ_bc_vs_nvx_cut->Draw("COLZ");
   
   puCanvas1->cd(5);
   h_Vrt_Ntrk_bc_one->Draw();
   
   puCanvas1->cd(6);
   h_Vrt_ntracksPV_bc_vs_nvx->Draw("COLZ");
   
   TCanvas* puCanvas2 = new TCanvas("puCanvas2", "puCanvas2", 1000, 600);
   puCanvas2->Divide(2,3);
   puCanvas2->cd(1);
   h_Vrt_deltaZ_bc_vs_nvx_cut->ProjectionY("3d bin",3,3)->Draw();
  
   puCanvas2->cd(2);
   h_Vrt_deltaZ_bc_vs_nvx_cut->ProjectionY("4th bin",4,4)->Draw();
  
   puCanvas2->cd(3);
   h_Vrt_deltaZ_bc_vs_nvx_cut->ProjectionY("5th bin",5,5)->Draw();
   
   puCanvas2->cd(4);
   h_Vrt_deltaZ_bc_vs_nvx_cut->ProjectionY("6th bin",6,6)->Draw();
   
   puCanvas2->cd(5);
   
   
   puCanvas2->cd(6);
   
   
   
   TCanvas* ntrkCanvas1 = new TCanvas("ntrkCanvas1", "ntrkCanvas1", 1000, 600);
   ntrkCanvas1->Divide(2,3);
   
   ntrkCanvas1->cd(1);
   h_Vrt_ntracksPV_bc_vs_nvx->ProjectionY("1st",1,1)->Draw();
  
   ntrkCanvas1->cd(2);
   h_Vrt_ntracksPV_bc_vs_nvx->ProjectionY("2nd",2,2)->Draw();
  
   ntrkCanvas1->cd(3);
   h_Vrt_ntracksPV_bc_vs_nvx->ProjectionY("3d",3,3)->Draw();
   ntrkCanvas1->cd(4);
   h_Vrt_ntracksPV_bc_vs_nvx->ProjectionY("4th",4,4)->Draw();
   
      
 
 
 
/*   TCanvas* drawCanvas1 = new TCanvas("drawCanvas1", "drawCanvas1", 1000, 600);
   //h_Vrt_XpullVsNtrk_split->Draw("COLZ");
//   h_Vrt_X_rec_bc->Fit("gaus");
//   h_Vrt_X_rec_bc->GetFunction("gaus")->SetLineColor(kBlue);
  
  
   h_Vrt_X_rec_bc->SetFillColor(kBlue);
   h_Vrt_X_rec_bc->Draw();
   
   TText * x_text = new TText(60.,15.,"X Text");
   x_text->SetNDC();

   TLatex * x_text1 = new TLatex(-0.3, 40000.,"#sqrt{s} = 7 TeV");
//   x_text1->Draw();
   
   x_text->SetTextColor(kBlack);
   x_text->SetTextSize(0.05);
//   x_text->DrawText(-0.3,35000.,"RUNS 152166 - 156682");
   
   TString  xString1("RMS = ");
   xString1 += TString::Format("%6.3f",h_Vrt_X_rec_bc->GetRMS());
 //  xString1 += TString(" +/- ");
 //  xString1 += TString::Format("%6.3f",h_Vrt_X_rec_bc->GetRMSError());
   xString1 += TString(" mm ");
//   x_text->DrawText(-0.3,40000,"#sqrt{s} = 7 TeV");
   
//   x_text->DrawText(-0.3,20000,xString1);
   x_text->DrawText(0.65,0.4,xString1);
//-0.3,20000,xString1);
   
   
//   TLatex * x_text2 = new TLatex(-0.3, 10000,"Atlas preliminary");
//   x_text2->SetTextColor(kRed);
//   x_text2->Draw(); 
   
   ATLAS_PRELIMINARY_LABEL(0.60,0.87);
   
   drawCanvas1->SaveAs("X.eps");

   TCanvas* drawCanvas2 = new TCanvas("drawCanvas2", "drawCanvas2", 1000, 600);
  // h_Vrt_XpullVsPt2_split->Draw("COLZ");
//   h_Vrt_Z_rec_bc->Fit("gaus");
//   h_Vrt_Z_rec_bc->GetFunction("gaus")->SetLineColor(kBlue);
  
   h_Vrt_Z_rec_bc->SetFillColor(kBlue);
   h_Vrt_Z_rec_bc->Draw();
   
   TText * z_text = new TText(60.,15.,"Z Text");
   z_text->SetNDC();

   TLatex * z_text1 = new TLatex(-185., 30000.,"#sqrt{s} = 7 TeV");
//   z_text1->SetNCD();
//   z_text1->Draw();
   
   z_text->SetTextColor(kBlack);
   z_text->SetTextSize(0.05);
//   z_text->DrawText(-185.,25000.,"RUNS 152166 - 156682");  
   
   TString  zString1("RMS = ");
   zString1 += TString::Format("%6.1f",h_Vrt_Z_rec_bc->GetRMS());
  // zString1 += TString(" +/- ");
  // zString1 += TString::Format("%6.3f",h_Vrt_Z_rec_bc->GetRMSError());
   zString1 += TString(" mm ");
//   z_text->DrawText(-185.,22000,zString1);
   x_text->DrawText(0.65,0.4,zString1);   
//   TLatex * z_text2 = new TLatex(-185., 18000,"Atlas preliminary");
//   z_text2->SetTextColor(kRed);
//   z_text2->Draw(); 

   ATLAS_PRELIMINARY_LABEL(0.6,0.87);
   
   drawCanvas2->SaveAs("Z.eps");
   

   TCanvas* drawCanvas3 = new TCanvas("drawCanvas3", "drawCanvas3", 850, 700);
  // drawCanvas3->SetLogy();
  // drawCanvas3->SetGrid();
  // kgs_vs_ntrk->GetHistogram()->GetYaxis()->SetRangeUser(0.5, 2.0); 
  // kgs_vs_ntrk->Draw("AP");
  // drawCanvas3->SetGrid();
   h_Vrt_XY_rec_bc->Draw("COLZ");
   
   TText * scatter_text = new TText(60.,17.,"Scat Text");
   scatter_text->SetNDC();
   scatter_text->SetTextColor(kBlue);
   scatter_text->SetTextSize(0.04);

   TLatex * scatter_text1 = new TLatex(-0.9, 1.24,"#sqrt{s} = 7 TeV");
//   scatter_text1->Draw();

   gPad->SetRightMargin(0.15);


//   scatter_text->DrawText(-0.9,1.2,"RUNS 152166 - 156682");  
   
   TString  scatterString1("RMS x = ");
   scatterString1 += TString::Format("%6.3f",h_Vrt_XY_rec_bc->GetRMS(1));
 //  scatterString1 += TString(" +/- ");
 //  scatterString1 += TString::Format("%6.3f",h_Vrt_XY_rec_bc->GetRMSError(1));
   scatterString1 += TString(" mm ");
   
   TString  scatterString2("RMS y = ");
   scatterString2 += TString::Format("%6.3f",h_Vrt_XY_rec_bc->GetRMS(2));
 //  scatterString2 += TString(" +/- ");
 //  scatterString2 += TString::Format("%6.3f",h_Vrt_XY_rec_bc->GetRMSError(2));
   scatterString2 += TString(" mm ");
   
   double xxx=0.40;
   double yyy=0.25;

   scatter_text->DrawText(xxx,yyy,scatterString1);
   scatter_text->DrawText(xxx,yyy-0.06,scatterString2);
   
//   TLatex * scatter_text2 = new TLatex(-0.9, 0.1,"Atlas preliminary");
//   scatter_text2->SetTextColor(kRed);
//   scatter_text2->Draw(); 
  
      ATLAS_PRELIMINARY_LABEL(0.40,0.87);

      drawCanvas3->SaveAs("XY.eps");
      

   TCanvas* drawCanvas4 = new TCanvas("drawCanvas4", "drawCanvas4", 1000, 600);
  // drawCanvas4->SetLogy();
  // drawCanvas4->SetGrid();
  // kgs_vs_pt->GetHistogram()->GetYaxis()->SetRangeUser(0.1, 10.);
  // kgs_vs_pt->Draw("AP");
  // drawCanvas4->SetGrid();
   h_Vrt_ZX_rec_bc->Draw("COLZ");
   
   TText * scatter1_text = new TText(60.,15.,"Scat1 Text");
   scatter1_text->SetNDC();
   scatter1_text->SetTextColor(kBlue);
//   scatter1_text->DrawText(-150.,0.3,"RUNS 152166 - 156682");  
   
   TString  scatter1String1("RMS z = ");
   scatter1String1 += TString::Format("%6.1f",h_Vrt_ZX_rec_bc->GetRMS(1));
//   scatter1String1 += TString(" +/- ");
//   scatter1String1 += TString::Format("%6.3f",h_Vrt_ZX_rec_bc->GetRMSError(1));
   scatter1String1 += TString(" mm ");
   
   TString  scatter1String2("RMS x = ");
   scatter1String2 += TString::Format("%6.3f",h_Vrt_ZX_rec_bc->GetRMS(2));
 //  scatter1String2 += TString(" +/- ");
 //  scatter1String2 += TString::Format("%6.3f",h_Vrt_ZX_rec_bc->GetRMSError(2));
   scatter1String2 += TString(" mm ");
   
   
   scatter1_text->DrawText(xxx,yyy,scatter1String2);
   
   scatter1_text->DrawText(xxx,yyy-0.06,scatter1String1);
   
   TLatex * scatter1_text1 = new TLatex(-150., 0.3 ,"#sqrt{s} = 7 TeV");
//   scatter1_text1->Draw();
   
   gPad->SetRightMargin(0.17);
   
//   TLatex * scatter1_text2 = new TLatex(-150., -0.1,"Atlas preliminary");
//   scatter1_text2->SetTextColor(kRed);
//   scatter1_text2->Draw(); 

      ATLAS_PRELIMINARY_LABEL(0.55,0.87);

      drawCanvas4->SaveAs("XZ.eps");
   

   TCanvas* drawCanvas5 = new TCanvas("drawCanvas5", "drawCanvas5", 1000, 600);
   gPad->SetRightMargin(0.15);   


   drawCanvas5->SetLogy();
 //  drawCanvas5->SetGrid();
   h_Vrt_err_vs_ntrk->Draw("COLZ");
   
   TText * err_x_nt_text = new TText(60.,15.,"err_x_nt_text Text");
   err_x_nt_text->SetTextColor(kBlue);
//   err_x_nt_text->DrawText(10.,50.,"RUNS 152166 - 156682");  
    
   TLatex * err_x_nt_text1 = new TLatex(50., 10. ,"#sqrt{s} = 7 TeV");
//   err_x_nt_text1->Draw();  
  
//   TLatex * err_x_nt_text2 = new TLatex(40., 10.,"Atlas preliminary");
//   err_x_nt_text2->SetTextColor(kRed);
//   err_x_nt_text2->Draw(); 

      ATLAS_PRELIMINARY_LABEL(0.55,0.87);

      drawCanvas5->SaveAs("xerr_ntrk.eps");
      
   TCanvas* drawCanvas6 = new TCanvas("drawCanvas6", "drawCanvas6", 1000, 600);
   drawCanvas6->SetLogy();
 //  drawCanvas6->SetGrid();
   h_Vrt_err_vs_pt2->Draw("COLZ");
   
   TLatex * h_Vrt_err_vs_pt2_text1 = new TLatex(7000., 40. ,"#sqrt{s} = 7 TeV");
//   h_Vrt_err_vs_pt2_text1->Draw();  
   
   
   TText * err_x_pt_text = new TText(60.,15.,"err_x_pt_text Text");
   err_x_pt_text->SetTextColor(kBlue);
   err_x_pt_text->SetTextSize(0.05);
//   err_x_pt_text->DrawText(2000.,0.6,"RUNS 152166 - 156682");  
   
   
//   TLatex * err_x_pt_text2 = new TLatex(7000., 10.,"Atlas preliminary");
//   err_x_pt_text2->SetTextColor(kRed);
//   err_x_pt_text2->Draw(); 

   
      ATLAS_PRELIMINARY_LABEL(0.60,0.87);

      drawCanvas6->SaveAs("xerr_pt.eps");
      
   TCanvas* drawCanvas7 = new TCanvas("drawCanvas7", "drawCanvas7", 1000, 600);
   drawCanvas7->SetLogy();
   drawCanvas7->SetGrid();
   res_vs_ntrk->GetHistogram()->GetYaxis()->SetRangeUser(0.01, 1.2); 
   res_vs_ntrk->Draw("AP");
   
   TText * resx_nt_text = new TText(60.,15.,"resz_nt_text Text");
   resx_nt_text->SetTextColor(kBlue);
   resx_nt_text->SetTextSize(0.05);
//   resx_nt_text->DrawText(15.,0.6,"RUNS 152166 - 156682");  
   
   TLatex * resx_nt_text1 = new TLatex(55., 0.3 ,"#sqrt{s} = 7 TeV");
//   resx_nt_text1->Draw();  
   
//   TLatex * resx_nt_text2 = new TLatex(50., 0.4,"Atlas preliminary");
//   resx_nt_text2->SetTextColor(kRed);
//   resx_nt_text2->Draw(); 

   ATLAS_PRELIMINARY_LABEL(0.60,0.87);
      
   drawCanvas7->SaveAs("resx_vs_ntrk.eps");
   
   TCanvas* drawCanvas8 = new TCanvas("drawCanvas8", "drawCanvas8", 1000, 600);
   drawCanvas8->SetLogy();
   drawCanvas8->SetGrid();
   
   res_vs_pt->GetHistogram()->GetYaxis()->SetRangeUser(0.01, 1.2); 
   res_vs_pt->Draw("AP");
   
   TText * resx_pt_text = new TText(60.,15.,"resx_pt_text Text");
   resx_pt_text->SetTextColor(kBlue);
//   resx_pt_text->DrawText(2000.,0.6,"RUNS 152166 - 156682");  
   
   TLatex * res_vs_pt_text1 = new TLatex(8., 0.4 ,"#sqrt{s} = 7 TeV");
//   res_vs_pt_text1->Draw();  
      
//   TLatex * res_vs_pt_text2 = new TLatex(7000., 0.2,"Atlas preliminary");
//   res_vs_pt_text2->SetTextColor(kRed);
//   res_vs_pt_text2->Draw(); 

   ATLAS_PRELIMINARY_LABEL(0.60,0.87);
      
   drawCanvas8->SaveAs("resx_vs_pt.eps");

   TCanvas* drawCanvas9 = new TCanvas("drawCanvas9", "drawCanvas9", 1000, 600);
   drawCanvas9->SetLogy();
   drawCanvas9->SetGrid();
   res_z_vs_pt->GetHistogram()->GetYaxis()->SetRangeUser(0.01, 2.); 
   res_z_vs_pt->Draw("AP");
      
   TText * resz_pt_text = new TText(60.,15.,"resx_pt_text Text");
   resz_pt_text->SetTextColor(kBlue);
//   resz_pt_text->DrawText(2000.,1.0,"RUNS 152166 - 156682");
   
   TLatex * resz_pt_text1 = new TLatex(8., 0.4 ,"#sqrt{s} = 7 TeV");
//   resz_pt_text1->Draw();  
     
//   TLatex * resz_pt_text2 = new TLatex(7000., 0.6,"Atlas preliminary");
//   resz_pt_text2->SetTextColor(kRed);
//   resz_pt_text2->Draw(); 

   ATLAS_PRELIMINARY_LABEL(0.60,0.87);

   drawCanvas9->SaveAs("resz_vs_pt.eps");
 
   TCanvas* drawCanvas10 = new TCanvas("drawCanvas10", "drawCanvas10", 1000, 600);
   drawCanvas10->SetLogy();
   drawCanvas10->SetGrid();
   res_z_vs_ntrk->GetHistogram()->GetYaxis()->SetRangeUser(0.01, 2.); 
   res_z_vs_ntrk->Draw("AP");
   
   TText * resz_nt_text = new TText(60.,15.,"resz_nt_text Text");
   resz_nt_text->SetTextColor(kBlue);
//   resz_nt_text->DrawText(10.,1.,"RUNS 152166 - 156682");  
    
   TLatex * resz_nt_text1 = new TLatex(50., 0.4 ,"#sqrt{s} = 7 TeV");
//   resz_nt_text1->Draw();  
    
    
//   TLatex * resz_nt_text2 = new TLatex(50., 0.4,"Atlas preliminary");
//   resz_nt_text2->SetTextColor(kRed);
//   resz_nt_text2->Draw();  

   ATLAS_PRELIMINARY_LABEL(0.60,0.87);

   drawCanvas10->SaveAs("resz_vs_ntrk.eps");

   TCanvas* drawCanvas11 = new TCanvas("drawCanvas11", "drawCanvas11", 1000, 600);
   drawCanvas11->SetLogy(); 
//   drawCanvas11->SetGrid();
   h_Vrt_err_z_vs_ntrk->Draw("COLZ");
   
   TText * zerr_nt_text = new TText(60.,15.,"zerr_nt_text Text");
   zerr_nt_text->SetTextColor(kBlue);
//   zerr_nt_text->DrawText(15.,50,"RUNS 152166 - 156682"); 
   
   
   TLatex * zerr_nt_text1 = new TLatex(50., 10. ,"#sqrt{s} = 7 TeV");
//   zerr_nt_text1->Draw(); 
   
//   TLatex * zerr_nt_text2 = new TLatex(50., 30,"Atlas preliminary");
//   zerr_nt_text2->SetTextColor(kRed);
//   zerr_nt_text2->Draw(); 

   ATLAS_PRELIMINARY_LABEL(0.60,0.87);
   
   drawCanvas11->SaveAs("zerr_ntrk.eps");
   
   TCanvas* drawCanvas12 = new TCanvas("drawCanvas12", "drawCanvas12", 1000, 600);
   drawCanvas12->SetLogy(); 
//   drawCanvas12->SetGrid(); 
   h_Vrt_err_z_vs_pt2->Draw("COLZ");
   
   TText * zerr_pt_text = new TText(60.,15.,"zerr_pt_text Text");
   zerr_pt_text->SetTextColor(kBlue);
//   zerr_pt_text->DrawText(2000.,50,"RUNS 152166 - 156682");  
   
   TLatex * zerr_pt_text1 = new TLatex(7., 10. ,"#sqrt{s} = 7 TeV");
//   zerr_pt_text1->Draw();    
  
  
//   TLatex * zerr_pt_text2 = new TLatex(7000., 30,"Atlas preliminary");
//   zerr_pt_text2->SetTextColor(kRed);
//   zerr_pt_text2->Draw(); 

   ATLAS_PRELIMINARY_LABEL(0.60,0.87);

   drawCanvas12->SaveAs("zerr_pt.eps");
   
   TCanvas* drawCanvas13 = new TCanvas("drawCanvas13", "drawCanvas13", 1000, 600);
//   drawCanvas13->SetLogy(); 
//   drawCanvas13->SetGrid(); 
//   h_Vrt_XpullVsNtrk_split->Draw("COLZ");
   
   h_Vrt_ZY_rec_bc->Draw("COLZ");
   
   TText * scatter3_text = new TText(60.,17.,"Scat3 Text");
   scatter3_text->SetNDC();
   scatter3_text->SetTextColor(kBlue);
//   scatter3_text->DrawText(-150.,1.4,"RUNS 152166 - 156682");  
   
   TString  scatter3String1("RMS z = ");
   scatter3String1 += TString::Format("%6.1f",h_Vrt_ZY_rec_bc->GetRMS(1));
   scatter3String1 += TString(" mm ");
   
   TString  scatter3String2("RMS y = ");
   scatter3String2 += TString::Format("%6.3f",h_Vrt_ZY_rec_bc->GetRMS(2));
   scatter3String2 += TString(" mm ");
   
   scatter3_text->DrawText(xxx,yyy,scatter3String2);
   scatter3_text->DrawText(xxx,yyy-0.06,scatter3String1);


   TLatex * scatter3_text1 = new TLatex(-150., 1.35 ,"#sqrt{s} = 7 TeV");
//   scatter3_text1->Draw();    

   gPad->SetRightMargin(0.17);

 
//   TLatex * scatter3_text2 = new TLatex(-150., 1.0,"Atlas preliminary");
//   scatter3_text2->SetTextColor(kRed);
//   scatter3_text2->Draw(); 

   ATLAS_PRELIMINARY_LABEL(0.55,0.87); 
 
   drawCanvas13->SaveAs("YZ.eps");

   TCanvas* drawCanvas14 = new TCanvas("drawCanvas14", "drawCanvas14", 1000, 600);
   drawCanvas14->SetLogy();  
   h_Vrt_XpullVsPt2_split->Draw("COLZ");
 
   gPad->SetRightMargin(0.15);
   

   TCanvas* drawCanvas15 = new TCanvas("drawCanvas15", "drawCanvas15", 1000, 600);
//   drawCanvas15->SetLogy();
   drawCanvas15->SetGrid();
   kgs_vs_ntrk->GetHistogram()->GetYaxis()->SetRangeUser(0.7, 1.2); 
   kgs_vs_ntrk->Draw("AP");
   
   TText * knt_text = new TText(0.,15.,"knt_text Text");
   knt_text->SetTextColor(kBlue);
//   knt_text->DrawText(0.,1.4,"RUNS 152166 - 156682"); 
    
   TLatex * kpn_text1 = new TLatex(20., 1.1,"#sqrt{s} = 7 TeV");
//   kpn_text1->Draw();    
    
    
//   TLatex * kpn_text2 = new TLatex(20., 1.05,"Atlas preliminary");
//   kpn_text2->SetTextColor(kRed);
//   kpn_text2->Draw();  

   ATLAS_PRELIMINARY_LABEL(0.60,0.87); 
   
   TCanvas* drawCanvas16 = new TCanvas("drawCanvas16", "drawCanvas16", 1000, 600);  
//   drawCanvas16->SetLogy();
   drawCanvas16->SetGrid();
   kgs_vs_pt->GetHistogram()->GetYaxis()->SetRangeUser(0.7, 1.2);
   kgs_vs_pt->Draw("AP");
   
   TText * kpt_text = new TText(0.,15.,"kpt_text Text");
   kpt_text->SetTextColor(kBlue);
//   kpt_text->DrawText(1000.,4.5,"RUNS 152166 - 156682"); 
  
  
   TLatex * kpt_text1 = new TLatex(4000., 1.15,"#sqrt{s} = 7 TeV");
//   kpt_text1->Draw();   /
     
//   TLatex * kpt_text2 = new TLatex(4000., 1.09,"Atlas preliminary");
//   kpt_text2->SetTextColor(kRed);
//   kpt_text2->Draw();  

   ATLAS_PRELIMINARY_LABEL(0.60,0.87); 
   
   

     
     
     
   TCanvas* drawCanvas17 = new TCanvas("drawCanvas17", "drawCanvas17", 1000, 600); 
//   drawCanvas17->SetLogy();
   drawCanvas17->SetGrid();
   kgs_z_vs_ntrk->GetHistogram()->GetYaxis()->SetRangeUser(0.7, 1.2); 
   kgs_z_vs_ntrk->Draw("AP");
  
   TText * knt_z_text = new TText(0.,15.,"knt_z_text Text");
   knt_z_text->SetTextColor(kBlue);
//   knt_z_text->DrawText(-5.,1.6,"RUNS 152166 - 156682"); 
     
   TLatex * knt_z_text1 = new TLatex(0., 1.1,"#sqrt{s} = 7 TeV");
//   knt_z_text1->Draw();    
   
//   TLatex * knt_z_text2 = new TLatex(0., 1.03,"Atlas preliminary");
//   knt_z_text2->SetTextColor(kRed);
//   knt_z_text2->Draw();
  
   ATLAS_PRELIMINARY_LABEL(0.60,0.87); 
     
     
   TCanvas* drawCanvas18 = new TCanvas("drawCanvas18", "drawCanvas18", 1000, 600);  
//   drawCanvas18->SetLogy();
   drawCanvas18->SetGrid();
   kgs_z_vs_pt->GetHistogram()->GetYaxis()->SetRangeUser(0.7, 1.2);
   kgs_z_vs_pt->Draw("AP");  
         
   TText * kpt_z_text = new TText(0.,15.,"kpt_z_text Text");
   kpt_z_text->SetTextColor(kBlue);
//   kpt_z_text->DrawText(500.,2.5,"RUNS 152166 - 156682");  
     
   TLatex * kpt_z_text1 = new TLatex(1000., 1.1,"#sqrt{s} = 7 TeV");
//   kpt_z_text1->Draw();


//  TLatex * kpt_z_text2 = new TLatex(1000., 1.03,"Atlas preliminary");
//  kpt_z_text2->SetTextColor(kRed);
//  kpt_z_text2->Draw();

   ATLAS_PRELIMINARY_LABEL(0.60,0.87); 

*/


   outputFile->Write();

    
}//end of loop method

TH1F* RealTrackTree::defineHistogram(TString name, unsigned int bins, Double_t lbin, Double_t ubin, TString xaxistitle, TString yaxistitle)
{
  TH1F* histogram = new TH1F(name, name, bins, lbin, ubin);
  TAxis* xaxis = histogram->GetXaxis();
  xaxis->SetTitle(xaxistitle);
  TAxis* yaxis = histogram->GetYaxis();
  yaxis->SetTitle(yaxistitle);
  return histogram;
}

TH2F* RealTrackTree::define2DHistogram(TString name, unsigned int xbins, Double_t lxbin, Double_t uxbin, unsigned int ybins, Double_t lybin, Double_t uybin, TString xaxistitle, TString yaxistitle)
{
  TH2F* histogram = new TH2F(name, name, xbins, lxbin, uxbin, ybins, lybin, uybin);
  TAxis* xaxis = histogram->GetXaxis();
  xaxis->SetTitle(xaxistitle);
  TAxis* yaxis = histogram->GetYaxis();
  yaxis->SetTitle(yaxistitle);
  return histogram;
}

// this code has been copied from https://twiki.cern.ch/twiki/bin/view/AtlasProtected/MinBiasD3PDDocu#CTP_Information
bool RealTrackTree::trigger_L1_MBTS_1()
{


// bool eventPasses = (ei_bcid == 1 && ei_RunNumber == 152166) || ((ei_bcid == 1 || ei_bcid == 201 || ei_bcid == 301 || ei_bcid == 1786 
//      || ei_bcid == 1886 || ei_bcid == 1986 || ei_bcid == 2086)&& ei_RunNumber == 155697);

  bool eventPasses = true;

 if (eventPasses)
 {
   bool triggerOK = false;
   for (unsigned int i = 0 ; i < ctp_decisionItems->size() ; i++)
   {
     if (ctp_decisionItems->at(i) == "L1_MBTS_1") { triggerOK = true; continue; }
   }
   eventPasses = triggerOK;
 } else return false;


 return eventPasses; 
 
// return true;
 
}//end of trigger selectio function

bool RealTrackTree::good_run()
{
  bool good_run = true;
  
 // if(ei_RunNumber == 152166 && ei_lbn < 205 ) good_run = false;
  
  return good_run;

}


double RealTrackTree::error_func( float  x, Double_t *par)
{
//calculating the square of the propagated error on the fit values
 return  ( TMath::Power(par[0],2) +  x * TMath::Power(par[1],2) +   TMath::Power(x * par[2],2)) ;

}
