/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

// csc_cosmic_cluster.cxx

// Woochun Park
// Nov 1, 2007
//
// Main program to loop over entries in a cluster tree to find clusters from
// cosmic muon tracks.
//
// The classes ClusterAccessor used to access the trees
// are generated by root. If changes are made, run this program with option
// -g and copy the headers to the include directory CscClusterPerformance.

#include <string>
#include <iostream>
using namespace std;
using std::cout;
#include <iomanip>
using std::setw;
using std::setiosflags;
using std::setprecision;
#include <sstream>
#include <map>
#include <vector>
#include "TTree.h"
#include "TTreeIndex.h"
#include "CscClusterPerformance/SimposAccessor.h"
#include "CscClusterPerformance/ClusterAccessor.h"
#include <cmath>

using std::string;
using std::map;
using std::cout;
using std::endl;
using std::cerr;
using std::istringstream;

// To build a exe that only generates the ROOTT interface classes.
#undef  GENERATE_ONLY

typedef std::vector<int> EntryList;
typedef std::vector<std::string> NameList;
namespace {

// Class to hold event number.
  class Runevt {
    int m_run;
    int m_evt;
  public:
    Runevt(int run, int evt) : m_run(run), m_evt(evt) { }
    int run() const { return m_run; }
    int evt() const { return m_evt; }
    int operator<(const Runevt& rhs) const {
      if ( run() == rhs.run() ) return evt() < rhs.evt();
      return run() < rhs.run();
    }
    int operator==(const Runevt& rhs) const {
      return run() == rhs.run() && evt() == rhs.evt();
    }
  };

  std::ostream& operator<<(std::ostream& str, const Runevt& rhs) {
    str << rhs.run() << ":" << rhs.evt();
    return str;
  }

  class Cluster {
    float m_pos;
    float m_dpos;
    int m_phisec;
    int m_wlay;
    float m_x;
    float m_y;
    float m_z;
  public:
    Cluster(float pos, float dpos, float z)
      : m_pos(pos), m_dpos(dpos), m_phisec(-1), m_wlay(-1),
        m_x(-9999.), m_y(-9999.), m_z(z) { }
    float z()    const { return m_z; }
    float pos()    const { return m_pos; }
    float dpos()   const { return m_dpos; }
    float weight() const { return 1./m_dpos/m_dpos; }
    float zpos()   const { return (m_phisec-1)*12.55 + (m_wlay-1)*2.05;}
  };
}  // end unnamed namespace
//typedef std::vector<Cluster*> Clusters;



////////////////////////////

void fit_segment(const std::vector<Cluster*>& clus, float& s0, float& s1, float& d0, float& d1, float& d01, float& chsq ) {
  float q0 = 0.0;
  float q1 = 0.0;
  float q2 = 0.0;
  float q01 = 0.0;
  float q11 = 0.0;
  float q02 = 0.0;
  s0=0.;
  s1=0.;
  d0=0.;
  d1=0.;
  d01=0.;
  chsq =0.;

  for ( std::vector<Cluster*>::const_iterator iclu=clus.begin(); iclu!=clus.end(); ++iclu ) {
    const Cluster& clu = **iclu;
    float y = clu.pos();
    float z = clu.z();
    float d = clu.dpos();
    float w = 1.0/(d*d);
    q0 += w;
    q1 += w*z;
    q2 += w*z*z;
    q01 += w*y;
    q11 += w*z*y;
    q02 += w*y*y;
  }
  float r00 = q2/(q2*q0-q1*q1);
  float r01 = q1/(q1*q1-q2*q0);
  float r10 = q1/(q1*q1-q0*q2);
  float r11 = q0/(q0*q2-q1*q1);
  s0 = r01*q11 + r00*q01;
  s1 = r11*q11 + r10*q01;
  d0 = sqrt(r01*r01*q2 + 2.0*r00*r01*q1 + r00*r00*q0);
  d1 = sqrt(r11*r11*q2 + 2.0*r10*r11*q1 + r10*r10*q0);
  d01 = r01*r11*q2 + (r01*r10+r00*r11)*q1 + r00*r10*q0;
  chsq = q02 + s1*s1*q2 + 2*s0*s1*q1 + s0*s0*q0 - 2*s0*q01 - 2*s1*q11;
}

void fit_segment_eqwgt(const std::vector<Cluster*>& clus, float& s0, float& s1, float& d0, float& d1, float& d01, float& chsq ) {
  float q0 = 0.0;
  float q1 = 0.0;
  float q2 = 0.0;
  float q01 = 0.0;
  float q11 = 0.0;
  float q02 = 0.0;
  s0=0.;
  s1=0.;
  d0=0.;
  d1=0.;
  d01=0.;
  chsq =0.;

  for ( std::vector<Cluster*>::const_iterator iclu=clus.begin(); iclu!=clus.end(); ++iclu ) {
    const Cluster& clu = **iclu;
    float y = clu.pos();
    float z = clu.z();
    //    float d = clu.dpos();
    float w = 1.0;
    q0 += w;
    q1 += w*z;
    q2 += w*z*z;
    q01 += w*y;
    q11 += w*z*y;
    q02 += w*y*y;
  }
  float r00 = q2/(q2*q0-q1*q1);
  float r01 = q1/(q1*q1-q2*q0);
  float r10 = q1/(q1*q1-q0*q2);
  float r11 = q0/(q0*q2-q1*q1);
  s0 = r01*q11 + r00*q01;
  s1 = r11*q11 + r10*q01;
  d0 = sqrt(r01*r01*q2 + 2.0*r00*r01*q1 + r00*r00*q0);
  d1 = sqrt(r11*r11*q2 + 2.0*r10*r11*q1 + r10*r10*q0);
  d01 = r01*r11*q2 + (r01*r10+r00*r11)*q1 + r00*r10*q0;
  chsq = q02 + s1*s1*q2 + 2*s0*s1*q1 + s0*s0*q0 - 2*s0*q01 - 2*s1*q11;
}


//////////////
int main(int narg, char* argv[]) {
  bool help = false;
  bool generate = false;
  //  bool verbose = true;
  //  bool doPhi = false;
  int error = 0;
  int ndump = 0;
  string arg1;
  cout << narg << "  " << argv[0] << endl;
  // Read option flags.
  int iarg = 0;
  while ( ++iarg<narg && argv[iarg][0] == '-' ) {
    string opt = argv[iarg] + 1;
    if ( opt == "h" ) {
      help = true;
    } else if ( opt == "g" ) {
      generate = true;
    } else if ( opt == "d" ) {
      string sdump = argv[++iarg];
      istringstream ssdump(sdump);
      ssdump >> ndump;
    } else {
      cerr << "Uknown option: -" << opt << endl;
      error = 3;
    }
  }
  // Read the file names.
  if ( !error && !help ) {
    if ( iarg < narg ) {
      arg1 = argv[iarg++];
      //      if ( iarg < narg ) {
      //        arg2 = argv[iarg++];
      //      } else {
      //        cerr << "Second file name not found" << endl;
      //        error = 2;
      //      }
    } else {
      cout << "First file name not found" << endl;
      error = 1;
    }
  }

  if ( help ) {
    cout << "Usage: " << argv[0] << " [-g] simpos_file cluster_file" << endl;
    return error;
  }

  if ( error ) return error;

  // int x = (int);
  // char*chX='a';
  // int x = (int)*chX;

  // Open simpos file.
  TFile* psfile = new TFile(arg1.c_str(), "READ");
  TTree* pctree = dynamic_cast<TTree*>(psfile->Get("csc_cluster"));
  if ( pctree == 0 ) {
    cout << "Unable to retrieve simpos tree" << endl;
    cerr << "  File: " << arg1 << endl;
    psfile->Print();
    return 3;
  }
  cout << "Cluster tree has " << pctree->GetEntries() << " entries." << endl;
  if ( generate ) {
    cout << "Generating class ClusterAccessor" << endl;
    pctree->MakeClass("ClusterAccessor");
  } 

#ifndef GENERATE_ONLY
#define MAXENT 200
#define MAXSTRIP 10
#define MAXPOS 10
#define MAXEXTRA 20

  // Create result tree.
  int run;
  int evt;
  //  int nentry;                // Number of entries for each event.

  ClusterAccessor cluster(pctree);
  pctree->BuildIndex("run", "evt");

  int nsample =1000;
  //  int nsample =pctree->GetEntries();

  // Loop over events.
  for ( int icevt=1; icevt<nsample; ++icevt ) {
    cluster.GetEntry(icevt);
    run = cluster.run;
    evt = cluster.evt;
    Runevt re(run, evt);
    cout << "Processing run:event " << re << endl;
    int nclu = cluster.nentry;

    // Loop over clusters.
    float ref_value[2][4][4];
    int pid[2][4][4];
    for (int i=0; i<2; ++i)
      for (int j=0; j<4; ++j)
        for (int k=0; k<4; ++k) {
          ref_value[i][j][k] =0.;
          pid[i][j][k] =0;
        }

    for (int iphi=0; iphi<4; ++iphi)
      for (int ilay=0; ilay<4; ++ilay)
        for ( int iclu=0; iclu<nclu; ++iclu ){
          if (cluster.phisec[iclu]==iphi+1 && cluster.wlay[iclu]==ilay+1 )
            if (cluster.qpeak[iclu]>ref_value[cluster.measphi[iclu]][iphi][ilay]) {
              ref_value[cluster.measphi[iclu]][iphi][ilay] =cluster.qpeak[iclu];
              pid[cluster.measphi[iclu]][iphi][ilay] = iclu;
            }
        }

    std::vector<Cluster*> global_clus;
    for (Int_t iphi=3; iphi>=0; --iphi) {
      std::vector<Cluster*> clus;
      for (Int_t ilay=3; ilay>=0; --ilay) {
        /*
        cout << "  [" << iphi+1 << ", " << ilay+1 << "]  "
             << setw(7) << setprecision(2) << cluster.z[pid[0][iphi][ilay]]
             << setw(10) << setiosflags (ios::fixed) << setprecision(0) << cluster.qpeak[pid[0][iphi][ilay]]
             << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.pos[pid[0][iphi][ilay]]
             << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.error[pid[0][iphi][ilay]]
             << setw(5)  << setiosflags (ios::fixed) << cluster.strip0[pid[0][iphi][ilay]]
             << setw(5)  << setiosflags (ios::fixed) << cluster.pstrip[pid[0][iphi][ilay]]+cluster.strip0[pid[0][iphi][ilay]]
             << setw(4)  << setiosflags (ios::fixed) << cluster.sfit[pid[0][iphi][ilay]];
        if (doPhi)
          cout << setw(10) << setiosflags (ios::fixed) << setprecision(0) << cluster.qpeak[pid[1][iphi][ilay]]
               << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.pos[pid[1][iphi][ilay]]
               << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.error[pid[1][iphi][ilay]]
               << setw(5)  << setiosflags (ios::fixed) << cluster.strip0[pid[1][iphi][ilay]]
               << setw(5)  << setiosflags (ios::fixed) << cluster.pstrip[pid[1][iphi][ilay]]+cluster.strip0[pid[1][iphi][ilay]]
               << setw(4)  << setiosflags (ios::fixed) << cluster.sfit[pid[1][iphi][ilay]]
               << endl;
        else
          cout << endl;
        */
        float clupos =cluster.pos[pid[0][iphi][ilay]];
        float cludpos = cluster.error[pid[0][iphi][ilay]];
        float cluz = cluster.z[pid[0][iphi][ilay]];
        Cluster* clu = new Cluster(clupos, cludpos, cluz);
        clus.push_back(clu);
        global_clus.push_back(clu);
      }
      float s0, s1, d0, d1, d01, chsq;
      //      fit_segment(clus, s0, s1, d0, d1, d01, chsq);
      //      cout << s0 << " " << d0 << " " << s1 << " " << d1 << " " << chsq << endl;
      fit_segment_eqwgt(clus, s0, s1, d0, d1, d01, chsq);
      cout << "LOCAL  " <<  setw(7)  << setiosflags (ios::fixed) << setprecision(0) <<chsq << "  "
           << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.pos[pid[0][iphi][3]] << " "
           << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.pos[pid[0][iphi][2]] << " "
           << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.pos[pid[0][iphi][1]] << " "
           << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.pos[pid[0][iphi][0]] << " "
           <<endl;
    }
    float s0, s1, d0, d1, d01, chsq;
    //    fit_segment(global_clus, s0, s1, d0, d1, d01, chsq);
    //    cout << s0 << " " << d0 << " " << s1 << " " << d1 << " " << chsq << endl;
    fit_segment_eqwgt(global_clus, s0, s1, d0, d1, d01, chsq);
    cout << "GLOBAL "
         << setw(7)  << setiosflags (ios::fixed) << setprecision(0) << chsq
         << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.pos[pid[0][3][3]] << " "
         << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.pos[pid[0][3][2]] << " "
         << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.pos[pid[0][3][1]] << " "
         << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.pos[pid[0][3][0]] << " "
           << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.pos[pid[0][2][3]] << " "
           << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.pos[pid[0][2][2]] << " "
           << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.pos[pid[0][2][1]] << " "
           << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.pos[pid[0][2][0]] << " "
           << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.pos[pid[0][1][3]] << " "
           << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.pos[pid[0][1][2]] << " "
           << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.pos[pid[0][1][1]] << " "
           << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.pos[pid[0][1][0]] << " "
           << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.pos[pid[0][0][3]] << " "
           << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.pos[pid[0][0][2]] << " "
           << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.pos[pid[0][0][1]] << " "
           << setw(7)  << setiosflags (ios::fixed) << setprecision(1) << cluster.pos[pid[0][0][0]] << " "
         << endl;
    cout << endl;
    cout << endl;
    // Fill tree.
    //    nentry = ient;
    //    ptree->Fill();
  }  // end loop over events

  //  ptree->Print();
  //  pfile->Write();
#endif
  cout << "Done." << endl;
  return 0;
}

//******************************************************************************

// Fit a segment residual with a list of clusters.
// Segment is fit excluding cluster irclu and then the residual is calculated
// as the difference between the cluster position and that predicted by
// the segment. The error in the residual includes those of the segment and the
// excluded cluster.

/*
  void CscSegmentUtil::
fit_residual(const Clusters& clus, unsigned int irclu,
             float& res, float& dres) const {
  MsgStream log(m_alg.msgSvc(), m_alg.name());
  string prefix = "CscSegmentUtil::fit_residual: ";
  if ( debug () ) {
    std::cout << prefix << "Calculate residual for cluster " << irclu << std::endl;
  }
  Clusters fitclus;
  for ( unsigned int iclu=0; iclu<clus.size(); ++iclu ) {
    if ( iclu != irclu ) fitclus.push_back(clus[iclu]);
  }
  // Fit cluster.
  float s0, s1, d0, d1, d01, chsq;
  fit_segment(fitclus, s0, s1, d0, d1, d01, chsq);
  // Extract excluded cluster paramters.
  const CscCluster& clu = *clus[irclu];
  Identifier id = clu.identify();
  const CscReadoutElement* pro = m_gm.getCscReadoutElement(id);
  const HepPoint3D lpos = pro->localPos(clu.position());
  float y = lpos.y();
  float x = lpos.x();
  float d = clu.sigma();
  // Calculate predicted position and error.
  float seg_y = s0 + s1*x;
  float seg_dsquare = d0*d0 + 2.0*x*d01 + d1*d1;
  // Calculate residual and error.
  res = y - seg_y;
  dres = sqrt(d*d + seg_dsquare);
  if ( debug() ) {
    std::cout << prefix << "Residual " << irclu << ": " << res << " " << dres << std::endl;
  }
}
*/
// Build the skeleton functions.
#define ClusterAccessor_cxx
#include "CscClusterPerformance/ClusterAccessor.h"
void ClusterAccessor::Loop() { }
