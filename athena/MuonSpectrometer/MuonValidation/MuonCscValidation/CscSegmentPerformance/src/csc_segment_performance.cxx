/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

// csc_segment_performance.cxx

// David Adams
// June, 2006
//
// Main program to loop over entries in a simseg tree and find the matching
// entries in a segment tree.
//
// The classes SimsegAccessor and SegmentAccessor used to access the trees
// are generated byt root. If changes are made, run this program with option
// -g and copy the headers to the include directory CscClusterPerformance.

// To build a exe that only generates the ROOT interface classes.
#undef  GENERATE_ONLY

#include <cstdlib>
#include <string>
#include <iostream>
#include <sstream>
#include <vector>
#include "TFile.h"
#include "TTree.h"
#include "TTreeIndex.h"
#ifndef GENERATE_ONLY
#include "CscSegmentPerformance/SimsegAccessor.h"
#include "CscSegmentPerformance/SegmentAccessor.h"
#endif
#include "CscSegmentPerformance/SampleMatch.h"
#include <cmath>

using std::string;
using std::cout;
using std::cerr;
using std::endl;
using std::istringstream;
using std::map;

typedef std::vector<int> EntryList;

namespace {

// Class to hold event number.
class Runevt {
  int m_run;
  int m_evt;
public:
  Runevt(int run, int evt) : m_run(run), m_evt(evt) { }
  int run() const { return m_run; }
  int evt() const { return m_evt; }
  int operator<(const Runevt& rhs) const {
    if ( run() == rhs.run() ) return evt() < rhs.evt();
    return run() < rhs.run();
  }
  int operator==(const Runevt& rhs) const {
    return run() == rhs.run() && evt() == rhs.evt();
  }
};

std::ostream& operator<<(std::ostream& str, const Runevt& rhs) {
  str << rhs.run() << ":" << rhs.evt();
  return str;
}

const int maxchamber = 32;

// Class to identify a chamber.
class Chamber {
  int m_istation;
  int m_zsec;
  int m_phisec;
public:
  static int max() { return maxchamber; }
  // Constructors.
  Chamber(int istation, int zsec, int phisec)
  : m_istation(istation), m_zsec(zsec), m_phisec(phisec) { }
  Chamber(int ichm) {
    if ( ichm > 15 ) {
      m_istation = 2;
      ichm -= 16;
    } else {
      m_istation = 1;
    }
    if ( ichm > 7 ) {
      ichm -= 8;
      m_zsec = 1;
    } else {
      m_zsec = -1;
    }
    m_phisec = ichm+1;
  }
  // Return indices.
  int istation() const { return m_istation; }
  int phisec() const { return m_phisec; }
  int zsec() const { return m_zsec; }
  // Return index in range 0-31.
  int index() {
    return (m_istation-1)*16 + (m_zsec+1)*4 + m_phisec-1;
  }
};
// Output stream.
  std::ostream& operator<<(std::ostream& str, const Chamber& rhs) {
  if ( rhs.istation() == 1 ) str << "CSS";
  else str << "CSL";
  if ( rhs.zsec() < 0 ) str << "-";
  else str << "+";
  str << rhs.phisec();
  return str;
}

class RecSeg;

// Class to hold simulated segments.
class SimSeg {
public:
  int issg;
  int ichm;
  double y;
  double z;
  double ay;
  double az;
  double eta;
  double pt;
  const RecSeg* prec_phi;
  const RecSeg* prec_eta;
public:  // methods
  SimSeg() : issg(0), ichm(0), y(0.0), z(0.0), ay(0.0), az(0.0),
             eta(0.0), pt(0.0), prec_phi(0), prec_eta(0) { }
};

typedef std::vector<const SimSeg*> SimSegList;

// Class to hold reconstructed segments.
class RecSeg {
public:
  int irsg;
  int ichm;
  bool measphi;
  int nspoil;
  int nunspoil;
  double p;      // position
  double a;      // angle
  double dp;
  double da;
  double dpa;
  double chsq;
};

typedef std::vector<const RecSeg*> RecSegList;

// Distance from reco to sim.
class DistRecSim {
public:
  double operator()(const RecSeg& rseg, const SimSeg& sseg) const {
    // Residuals.
    double p0 = rseg.measphi ? sseg.y : sseg.z;
    double p1 = rseg.measphi ? sseg.ay : sseg.az;
    double r0 = rseg.p - p0;
    double r1 = rseg.a - p1;
    // Weight matrix.
    double d0 = rseg.dp;
    double d1 = rseg.da;
    double d01 = rseg.dpa;
    double den = d0*d0*d1*d1 - d01*d01;
    double w00 = d1*d1/den;
    double w11 = d0*d0/den;
    double w01 = -d01/den;
    // Weighted distance.
    double dist2 = w00*r0*r0 + w11*r1*r1 + 2.0*w01*r0*r1;
    double dist = sqrt(dist2);
    cout << "DistRecSim: dist=" << dist << " res=(" << r0 << "," << r1 << ") "
         << " err = (" << d0 << "," << d1 << ")" << endl;
    cout << "  Measphi: " << rseg.measphi << endl;
    cout << "  Sim: " << p0 << " " << p1 << endl;
    cout << "  Rec: " << rseg.p << " " << rseg.a << endl;
    return dist;
  }
};
DistRecSim recdist;

// Distance from sim to reco.
class DistSimRec {
public:
  double operator()(const SimSeg& sseg, const RecSeg& rseg) const {
    // Residuals.
    double p0 = rseg.measphi ? sseg.y : sseg.z;
    double p1 = rseg.measphi ? sseg.ay : sseg.az;
    double r0 = rseg.p - p0;
    double r1 = rseg.a - p1;
    // Weight matrix.
    double dpos = 1.0;    // Expected error in position
    double len = 77;      // Distance between position measurments.
    double w00 = 1.0/dpos/dpos;
    double w11 = 4.0*len*len/dpos/dpos;
    // Weighted distance.
    double dist2 = w00*r0*r0 + w11*r1*r1;
    double dist = sqrt(dist2);
    cout << "DistSimRec: dist=" << dist << " res=(" << r0 << "," << r1 << ") " << endl;
    return dist;
  }
};
DistSimRec simdist;

typedef SampleMatch<SimSeg, RecSeg, SimSegList, RecSegList, DistSimRec, DistRecSim> Match;

}  // end unnamed namespace

int main(int narg, char* argv[]) {
  bool help = false;
  bool generate = false;
  int error = 0;
  int ndump = 0;
  string arg1;
  string arg2;
  // Read option flags.
  int iarg = 0;
  while ( ++iarg<narg && argv[iarg][0] == '-' ) {
    string opt = argv[iarg] + 1;
    if ( opt == "h" ) {
      help = true;
    } else if ( opt == "g" ) {
      generate = true;
    } else if ( opt == "d" ) {
      string sdump = argv[++iarg];
      istringstream ssdump(sdump);
      ssdump >> ndump;
    } else {
      cerr << "Uknown option: -" << opt << endl;
      error = 3;
    }
  }
  // Read the file names.
  if ( !error && !help ) {
    if ( iarg < narg ) {
      arg1 = argv[iarg++];
      if ( iarg < narg ) {
        arg2 = argv[iarg++];
      } else {
        cerr << "Second file name not found" << endl;
        error = 2;
      }
    } else {
      cout << "First file name not found" << endl;
      error = 1;
    }
  }

  if ( help ) {
    cout << "Usage: " << argv[0] << " [-g] simseg_file segment_file" << endl;
    return error;
  }

  if ( error ) return error;

  // Open simseg file.
  TFile* psfile = new TFile(arg1.c_str(), "READ");
  TTree* pstree = dynamic_cast<TTree*>(psfile->Get("csc_simseg"));
  if ( pstree == 0 ) {
    cout << "Unable to retrieve simseg tree" << endl;
    cerr << "  File: " << arg1 << endl;
    psfile->Print();
    return 3;
  }
  cout << "Simseg tree has " << pstree->GetEntries() << " entries." << endl;
  if ( generate ) {
    cout << "Generating class SimsegAccessor" << endl;
    pstree->MakeClass("SimsegAccessor");
  } 

  // Open segment file.
  TFile* pcfile = new TFile(arg2.c_str(), "READ");
  TTree* pctree = dynamic_cast<TTree*>(pcfile->Get("csc_segment"));
  if ( pctree == 0 ) {
    cout << "Unable to retrieve segment tree" << endl;
    cerr << "  File: " << arg2 << endl;
    pcfile->Print();
    return 4;
  }
  cout << "Segment tree has " << pctree->GetEntries() << " entries." << endl;
  if ( generate ) {
    cout << "Generating class SegmentAccessor" << endl;
    pctree->MakeClass("SegmentAccessor");
    return 0;
  } 

#ifndef GENERATE_ONLY
#define MAXENT 400
#define MAXSTRIP 10

  // Create result tree.
  // ..event fields
  int run;
  int evt;
  int ient;                  // Number of entries for each event.
  int nfakey;                // # phi fakes/event
  int nfakez;                // # r fakes/event
  // ..entry status
  int staty[MAXENT];         // 0=found, 1=lost, 2=fake, 3=nothing
  int statz[MAXENT];
  // ..truth info
  float yh[MAXENT];          // Simulation position in local coordinates.
  float zh[MAXENT];
  float ayh[MAXENT];         // Simulation direction atan(dx/dy) in local coordinates.
  float azh[MAXENT];
  float eta[MAXENT];         // Eta at production vertex.
  float pt[MAXENT];          // PT at production vertex.
  // ..reco info
  int nspoily[MAXENT];       // # spoiled clusters in the segment.
  int nspoilz[MAXENT];
  int nunspoily[MAXENT];     // # unspoiled clusters in the segment.
  int nunspoilz[MAXENT];
  float y[MAXENT];           // Segment paramters. 
  float z[MAXENT];
  float ay[MAXENT];
  float az[MAXENT];
  float dy[MAXENT];          // Segment errors.
  float dz[MAXENT];
  float day[MAXENT];
  float daz[MAXENT];
  float ey[MAXENT];          // Segment error correlations: y-ay
  float ez[MAXENT];
  float chsqy[MAXENT];       // Reconstruction chi-square.
  float chsqz[MAXENT];     
  float drecy[MAXENT];       // Reconstructed to simulated distance (error matrix weight)
  float drecz[MAXENT];
  float dsimy[MAXENT];       // Simulated to reconstructed distance (fixed weight)
  float dsimz[MAXENT];
  int zsec[MAXENT];          // Z-sector (-1, +1)
  int istation[MAXENT];      // station (1=CSS, 2=CSL)
  int phisec[MAXENT];        // phi-sector (1-8)
  int sector[MAXENT];        // zsec*(2*phisec-istation+1)
  TFile* pfile = new TFile("csc_segperf.root", "RECREATE");
  TTree* ptree = new TTree("csc_segperf", "CSC 2D segment performance");
  ptree->Branch("run",     &run,      "run/I");
  ptree->Branch("evt",     &evt,      "evt/I");
  ptree->Branch("nentry",  &ient,     "nentry/I");
  ptree->Branch("nfakey",  &nfakey,   "nfakey/I");
  ptree->Branch("nfakez",  &nfakez,   "nfakez/I");
  ptree->Branch("yh",       yh,       "yh[nentry]");
  ptree->Branch("zh",       zh,       "zh[nentry]");
  ptree->Branch("ayh",      ayh,      "ayh[nentry]");
  ptree->Branch("azh",      azh,      "azh[nentry]");
  ptree->Branch("eta",      eta,      "eta[nentry]");
  ptree->Branch("pt",       pt,       "pt[nentry]");
  ptree->Branch("nspoily",  nspoily,  "nspoily[nentry]/I");
  ptree->Branch("nspoilz",  nspoilz,  "nspoilz[nentry]/I");
  ptree->Branch("nunspoily",nunspoily,"nunspoily[nentry]/I");
  ptree->Branch("nunspoilz",nunspoilz,"nunspoilz[nentry]/I");
  ptree->Branch("y",        y,        "y[nentry]");
  ptree->Branch("staty",    staty,    "staty[nentry]/I");
  ptree->Branch("statz",    statz,    "statz[nentry]/I");
  ptree->Branch("z",        z,        "z[nentry]");
  ptree->Branch("ay",       ay,       "ay[nentry]");
  ptree->Branch("az",       az,       "az[nentry]");
  ptree->Branch("dy",       dy,       "dy[nentry]");
  ptree->Branch("dz",       dz,       "dz[nentry]");
  ptree->Branch("day",      day,      "day[nentry]");
  ptree->Branch("daz",      daz,      "daz[nentry]");
  ptree->Branch("ey",       ey,       "ey[nentry]");
  ptree->Branch("ez",       ez,       "ez[nentry]");
  ptree->Branch("chsqy",    chsqy,    "chsqy[nentry]");
  ptree->Branch("chsqz",    chsqz,    "chsqz[nentry]");
  ptree->Branch("drecy",    drecy,    "drecy[nentry]");
  ptree->Branch("drecz",    drecz,    "drecz[nentry]");
  ptree->Branch("dsimy",    dsimy,    "dsimy[nentry]");
  ptree->Branch("dsimz",    dsimz,    "dsimz[nentry]");
  ptree->Branch("zsec",     zsec,     "zsec[nentry]/I");
  ptree->Branch("istation", istation, "istation[nentry]/I");
  ptree->Branch("phisec",   phisec,   "phisec[nentry]/I");
  ptree->Branch("sector",   sector,   "sector[nentry]/I");

  SimsegAccessor simseg(pstree);
  SegmentAccessor segment(pctree);
  //  pctree->BuildIndex("run", "evt");
  
  // Build index for segment tree.
  typedef map<Runevt, int> EvtIndex;
  EvtIndex segment_index;
  for ( int isevt=0; isevt<pstree->GetEntries(); ++isevt ) {
    segment.GetEntry(isevt);
    Runevt re(segment.run, segment.evt);
    segment_index[re] = isevt;
    cout << "Index: " << re << " " << isevt << endl;
  }

  // Assign limits for matching distances.
  double max_simdist = 1000;
  double good_simdist =  10;
  double max_recdist = 1000;
  double good_recdist =  10;
  cout << "Maximum sim distance is " << max_simdist << endl;
  cout << "   Good sim distance is " << good_simdist << endl;
  cout << "Maximum rec distance is " << max_recdist << endl;
  cout << "   Good rec distance is " << good_recdist << endl;

  // Loop over events.
  int nevt = 0;
  int ntot = 0;
  int nfound_phi = 0;
  int nlost_phi = 0;
  int nfake_phi = 0;
  int nfound_eta = 0;
  int nlost_eta = 0;
  int nfake_eta = 0;
  for ( int isevt=0; isevt<pstree->GetEntries(); ++isevt ) {
    ++nevt;
    simseg.GetEntry(isevt);
    run = simseg.run;
    evt = simseg.evt;
    ient = 0;
    Runevt re(run, evt);
    cout << "Processing run:event " << re << endl;
    int nssg = simseg.nentry;
    // Fetch the segments for this event.
    EvtIndex::const_iterator iisevt = segment_index.find(re);
    if ( iisevt == segment_index.end() ) {
      cout << "  Event not found in segment tree!" << endl;
      continue;
    }
    int jsevt = iisevt->second;
    segment.GetEntry(jsevt);
    // Fetch sim segments.
    SimSegList simseg_map[maxchamber];
    for ( int issg=0; issg<nssg; ++issg ) {
      if ( issg > MAXENT ) {
        cout << "Too many sim segments!!!" << endl;
        abort();
      }
      SimSeg* psseg = new SimSeg;
      SimSeg& sseg = *psseg;
      int ichm = Chamber(simseg.istation[issg], simseg.zsec[issg],
                         simseg.phisec[issg]).index();
      sseg.issg = issg;
      sseg.ichm = ichm;
      sseg.y = simseg.y[issg];
      sseg.z = simseg.z[issg];
      sseg.ay = simseg.axy[issg];
      sseg.az = simseg.axz[issg];
      sseg.eta = simseg.eta[issg];
      sseg.pt = simseg.pt[issg];
      simseg_map[ichm].push_back(psseg);
    }
    // Fetch reco segments.
    RecSegList recseg_eta_map[maxchamber];
    RecSegList recseg_phi_map[maxchamber];
    // Loop over segments.
    for ( int irsg=0; irsg<segment.nentry; ++irsg ) {
      RecSeg* prseg = new RecSeg;
      RecSeg& rseg = *prseg;
      int ichm = Chamber(segment.istation[irsg], segment.zsec[irsg],
                         segment.phisec[irsg]).index();
      rseg.irsg = irsg;
      rseg.ichm = ichm;
      rseg.measphi = segment.measphi[irsg];
      rseg.nspoil = segment.nspoil[irsg];
      rseg.nunspoil = segment.nunspoil[irsg];
      rseg.p = segment.s0[irsg];
      rseg.a = segment.sa[irsg];
      rseg.dp = segment.d0[irsg];
      rseg.da = segment.da[irsg];
      rseg.dpa = segment.d0a[irsg];
      rseg.chsq = segment.chsq[irsg];
      if ( rseg.measphi ) {
        recseg_phi_map[ichm].push_back(prseg);
      } else {
        recseg_eta_map[ichm].push_back(prseg);
      }
    }
    // Loop over chambers and look for matches.
    nfakey = 0;
    nfakez = 0;
    for ( int ichm=0; ichm<maxchamber; ++ichm ) {
      Chamber chm(ichm);
      SimSegList& simsegs = simseg_map[ichm];
      ntot += simsegs.size();
      RecSegList& recsegs_phi = recseg_phi_map[ichm];
      RecSegList& recsegs_eta = recseg_eta_map[ichm];
      RecSegList fake_eta;
      if ( true ) {
         // Phi matching
        cout << chm << "p has " << simsegs.size() << " simulated and "
             << recsegs_phi.size() << " reconstructed phi segments." << endl;
        Match matphi(simsegs, recsegs_phi, simdist, recdist,
                  max_simdist, good_simdist, max_recdist, good_recdist);
        nfakey += matphi.fake().size();
        nfound_phi += matphi.found().size();
        nlost_phi += matphi.lost().size();
        nfake_phi += matphi.fake().size();
        cout << matphi << endl;
        const Match::EvalMap& found_phi = matphi.found();
        const Match::RefDistanceMap& simdist_phi = matphi.found_reference_distance();
        const Match::EvalDistanceMap& recdist_phi = matphi.found_evaluation_distance();
        const Match::EvalList& fake_phi = matphi.fake();
        // R matching
        cout << chm << "r has " << simsegs.size() << " simulated and "
             << recsegs_eta.size() << " reconstructed r segments." << endl;
        Match mateta(simsegs, recsegs_eta, simdist, recdist,
                  max_simdist, good_simdist, max_recdist, good_recdist);
        nfakez += mateta.fake().size();
        nfound_eta += mateta.found().size();
        nlost_eta += mateta.lost().size();
        nfake_eta += mateta.fake().size();
        cout << mateta << endl;
        const Match::EvalMap& found_eta = mateta.found();
        const Match::RefDistanceMap& simdist_eta = mateta.found_reference_distance();
        const Match::EvalDistanceMap& recdist_eta = mateta.found_evaluation_distance();
        const Match::EvalList& fake_eta = mateta.fake();
        // Fill found and lost tree variables for this segment.
        for ( SimSegList::const_iterator issg=simsegs.begin();
              issg!=simsegs.end(); ++issg ) {
          const SimSeg* psseg = *issg;
          const SimSeg& sseg = *psseg;
          Match::EvalMap::const_iterator ifnd_phi = found_phi.find(psseg);
          const RecSeg* precy = ifnd_phi==found_phi.end() ? 0 : ifnd_phi->second;
          Match::EvalMap::const_iterator ifnd_eta = found_eta.find(psseg);
          const RecSeg* precz = ifnd_eta==found_eta.end() ? 0 : ifnd_eta->second;
          istation[ient] = chm.istation();
          zsec[ient] = chm.zsec();
          phisec[ient] = chm.phisec();
          sector[ient] = zsec[ient]* (2*phisec[ient]-istation[ient]+1);
          yh[ient] = sseg.y;
          zh[ient] = sseg.z;
          ayh[ient] = sseg.ay;
          azh[ient] = sseg.az;
          eta[ient] = sseg.eta;
          pt[ient] = sseg.pt;
          // Rec phi
          if ( precy ) {
            const RecSeg& rseg = *precy;
            staty[ient] = 0;
            nspoily[ient] = rseg.nspoil;
            nunspoily[ient] = rseg.nunspoil;
            y[ient] = rseg.p;
            ay[ient] = rseg.a;
            dy[ient] = rseg.dp;
            day[ient] = rseg.da;
            ey[ient] = rseg.dpa;
            chsqy[ient] = rseg.chsq;
            dsimy[ient] = simdist_phi.find(psseg)->second;
            drecy[ient] = recdist_phi.find(psseg)->second;
          } else {
            staty[ient] = 1;
            nspoily[ient] = 0;
            nunspoily[ient] = 0;
            y[ient] = 0.0;
            ay[ient] = 0.0;
            dy[ient] = 0.0;
            day[ient] = 0.0;
            ey[ient] = 0.0;
            chsqy[ient] = 0.0;
            dsimy[ient] = 0.0;
            drecy[ient] = 0.0;
          }
          // Rec r
          if ( precz ) {
            const RecSeg& rseg = *precz;
            statz[ient] = 0;
            nspoilz[ient] = rseg.nspoil;
            nunspoilz[ient] = rseg.nunspoil;
            z[ient] = rseg.p;
            az[ient] = rseg.a;
            dz[ient] = rseg.dp;
            daz[ient] = rseg.da;
            ez[ient] = rseg.dpa;
            chsqz[ient] = rseg.chsq;
            dsimz[ient] = simdist_eta.find(psseg)->second;
            drecz[ient] = recdist_eta.find(psseg)->second;
          } else {
            statz[ient] = 1;
            nspoilz[ient] = 0;
            nunspoilz[ient] = 0;
            z[ient] = 0.0;
            az[ient] = 0.0;
            dz[ient] = 0.0;
            daz[ient] = 0.0;
            ez[ient] = 0.0;
            chsqz[ient] = 0.0;
            dsimz[ient] = 0.0;
            drecz[ient] = 0.0;
          }
          // ...
          ++ient;
        }  // end loop over sim segs
        // Add phi fakes.
        for ( Match::EvalList::const_iterator irsg=fake_phi.begin();
              irsg!=fake_phi.end(); ++irsg ) {
          const RecSeg& rseg = **irsg;
          istation[ient] = chm.istation();
          zsec[ient] = chm.zsec();
          phisec[ient] = chm.phisec();
          sector[ient] = zsec[ient]* (2*phisec[ient]-istation[ient]+1);
          yh[ient] = 0.0;
          zh[ient] = 0.0;
          ayh[ient] = 0.0;
          azh[ient] = 0.0;
          staty[ient] = 2;
          nspoily[ient] = rseg.nspoil;
          nunspoily[ient] = rseg.nunspoil;
          y[ient] = rseg.p;
          ay[ient] = rseg.a;
          dy[ient] = rseg.dp;
          day[ient] = rseg.da;
          ey[ient] = rseg.dpa;
          chsqy[ient] = rseg.chsq;
          dsimy[ient] = 0.0;
          drecy[ient] = 0.0;
          statz[ient] = 3;
          nspoilz[ient] = 0;
          nunspoilz[ient] = 0;
          z[ient] = 0.0;
          az[ient] = 0.0;
          dz[ient] = 0.0;
          daz[ient] = 0.0;
          ez[ient] = 0.0;
          chsqz[ient] = 0.0;
          dsimz[ient] = 0.0;
          drecz[ient] = 0.0;
          ++ient;
        }  // end loop over phi fakes
        // Add r fakes.
        for ( Match::EvalList::const_iterator irsg=fake_eta.begin();
              irsg!=fake_eta.end(); ++irsg ) {
          const RecSeg& rseg = **irsg;
          istation[ient] = chm.istation();
          zsec[ient] = chm.zsec();
          phisec[ient] = chm.phisec();
          sector[ient] = zsec[ient]* (2*phisec[ient]-istation[ient]+1);
          yh[ient] = 0.0;
          zh[ient] = 0.0;
          ayh[ient] = 0.0;
          azh[ient] = 0.0;
          // rec phi
          staty[ient] = 3;
          nspoily[ient] = 0;
          nunspoily[ient] = 0;
          y[ient] = 0.0;
          ay[ient] = 0.0;
          dy[ient] = 0.0;
          day[ient] = 0.0;
          ey[ient] = 0.0;
          chsqy[ient] = 0.0;
          dsimy[ient] = 0.0;
          drecy[ient] = 0.0;
          statz[ient] = 2;
          nspoilz[ient] = rseg.nspoil;
          nunspoilz[ient] = rseg.nunspoil;
          z[ient] = rseg.p;
          az[ient] = rseg.a;
          dz[ient] = rseg.dp;
          daz[ient] = rseg.da;
          ez[ient] = rseg.dpa;
          chsqz[ient] = rseg.chsq;
          dsimz[ient] = 0.0;
          drecz[ient] = 0.0;
          ++ient;
        }  // end loop over r fakes
      }  // end if simsegs.size()
      // Delete local segments.
      for ( RecSegList::const_iterator irsg=recsegs_phi.begin();
            irsg!=recsegs_phi.end(); ++irsg ) delete *irsg;
      recsegs_phi.clear();
      for ( RecSegList::const_iterator irsg=recsegs_eta.begin();
            irsg!=recsegs_eta.end(); ++irsg ) delete *irsg;
      recsegs_eta.clear();
      for ( SimSegList::const_iterator issg=simsegs.begin();
            issg!=simsegs.end(); ++issg ) delete *issg;
      simsegs.clear();
    }  // End loop over chambers
    // Fill tree for this events.
    ptree->Fill();
  } // End loop over events

  // Display result summary.
  cout << "Eta efficiency = " << nfound_eta << "/" << ntot << " = ";
  if( ntot != 0 ) cout << double(nfound_eta)/double(ntot) << endl;
  else cout << "nan" << endl;
  cout << "Eta fakes/event = " << nfake_eta << "/" << nevt << " = ";
  if( nevt != 0 ) cout << double(nfake_eta)/double(nevt) << endl;
  else cout << "nan" << endl;
  cout << "Phi efficiency = " << nfound_phi << "/" << ntot << " = ";
  if( ntot != 0 ) cout << double(nfound_phi)/double(ntot) << endl;
  else cout << "nan" << endl;
  cout << "Phi fakes/event = " << nfake_phi << "/" << nevt << " = ";
  if( nevt != 0 ) cout << double(nfake_phi)/double(nevt) << endl;
  else cout << "nan" << endl;

  // Write output file.
  pfile->Write();

#endif
  cout << "Done." << endl;
  return 0;
}

// Build the skeleton functions.
#ifndef GENERATE_ONLY
#define SimsegAccessor_cxx
#include "CscSegmentPerformance/SimsegAccessor.h"
void SimsegAccessor::Loop() { }
#define SegmentAccessor_cxx
#include "CscSegmentPerformance/SegmentAccessor.h"
void SegmentAccessor::Loop() { }
#endif
