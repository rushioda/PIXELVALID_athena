/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

// csc_layer_efficiency.cxx

// Woochun Park
// November 6, 2009
//
// Main program to loop over segments and find layer efficiency out of it
// playing with threshold.

// The classes CalibAccessor and SegmentAccessor used to access the trees
// are generated byt root. If changes are made, run this program with option
// -g and copy the headers to the include directory CscClusterPerformance.

// To build a exe that only generates the ROOT interface classes.
#undef  GENERATE_ONLY

#include <cstdlib>
#include <string>
#include <iostream>
#include <sstream>
#include <vector>
#include "TFile.h"
#include "TTree.h"
#include "TGraphErrors.h"
#include "TH1.h"
#include "TTreeIndex.h"
#ifndef GENERATE_ONLY
#include "CscSegmentPerformance/CalibAccessor.h"
#include "CscSegmentPerformance/SegmentAccessor.h"
#include "CscSegmentPerformance/ClusterAccessor.h"
#include "CscSegmentPerformance/SampleMatch.h"
#endif
#include <cmath>
#include <algorithm>

using std::string;
using std::cout;
using std::cerr;
using std::endl;
using std::istringstream;
using std::map;
using std::vector;

namespace {
  enum NoiseOption {
    RMS,
    Sigma,
    F001
  };
  ///////////////////////
  // Global Variabls
  //  double kFactor=20000;
  //  double T0=0;
  //  NoiseOption noiseOption=Sigma;
  const int maxchamber = 32;
  
  double f001[maxchamber][4][2][192]; // 32 sector 4 layer 0/1 192 channel
  double rms[maxchamber][4][2][192]; // 32 sector 4 layer 0/1 192 channel
  double sigma[maxchamber][4][2][192]; // 32 sector 4 layer 0/1 192 channel
  

  int getSectorIdx(int isector); 
  int getIdxToSector(int ichm); 
  class RecSeg;
  int getabit(NoiseOption opt, double T0, double kFactor, const RecSeg* s);
  int getabit(NoiseOption opt, double T0, double kFactor, const vector<double>& qps, const  vector<int>& pids, int sector, bool meas);
  double getNoise( NoiseOption opt, unsigned int isector, unsigned int ilay, unsigned int imeas, unsigned int ist);

  class RecClu;
  bool getastrip(NoiseOption opt, double T0, double kFactor, const RecClu* c);
  bool getastrip(NoiseOption opt, double T0, double kFactor, double qpeak, int pid,
                 int sector, int wlay, bool meas);

  
  // Class to hold reconstructed segments.
  class RecSeg {
  public:
    int    run;
    int    evt;
    int    sector;
    bool   measphi;
    int   abit;
    vector<double> qpeaks;      // position
    vector<int>    pids;      // angle
    RecSeg() : run(0), evt(0), sector(0), measphi(0), abit(0) {}
    //
    void print() const {
      cout << "---->" << run << ":" << evt << "   " <<sector << " " << measphi << " " << abit << endl;
      for (unsigned int i=0; i<4; ++i)
        cout << qpeaks[i] << "  " << pids[i] << "  " << getNoise(F001,sector,i,measphi,pids[i]) <<  endl;
    }
  };
  typedef std::vector<const RecSeg*> RecSegList;

  class RecClu {
  public:
    int    run;
    int    evt;
    int    sector;
    bool   measphi;
    bool   astrip;
    double qpeak;
    int    pid;
    int    wlay;
    RecClu() : run(0), evt(0), sector(0), measphi(0), astrip(0), qpeak(0.0), pid(0), wlay(0) {}
    //
    void print() const {
      cout << "---->" << run << ":" << evt << "   " <<sector << " " << wlay << " " << measphi << " "
           << astrip << " " << qpeak << " " << pid << endl;
    }
  };
  typedef std::vector<const RecClu*> RecCluList;
}  // end unnamed namespace


/////////////////////////////////////////////////////////////////////
//  MAIN Starts!!!!
///////////////////////////////////////////////////////////////////////

int main(int narg, char* argv[]) {
  bool help = false;
  bool generate = false;
  int error = 0;
  int ndump = 0;
  string arg1;
  string arg2;

  //////// Read option flags.
  int iarg = 0;
  while ( ++iarg<narg && argv[iarg][0] == '-' ) {
    string opt = argv[iarg] + 1;

    if ( opt == "h" )      help = true;
    else if ( opt == "g" ) generate = true;
    else if ( opt == "d" ) {
      string sdump = argv[++iarg];
      istringstream ssdump(sdump);
      ssdump >> ndump;
    } else {
      cerr << "Uknown option: -" << opt << endl;
      error = 3;
    }
  }

  //////// Read the file names.
  // Read the file names.
  if ( !error && !help ) {
    if ( iarg < narg ) {
      arg1 = argv[iarg++];
      if ( iarg < narg ) {
        arg2 = argv[iarg++];
      } else {
        cerr << "Second file name not found" << endl;
        error = 2;
      }
    } else {
      cout << "First file name not found" << endl;
      error = 1;
    }
  }

  if ( help ) {
    cout << "Usage: " << argv[0] << " [-g] simseg_file segment_file" << endl;
    return error;
  }

  if ( error ) return error;

  // Open calib & segment for signal..... file.
  TFile* psfile = new TFile(arg1.c_str(), "READ");
  TTree* pstree = dynamic_cast<TTree*>(psfile->Get("csc_calib"));
  TTree* pctree = dynamic_cast<TTree*>(psfile->Get("csc_segment"));
  if ( pstree == 0 || pctree ==0 ) {
    cout << "Unable to retrieve csc_calib or csc_segment tree" << endl;
    cerr << "  File: " << arg1 << endl;
    psfile->Print();
    return 3;
  }

  cout << "csc_calib tree has " << pstree->GetEntries() << " entries." << endl;
  cout << "Segment tree has " << pctree->GetEntries() << " entries." << endl;
  if ( generate ) {
    cout << "Generating class CalibAccessor" << endl;
    pstree->MakeClass("CalibAccessor");

    cout << "Generating class SegmentAccessor" << endl;
    pctree->MakeClass("SegmentAccessor");
    return 0;
  } 



  // Open segment file.
  TFile* pfkfile = new TFile(arg2.c_str(), "READ");
  TTree* pfktree = dynamic_cast<TTree*>(pfkfile->Get("csc_cluster"));
  if ( pfktree == 0 ) {
    cout << "Unable to retrieve cluster tree" << endl;
    cerr << "  File: " << arg2 << endl;
    pfkfile->Print();
    return 4;
  }

#ifndef GENERATE_ONLY
#define MAXENT 400
#define MAXSTRIP 10
  
  // fill Calib constants!!!!!
  //  fillCalibTable(pstree);
  TFile* pfile = new TFile("csc_layerEff.root", "RECREATE");

  const int nPlays=30;

  TH1F *hqpeak[32][4][2];
  TH1F *hqpeakFk[32][4][2];
  TH1F *hf001[32][4][2], *hrms[32][4][2], *hsigma[32][4][2];
  for (int k=0; k<2; ++k) {
    for (int i=0; i<32; ++i) {
      for (int j=0; j<4; ++j) {
        hqpeak[i][j][k]   = new TH1F(Form("qps%dl%dm%d",i,j,k),
                                     Form("sec %d: lay %d: measphi %d; Qpeak",getIdxToSector(i),j+1,k),
                                     100, 0, 2500000);
        hqpeakFk[i][j][k] = new TH1F(Form("qpFks%dl%dm%d",i,j,k),
                                     Form("sec %d: lay %d: measphi %d; Qpeak",getIdxToSector(i),j+1,k),
                                     100, 0, 250000);
        hf001[i][j][k]    = new TH1F(Form("f001_s%dl%dm%d",i,j,k),
                                     Form("sec %d: lay %d: measphi %d; f001",getIdxToSector(i),j+1,k),
                                     100, 0, 40000);
        hrms[i][j][k]     = new TH1F(Form("rms_s%dl%dm%d",i,j,k),
                                     Form("sec %d: lay %d: measphi %d; rms",getIdxToSector(i),j+1,k),
                                     100, 0, 40000);
        hsigma[i][j][k]   = new TH1F(Form("sigma_s%dl%dm%d",i,j,k),
                                     Form("sec %d: lay %d: measphi %d; sigma",getIdxToSector(i),j+1,k),
                                     100, 0, 40000);
      }
    }
  }

  TH1F *layEffEtaf001[32][4], *layEffPhif001[32][4];
  TH1F *layEffEtarms[32][4], *layEffPhirms[32][4];
  TH1F *layEffEtasigma[32][4], *layEffPhisigma[32][4];

  TH1F *layFakeEtaf001[32][4], *layFakePhif001[32][4];
  TH1F *layFakeEtarms[32][4], *layFakePhirms[32][4];
  TH1F *layFakeEtasigma[32][4], *layFakePhisigma[32][4];
  for (int is=0; is<32; ++is) {
    for (int i=0; i<4; ++i) {
      layEffEtaf001[is][i]   = new TH1F(Form("layEffEtaf001_s%dl%d", is, i+1),
                                        Form("sec %d: lay %d; Eff",getIdxToSector(is),i+1),
                                        nPlays, 0, nPlays);
      layEffPhif001[is][i]   = new TH1F(Form("layEffPhif001_s%dl%d", is, i+1),
                                        Form("sec %d: lay %d; Eff",getIdxToSector(is),i+1),
                                        nPlays, 0, nPlays);
      layEffEtarms[is][i]    = new TH1F(Form("layEffEtarms_s%dl%d", is, i+1),
                                        Form("sec %d: lay %d; Eff",getIdxToSector(is),i+1),
                                        nPlays, 0, nPlays);
      layEffPhirms[is][i]    = new TH1F(Form("layEffPhirms_s%dl%d", is, i+1),
                                        Form("sec %d: lay %d; Eff",getIdxToSector(is),i+1),
                                        nPlays, 0, nPlays);
      layEffEtasigma[is][i]  = new TH1F(Form("layEffEtasigma_s%dl%d", is, i+1),
                                        Form("sec %d: lay %d; Eff",getIdxToSector(is),i+1),
                                        nPlays, 0, nPlays);
      layEffPhisigma[is][i]  = new TH1F(Form("layEffPhisigma_s%dl%d", is, i+1),
                                        Form("sec %d: lay %d; Eff",getIdxToSector(is),i+1),
                                        nPlays, 0, nPlays);
      
      layFakeEtaf001[is][i]  = new TH1F(Form("layFakeEtaf001_s%dl%d", is, i+1),
                                        Form("sec %d: lay %d; Fake",getIdxToSector(is),i+1),
                                        nPlays, 0, nPlays);
      layFakePhif001[is][i]  = new TH1F(Form("layFakePhif001_s%dl%d", is, i+1),
                                        Form("sec %d: lay %d; Fake",getIdxToSector(is),i+1),
                                        nPlays, 0, nPlays);
      layFakeEtarms[is][i]   = new TH1F(Form("layFakeEtarms_s%dl%d", is, i+1),
                                        Form("sec %d: lay %d; Fake",getIdxToSector(is),i+1),
                                        nPlays, 0, nPlays);
      layFakePhirms[is][i]   = new TH1F(Form("layFakePhirms_s%dl%d", is, i+1),
                                        Form("sec %d: lay %d; Fake",getIdxToSector(is),i+1),
                                        nPlays, 0, nPlays);
      layFakeEtasigma[is][i] = new TH1F(Form("layFakeEtasigma_s%dl%d", is, i+1),
                                        Form("sec %d: lay %d; Fake",getIdxToSector(is),i+1),
                                        nPlays, 0, nPlays);
      layFakePhisigma[is][i] = new TH1F(Form("layFakePhisigma_s%dl%d", is, i+1),
                                        Form("sec %d: lay %d; Fake",getIdxToSector(is),i+1),
                                        nPlays, 0, nPlays);
    }
  }
  
  CalibAccessor   calib(pstree);

  for ( int i=0; i<pstree->GetEntries(); ++i ) { // 32*4*2 = 256
    calib.GetEntry(i);
    
    unsigned int isector;
    int tmpsector = getSectorIdx(calib.sector);
    if( tmpsector < 0 ) continue;
    else isector = (unsigned int) tmpsector; 
    unsigned int ilay    =calib.wlay-1;
    unsigned int imeas   =calib.measphi;
    
    for (int ist=0; ist<calib.nchan; ++ist) {
      f001[isector][ilay][imeas][ist] = calib.f001[ist];
      rms[isector][ilay][imeas][ist]  = calib.rms[ist];
      sigma[isector][ilay][imeas][ist] = calib.sigma[ist];

      hf001[isector][ilay][imeas] ->Fill(f001[isector][ilay][imeas][ist]);
      hrms[isector][ilay][imeas]  ->Fill(rms[isector][ilay][imeas][ist]);
      hsigma[isector][ilay][imeas]->Fill(sigma[isector][ilay][imeas][ist]);
    }
  }



  SegmentAccessor segment(pctree);

  RecSegList recseg_eta_map[maxchamber];
  RecSegList recseg_phi_map[maxchamber];

  int cntMultSegEvent =0;
  for ( int iev=0; iev<pctree->GetEntries(); ++iev ) {

    if (iev %1000 == 0 && iev>0 ) cout << iev << " entries processed!!" << endl;
    
    segment.GetEntry(iev);

    if (segment.nentry <2) continue;
    
    bool singleSegment_map[maxchamber];
    int nseg_eta_map[maxchamber];
    int nseg_phi_map[maxchamber];
    for (int i=0; i<maxchamber; ++i) {
      singleSegment_map[i] = false;
      nseg_eta_map[i] =0;
      nseg_phi_map[i] =0;
    }

    // fill up initail value....
    bool hasEtaSeg=false;
    bool hasPhiSeg=false;
    for (int isg=0; isg<segment.nentry; ++isg) {
      int ichm = getSectorIdx(segment.sector[isg]);
      if( ichm < 0 ) continue;
      bool measphi = segment.measphi[isg];
      if (measphi) {
        hasPhiSeg =true;
        nseg_phi_map[ichm]++;
      } else {
        hasEtaSeg =true;
        nseg_eta_map[ichm]++;
      }
    }

    if (hasPhiSeg && hasEtaSeg) cntMultSegEvent++;
    
    for (int i=0; i<maxchamber; ++i) {
      if (nseg_phi_map[i] ==1 && nseg_eta_map[i] ==1)
        singleSegment_map[i] = true;
    }

    /////////////////////////////////
    for (int isg=0; isg<segment.nentry; ++isg) {
      int ichm = getSectorIdx(segment.sector[isg]);
      if( ichm < 0 ) continue;
      //      if (segment.sector[isg]==14)
      //        cout << nseg_phi_map[ichm] << " " << nseg_eta_map[ichm] << endl;
      if (!singleSegment_map[ichm]) continue; // require single track per chamber...
      if (segment.hitmap[isg]<15)   continue; // require 4 hit segment...
      
      RecSeg* prseg = new RecSeg;
      RecSeg& rseg = *prseg;

      rseg.run     =segment.run;
      rseg.evt     =segment.evt;
      rseg.sector  =segment.sector[isg];
      rseg.measphi =segment.measphi[isg];
      rseg.abit    =segment.hitmap[isg];

      std::vector<double> qpeaks;
      std::vector<int> pids;
      for (int i=0; i<4; ++i) {
        qpeaks.push_back(segment.qpeak[isg][i]);
        pids.push_back(segment.pstr[isg][i]);
      }
      rseg.qpeaks = qpeaks;
      rseg.pids = pids;
      
      if (rseg.measphi)
        recseg_phi_map[ichm].push_back(prseg);
      else
        recseg_eta_map[ichm].push_back(prseg);
    }
  } // Loop over GetEntries...


  cout << " ---> " << cntMultSegEvent << " events has at least 1 4dSegment\n"; 
  ////////////////////////////////////
  //  Phase II
  ///////////////////////////////////////////////////////////
  double layEffCntEtaf001[32][4][nPlays];
  double layEffCntPhif001[32][4][nPlays];
  double layEffCntEtarms[32][4][nPlays];
  double layEffCntPhirms[32][4][nPlays];
  double layEffCntEtasigma[32][4][nPlays];
  double layEffCntPhisigma[32][4][nPlays];
  for (int k=0; k<32; ++k) 
    for (int j=0; j<4; ++j) 
      for (int i=0; i<nPlays; ++i) {  //*(pcnt+i)=0; // cnt[i] =0;
        layEffCntEtaf001[k][j][i]=0;
        layEffCntPhif001[k][j][i]=0;
        layEffCntEtarms[k][j][i]=0;
        layEffCntPhirms[k][j][i]=0;
        layEffCntEtasigma[k][j][i]=0;
        layEffCntPhisigma[k][j][i]=0;
      }

  //  int refSector = 14;
  unsigned int totEffNclu_eta = 0;
  unsigned int totEffNclu_phi = 0;
  for (int refSector=-16; refSector<=16; ++refSector) {
    int chmidx = getSectorIdx(refSector); // sector 14
    if (chmidx<0) continue;
    
    cout << "  ---> Total number of 4hit segment in Sector=" << refSector
         << "  Neta= " << recseg_eta_map[chmidx].size() << " Nphi= " << recseg_phi_map[chmidx].size() << endl;
    
    totEffNclu_eta += recseg_eta_map[chmidx].size();
    totEffNclu_phi += recseg_phi_map[chmidx].size();
    
    //  int* pcnt = cnt;
    // ETA....
    for (unsigned int isg=0; isg<recseg_eta_map[chmidx].size(); ++isg) {
      const RecSeg* pseg = recseg_eta_map[chmidx][isg];
      //    pseg->print();
      for (int j=0; j<4; j++) {
        hqpeak[chmidx][j][0]->Fill(pseg->qpeaks[j]);
        for (int i=0; i<nPlays; ++i) {
          int abit =  getabit(F001, 20000, i, pseg);
          if ( abit & int(pow(2.0, double(j))) )
            layEffCntEtaf001[chmidx][j][i]=layEffCntEtaf001[chmidx][j][i]+1;
          // *(pcnt+i) = *(pcnt+i) +1;//cnt[i]++;

          abit =  getabit(RMS, 20000, i, pseg);
          if ( abit & int(pow(2.0, double(j))) )
            layEffCntEtarms[chmidx][j][i]=layEffCntEtarms[chmidx][j][i]+1;

          abit =  getabit(Sigma, 20000, i, pseg);
          if ( abit & int(pow(2.0, double(j))) )
            layEffCntEtasigma[chmidx][j][i]=layEffCntEtasigma[chmidx][j][i]+1;
        }
      }
    }
    // PHI
    for (unsigned int isg=0; isg<recseg_phi_map[chmidx].size(); ++isg) {
      const RecSeg* pseg = recseg_phi_map[chmidx][isg];
      //    pseg->print();
      for (int j=0; j<4; j++) {
        hqpeak[chmidx][j][1]->Fill(pseg->qpeaks[j]);
        for (int i=0; i<nPlays; ++i) {
          int abit =  getabit(F001, 20000, i, pseg);
          if ( abit & int(pow(2.0, double(j))) )
            layEffCntPhif001[chmidx][j][i]=layEffCntPhif001[chmidx][j][i]+1;
          // *(pcnt+i) = *(pcnt+i) +1;//cnt[i]++;

          abit =  getabit(RMS, 20000, i, pseg);
          if ( abit & int(pow(2.0, double(j))) )
            layEffCntPhirms[chmidx][j][i]=layEffCntPhirms[chmidx][j][i]+1;

          abit =  getabit(Sigma, 20000, i, pseg);
          if ( abit & int(pow(2.0, double(j))) )
            layEffCntPhisigma[chmidx][j][i]=layEffCntPhisigma[chmidx][j][i]+1;
        }
      }
    }
  } // loop over sector....
  ///////////////////////////////
  for (int k=0; k<32; ++k) {
    unsigned int toteta = recseg_eta_map[k].size();
    unsigned int totphi = recseg_phi_map[k].size();
    for (int j=0; j<4; ++j) {
      layEffEtaf001[k][j]->SetMinimum(0.90);
      layEffPhif001[k][j]->SetMinimum(0.90);
      layEffEtarms[k][j]->SetMinimum(0.90);
      layEffPhirms[k][j]->SetMinimum(0.90);
      layEffEtasigma[k][j]->SetMinimum(0.90);
      layEffPhisigma[k][j]->SetMinimum(0.90);
      for (int i=0; i<nPlays; ++i) {
        if (toteta ==0) {
          layEffEtaf001[k][j] ->SetBinContent(i+1, -1.);
          layEffEtarms[k][j]  ->SetBinContent(i+1, -1.);
          layEffEtasigma[k][j]->SetBinContent(i+1, -1.);
        } else {
          layEffEtaf001[k][j] ->SetBinContent(i+1, layEffCntEtaf001[k][j][i] /toteta);
          layEffEtarms[k][j]  ->SetBinContent(i+1, layEffCntEtarms[k][j][i]  /toteta);
          layEffEtasigma[k][j]->SetBinContent(i+1, layEffCntEtasigma[k][j][i]/toteta);
        }

        if (totphi ==0) {
          layEffPhif001[k][j] ->SetBinContent(i+1, -1.);
          layEffPhirms[k][j]  ->SetBinContent(i+1, -1.);
          layEffPhisigma[k][j]->SetBinContent(i+1, -1.);
        } else {
          layEffPhif001[k][j] ->SetBinContent(i+1, layEffCntPhif001[k][j][i] /totphi);
          layEffPhirms[k][j]  ->SetBinContent(i+1, layEffCntPhirms[k][j][i]  /totphi);
          layEffPhisigma[k][j]->SetBinContent(i+1, layEffCntPhisigma[k][j][i]/totphi);
        }
        
      }
    }
  }

  cout << " ----> Number of Segments Used..  " << totEffNclu_eta << "  " <<  totEffNclu_phi << endl;

  ////////////////////////////////////
  //   PHASE III : FAKE Study...
  //////////////////////////////////////////////

  ClusterAccessor cluster(pfktree);

  RecCluList recclu_eta_map[maxchamber];
  RecCluList recclu_phi_map[maxchamber];

  int totalFakeCntEta[32][4];
  int totalFakeCntPhi[32][4];
  for (int k=0; k<32; ++k) {
    for (int j=0; j<4; ++j) {
      totalFakeCntEta[k][j]=0;
      totalFakeCntPhi[k][j]=0;
    }
  }
  
  for ( int iev=0; iev<pfktree->GetEntries(); ++iev ) {

    if (iev %1000 == 0 && iev>0 ) cout << iev << " entries processed!!" << endl;
    
    cluster.GetEntry(iev);

    for (int icl=0; icl<cluster.nentry; ++icl) {
      int ichm = getSectorIdx(cluster.sector[icl]);
      if( ichm < 0 ) continue;

      RecClu* prclu = new RecClu;
      RecClu& rclu = *prclu;

      rclu.run     =cluster.run;
      rclu.evt     =cluster.evt;
      rclu.sector  =cluster.sector[icl];
      rclu.measphi =cluster.measphi[icl];
      rclu.wlay    =cluster.wlay[icl];
      rclu.qpeak   =cluster.qpeak[icl];
      rclu.pid     =cluster.strip0[icl]+cluster.pstrip[icl];
      
      if (rclu.measphi) {
        recclu_phi_map[ichm].push_back(prclu);
        ++totalFakeCntPhi[ichm][rclu.wlay-1];
      } else {
        recclu_eta_map[ichm].push_back(prclu);
        ++totalFakeCntEta[ichm][rclu.wlay-1];
      }
    }
  } // Loop over GetEntries...


  for (int i=0; i<maxchamber; ++i) 
    cout << " ---> " << getIdxToSector(i) << "  "
         << recclu_eta_map[i].size() << " " << recclu_phi_map[i].size() << endl;


  for (int k=0; k<32; ++k) {
    for (int i=0; i<4; ++i) {
      cout << " --> Sec:Layer " << getIdxToSector(k) << "  " << i+1 << "  "
           << totalFakeCntEta[k][i] << " " << totalFakeCntPhi[k][i] << endl;
    }
  }


  double layFakeCntEtaf001[32][4][nPlays];
  double layFakeCntPhif001[32][4][nPlays];
  double layFakeCntEtarms[32][4][nPlays];
  double layFakeCntPhirms[32][4][nPlays];
  double layFakeCntEtasigma[32][4][nPlays];
  double layFakeCntPhisigma[32][4][nPlays];
  for (int k=0; k<32; ++k) 
    for (int j=0; j<4; ++j) 
      for (int i=0; i<nPlays; ++i) {  //*(pcnt+i)=0; // cnt[i] =0;
        layFakeCntEtaf001[k][j][i]=0;
        layFakeCntPhif001[k][j][i]=0;
        layFakeCntEtarms[k][j][i]=0;
        layFakeCntPhirms[k][j][i]=0;
        layFakeCntEtasigma[k][j][i]=0;
        layFakeCntPhisigma[k][j][i]=0;
      }

  
  for (int i=0; i<maxchamber; ++i) {
    // ETA
    //    cout << i << " " << recclu_eta_map[i].size() << " " << recclu_phi_map[i].size() << endl;
    for (unsigned int j=0; j<recclu_eta_map[i].size(); ++j) {
      const RecClu* pclu = recclu_eta_map[i][j];
      int ilay = pclu->wlay -1;
      hqpeakFk[i][ilay][0]->Fill(pclu->qpeak);

      
      for (int ipl=0; ipl<nPlays; ++ipl) {
        if ( getastrip(F001, 20000, ipl, pclu) )
          layFakeCntEtaf001[i][ilay][ipl]=layFakeCntEtaf001[i][ilay][ipl]+1;
        if ( getastrip(RMS, 20000, ipl, pclu) )
          layFakeCntEtarms[i][ilay][ipl]=layFakeCntEtarms[i][ilay][ipl]+1;
        if ( getastrip(Sigma, 20000, ipl, pclu) )
          layFakeCntEtasigma[i][ilay][ipl]=layFakeCntEtasigma[i][ilay][ipl]+1;
      }
    }
    // PHI

    for (unsigned int j=0; j<recclu_phi_map[i].size(); ++j) {
      const RecClu* pclu = recclu_phi_map[i][j];
      int ilay = pclu->wlay -1;
      hqpeakFk[i][ilay][1]->Fill(pclu->qpeak);
      
      for (int ipl=0; ipl<nPlays; ++ipl) {
        if ( getastrip(F001, 20000, ipl, pclu) )
          layFakeCntPhif001[i][ilay][ipl]=layFakeCntPhif001[i][ilay][ipl]+1;
        if ( getastrip(RMS, 20000, ipl, pclu) )
          layFakeCntPhirms[i][ilay][ipl]=layFakeCntPhirms[i][ilay][ipl]+1;
        if ( getastrip(Sigma, 20000, ipl, pclu) )
          layFakeCntPhisigma[i][ilay][ipl]=layFakeCntPhisigma[i][ilay][ipl]+1;
      }
    }
    
  } // all chamber

  ////////////////////////////////////
  //  Phase IV
  ///////////////////////////////////////////////////////////

  for (int k=0; k<32; ++k) {
    for (int j=0; j<4; ++j) {
      layFakeEtaf001[k][j]->SetMinimum(0.0);
      layFakePhif001[k][j]->SetMinimum(0.0);
      layFakeEtarms[k][j]->SetMinimum(0.0);
      layFakePhirms[k][j]->SetMinimum(0.0);
      layFakeEtasigma[k][j]->SetMinimum(0.0);
      layFakePhisigma[k][j]->SetMinimum(0.0);
      
      for (int i=0; i<nPlays; ++i) {
        if (k==11)
          cout << "eta ichm:lay= " << k << ":L" << j
               << "  " << layFakeCntEtaf001[k][j][0] << endl;
      
        if (totalFakeCntEta[k][j]==0) {
          layFakeEtaf001[k][j] ->SetBinContent(i+1, -1.);
          layFakeEtarms[k][j]  ->SetBinContent(i+1, -1.);
          layFakeEtasigma[k][j]->SetBinContent(i+1, -1.);
        } else {
          layFakeEtaf001[k][j] ->SetBinContent(i+1, layFakeCntEtaf001[k][j][i] /totalFakeCntEta[k][j]);
          layFakeEtarms[k][j]  ->SetBinContent(i+1, layFakeCntEtarms[k][j][i]  /totalFakeCntEta[k][j]);
          layFakeEtasigma[k][j]->SetBinContent(i+1, layFakeCntEtasigma[k][j][i]/totalFakeCntEta[k][j]);
        }

        if (totalFakeCntPhi[k][j]==0) {
          layFakePhif001[k][j] ->SetBinContent(i+1, -1.);
          layFakePhirms[k][j]  ->SetBinContent(i+1, -1.);
          layFakePhisigma[k][j]->SetBinContent(i+1, -1.);
        } else {
          layFakePhif001[k][j] ->SetBinContent(i+1, layFakeCntPhif001[k][j][i] /totalFakeCntPhi[k][j]);
          layFakePhirms[k][j]  ->SetBinContent(i+1, layFakeCntPhirms[k][j][i]  /totalFakeCntPhi[k][j]);
          layFakePhisigma[k][j]->SetBinContent(i+1, layFakeCntPhisigma[k][j][i]/totalFakeCntPhi[k][j]);
        }
      }
    }
  }
  
  pfile->Write();
  pfile->Close();


#endif
  cout << "Done." << endl;
  return 0;
}

// Build the skeleton functions.
#ifndef GENERATE_ONLY
#define CalibAccessor_cxx
#include "CscSegmentPerformance/CalibAccessor.h"
void CalibAccessor::Loop() { }
#define ClusterAccessor_cxx
#include "CscSegmentPerformance/ClusterAccessor.h"
void ClusterAccessor::Loop() { }
#define SegmentAccessor_cxx
#include "CscSegmentPerformance/SegmentAccessor.h"
void SegmentAccessor::Loop() { }

namespace{
  int getSectorIdx(int isector) {// A wheel : 0-15  C wheel 16-31
    if (abs(isector)<1 || abs(isector)>16) return -1;
    return (isector>0) ? isector-1 : -1*isector+15;
  }
  int getIdxToSector(int ichm) {// A wheel : 0-15  C wheel 16-31
    if (ichm>=0 && ichm <16) return ichm+1;
    else if (ichm >= 16 && ichm <32) return -1*(ichm-15);
    else return -99;
  }
  ////////////////////////////////
  double getNoise( NoiseOption opt,
                   unsigned int isector, unsigned int ilay,
                   unsigned int imeas,   unsigned int ist) { // 0  
    if (opt == RMS) {
      return rms[isector][ilay][imeas][ist];
    } else if (opt == Sigma) {
      return sigma[isector][ilay][imeas][ist];
    } else if (opt == F001) {
      return f001[isector][ilay][imeas][ist];
    } else {
      cout << "NoiseOption is not set up!!!!!!! << endl";
      return 3.5;
    }
  }

  ///////////////////////////////////
  int getabit(NoiseOption opt, double T0, double kFactor,
              const vector<double>& qps, const  vector<int>& pids,
              int sector, bool meas){
              

    unsigned int isector;
    int tmpsector = getSectorIdx(sector);
    if( tmpsector < 0 ) {
      cout << "invalid sector!!" << endl;
      return -1;
    }
    else isector = (unsigned int) tmpsector;
    int abit=0;
    if (qps.size()!=4) {
      cout << "qpeaks size should be 4!!" << endl;
      return -1;
    }
    
    for (int ilay=0; ilay<4; ++ilay) {
      double qpeak=qps[ilay];
      double noise =getNoise(opt,isector,ilay,meas,pids[ilay]-1); // starting from 0
      double threshold = std::max(T0,kFactor*noise);
      if (qpeak >= threshold )
        abit += int( pow(2.0, double(ilay)) );

      //      cout << "   ---> getabit " << ilay << " " << qpeak << "  " << threshold << "  " << abit << endl;


    }
    return abit;    
  }
  ///////////////////////////////////
  int getabit(NoiseOption opt, double T0, double kFactor, const RecSeg* s) {
    int abit =getabit(opt, T0, kFactor, s->qpeaks, s->pids, s->sector, s->measphi);
    return abit;
  }

  ///////////////////////////////////
  bool getastrip(NoiseOption opt, double T0, double kFactor, const RecClu* s) {
    return getastrip(opt, T0, kFactor, s->qpeak, s->pid, s->sector, s->wlay, s->measphi);
  }


  ///////////////////////////////////
  bool getastrip(NoiseOption opt, double T0, double kFactor,
              double qpeak, int pid, int sector, int wlay, bool meas){
    unsigned int isector;
    int tmpsector = getSectorIdx(sector);
    if( tmpsector < 0 ) {
      cout << "invalid sector!!" << endl;
      return false;
    }
    else isector = (unsigned int) tmpsector;
    double noise =getNoise(opt,isector,wlay-1,meas,pid-1); // starting from 0
    double threshold = std::max(T0,kFactor*noise);

    //    if (isector ==11 && wlay==1 && opt == F001)
      //      cout << qpeak << " " << pid << " " << noise << " " << kFactor*noise << endl;

    return (qpeak >= threshold );
  }


}

#endif
