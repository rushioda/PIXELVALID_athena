/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

// Dear emacs, this is -*-c++-*-

//=============================================================================
// Constructor
//=============================================================================
template < class T, class CT >
D2PDSelectorBase< T, CT >::D2PDSelectorBase( const std::string& name,
                                             ISvcLocator* pSvcLocator ) :
  AthFilterAlgorithm ( name, pSvcLocator ),
  m_userDataSvc( "UserDataSvc", name ),
  m_kinSelectorTool( "KinematicSelector", this ),
  m_userDataHelperTool( "UserDataHelperTool", this ),
  m_filterTool( "FilterTool", this ),
  m_selectionTools(this),
  m_selectorTools(this),
  m_associationTools(this),
  m_userDataCalcTools(this),
  m_inputIsLinkColl(false),
  m_doPt(false),
  m_idxPt(0),
  m_doP(false),
  m_idxP(0),
  m_doEt(false),
  m_idxEt(0),
  m_doE(false),
  m_idxE(0),
  m_doEta(false),
  m_idxEta(0),
  m_doAbsEta(false),
  m_idxAbsEta(0),
  m_doEtaVeto(false),
  m_idxEtaVeto(0),
  m_doPhi(false),
  m_idxPhi(0),
  m_doPhiVeto(false),
  m_idxPhiVeto(0),
  m_doMass(false),
  m_idxMass(0),
  m_doSelectionTools(false),
  m_idxSelectionTools(0),
  m_doSelectorTools(false),
  m_idxSelectorTools(0),
  m_doAssociationTools(false),
  m_idxAssociationTools(0),
  m_doUserDataTools(false),
  m_idxUserDataTools(0),
  m_idxFinal(0),
  m_nEventsProcessed(0),
  m_nObjectsProcessed(0),
  m_nObjectsPassed(0)
{
  // Properties go here
  declareProperty("printSetup",              m_printSetup   = false, "Printing the setup if true" );
  declareProperty("printSummary",            m_printSummary = false, "Printing the summary if true" );
  declareProperty("printInternalCutflow",    m_printInternalCutflow = false, "Print the internal cutflow of this algorithm" );
  declareProperty("printNDigits",            m_nDigits = 90, "Number of digits to print for the internal cutflow" );

  declareProperty("inputCollection",         m_inCollKey="",
                  "The name (i.e. StoreGate key) of the input container/collection" );
  declareProperty("outputCollection",        m_outCollKey="",
                  "The name (i.e. StoreGate key) of the output container/collection" );
  declareProperty("outputLinkCollection",    m_outLinkCollKey="",
                  "The name (i.e. StoreGate key) of the output Link container/collection" );

  declareProperty("kinematicSelectorTool",   m_kinSelectorTool, "Kinematic selection tool" );

  declareProperty("minNumberPassed",         m_minNumberPassed=0,
                  "Min number of selected objects" );
  declareProperty("maxNumberPassed",         m_maxNumberPassed=INT_MAX,
                  "Max number of selected objects" );

  declareProperty("ptMin",                   m_ptMin=-1.0*DBL_MAX, "Min P_T" );
  m_ptMin.declareUpdateHandler( &D2PDSelectorBase< T, CT >::setupPt, this );
  declareProperty("ptMax",                   m_ptMax=DBL_MAX,  "Max P_T" );
  m_ptMax.declareUpdateHandler( &D2PDSelectorBase< T, CT >::setupPt, this );

  declareProperty("pMin",                    m_pMin=-1.0*DBL_MAX, "Min P" );
  m_pMin.declareUpdateHandler( &D2PDSelectorBase< T, CT >::setupP, this );
  declareProperty("pMax",                    m_pMax=DBL_MAX,  "Max P" );
  m_pMax.declareUpdateHandler( &D2PDSelectorBase< T, CT >::setupP, this );

  declareProperty("etMin",                   m_etMin=-DBL_MAX, "Min E_T" );
  m_etMin.declareUpdateHandler( &D2PDSelectorBase< T, CT >::setupEt, this );
  declareProperty("etMax",                   m_etMax=DBL_MAX,  "Max E_T" );
  m_etMax.declareUpdateHandler( &D2PDSelectorBase< T, CT >::setupEt, this );

  declareProperty("eMin",                    m_eMin=-DBL_MAX,  "Min E" );
  m_eMin.declareUpdateHandler( &D2PDSelectorBase< T, CT >::setupE, this );
  declareProperty("eMax",                    m_eMax=DBL_MAX,   "Max E" );
  m_eMax.declareUpdateHandler( &D2PDSelectorBase< T, CT >::setupE, this );

  declareProperty("etaMin",                  m_etaMin=-DBL_MAX, "Min eta" );
  m_etaMin.declareUpdateHandler( &D2PDSelectorBase< T, CT >::setupEta, this );
  declareProperty("etaMax",                  m_etaMax=DBL_MAX,  "Max eta" );
  m_etaMax.declareUpdateHandler( &D2PDSelectorBase< T, CT >::setupEta, this );

  declareProperty("absEtaMin",               m_absEtaMin=-DBL_MAX, "Min |eta|" );
  m_absEtaMin.declareUpdateHandler( &D2PDSelectorBase< T, CT >::setupAbsEta, this );
  declareProperty("absEtaMax",               m_absEtaMax=DBL_MAX,  "Max |eta|" );
  m_absEtaMax.declareUpdateHandler( &D2PDSelectorBase< T, CT >::setupAbsEta, this );

  declareProperty("etaVetoRanges",           m_etaVetoRanges="", "Eta-ranges to veto" );
  m_etaVetoRanges.declareUpdateHandler( &D2PDSelectorBase< T, CT >::setupEtaVeto, this );

  declareProperty("phiMin",                  m_phiMin=-DBL_MAX, "Min phi" );
  m_phiMin.declareUpdateHandler( &D2PDSelectorBase< T, CT >::setupPhi, this );
  declareProperty("phiMax",                  m_phiMax=DBL_MAX,  "Max phi" );
  m_phiMax.declareUpdateHandler( &D2PDSelectorBase< T, CT >::setupPhi, this );

  declareProperty("phiVetoRanges",           m_phiVetoRanges="", "Phi-ranges to veto" );
  m_phiVetoRanges.declareUpdateHandler( &D2PDSelectorBase< T, CT >::setupPhiVeto, this );

  declareProperty("massMin",                 m_massMin=-DBL_MAX, "Min mass" );
  m_massMin.declareUpdateHandler( &D2PDSelectorBase< T, CT >::setupMass, this );
  declareProperty("massMax",                 m_massMax=DBL_MAX,  "Max mass" );
  m_massMax.declareUpdateHandler( &D2PDSelectorBase< T, CT >::setupMass, this );


  declareProperty("iSelectorToolList",       m_selectionTools, "List of ISelector tools to be used for selection" );
  declareProperty("selectorToolList",        m_selectorTools, "List of ObejectSelectorCore tools to be used for selection" );


  declareProperty("associationToolList",     m_associationTools, "List of AssociationTools to be used for matching" );
  declareProperty("forceExecuteAssociation", m_forceExecuteAssociation = false,
                  "Run the association tools, even if inputCollection is a link collection" );

  declareProperty("outputAssociationContainerList", m_outAssoCollKeys,
                  "List of the names of the output association maps (INav4MomAssocs)" );
  declareProperty("numberOfAssociationsMinCutList", m_assoMinCutList,
                  "List of the minimum number of associations an object has to have to pass this selection" );
  declareProperty("numberOfAssociationsMaxCutList", m_assoMaxCutList,
                  "List of the maximum number of associations an object has to have to pass this selection" );


  declareProperty("userDataSvc",             m_userDataSvc, "The UserData service" );
  declareProperty("forceExecuteUserData",    m_forceExecuteUserData=false,
                  "Run UserData calculation, even if inputCollection is a link collection" );

  declareProperty("userDataCalcToolList",    m_userDataCalcTools, "List of UserDataCalcTools to be used" );

  declareProperty("userDataNameList",        m_userDataNameList,   "List of UserData variables to be used for selections" );
  declareProperty("userDataMinCutList",      m_userDataMinCutList, "List of lower cut values for UserData selections" );
  declareProperty("userDataMaxCutList",      m_userDataMaxCutList, "List of upper cut values for UserData selections" );

  declareProperty("userDataHelperTool",      m_userDataHelperTool, "The tool to help retrieve UserData" );
  declareProperty("filterTool",              m_filterTool,         "The tool to help apply some filtering selections" );

  declareProperty("dumpStoreGate",           m_dumpStoreGate=false, "Flag to dump StoreGate content after each event" );

}





//=============================================================================
// Athena initialize method
//=============================================================================
template < class T, class CT >
StatusCode D2PDSelectorBase< T, CT >::initialize()
{
  // Print the used configuration
  if ( m_printSetup || msgLvl(MSG::DEBUG) )
    {
      ATH_MSG_INFO( "==> initialize " << name() << "...");
      
      // Print out the used configuration
      ATH_MSG_INFO( " using printSetup                     = " << m_printSetup );
      ATH_MSG_INFO( " using printSummary                   = " << m_printSummary );

      ATH_MSG_INFO( " using inputCollection                = " << m_inCollKey );
      ATH_MSG_INFO( " using outputCollection               = " << m_outCollKey );
      ATH_MSG_INFO( " using outputLinkCollection           = " << m_outLinkCollKey );

      ATH_MSG_INFO( " using minNumberPassed                = " << m_minNumberPassed );
      ATH_MSG_INFO( " using maxNumberPassed                = " << m_maxNumberPassed );

      ATH_MSG_INFO( " using ptMin                          = " << m_ptMin );
      ATH_MSG_INFO( " using ptMax                          = " << m_ptMax );

      ATH_MSG_INFO( " using pMin                           = " << m_pMin );
      ATH_MSG_INFO( " using pMax                           = " << m_pMax );

      ATH_MSG_INFO( " using etMin                          = " << m_etMin );
      ATH_MSG_INFO( " using etMax                          = " << m_etMax );

      ATH_MSG_INFO( " using eMin                           = " << m_eMin );
      ATH_MSG_INFO( " using eMax                           = " << m_eMax );

      ATH_MSG_INFO( " using etaMin                         = " << m_etaMin );
      ATH_MSG_INFO( " using etaMax                         = " << m_etaMax );
      ATH_MSG_INFO( " using etaVetoRanges                  = " << m_etaVetoRanges );

      ATH_MSG_INFO( " using absEtaMin                      = " << m_absEtaMin );
      ATH_MSG_INFO( " using absEtaMax                      = " << m_absEtaMax );

      ATH_MSG_INFO( " using phiMin                         = " << m_phiMin );
      ATH_MSG_INFO( " using phiMax                         = " << m_phiMax );
      ATH_MSG_INFO( " using phiVetoRanges                  = " << m_phiVetoRanges );

      ATH_MSG_INFO( " using massMin                        = " << m_massMin );
      ATH_MSG_INFO( " using massMax                        = " << m_massMax );

      ATH_MSG_INFO( " using kinematicSelectorTool          = " << m_kinSelectorTool );

      ATH_MSG_INFO( " using iSelectorToolList              = " << m_selectionTools );
      ATH_MSG_INFO( " using SelectorToolList               = " << m_selectorTools );

      ATH_MSG_INFO( " using associationToolList            = " << m_associationTools );
      ATH_MSG_INFO( " using outputAssociationContainerList = " << m_outAssoCollKeys );
      ATH_MSG_INFO( " using numberOfAssociationsMinCutList = " << m_assoMinCutList );
      ATH_MSG_INFO( " using numberOfAssociationsMaxCutList = " << m_assoMaxCutList );
      ATH_MSG_INFO( " using forceExecuteAssociation        = " << m_forceExecuteAssociation );

      ATH_MSG_INFO( " using userDataSvc                    = " << m_userDataSvc );
      ATH_MSG_INFO( " using forceExecuteUserData           = " << m_forceExecuteUserData );
      ATH_MSG_INFO( " using userDataCalcToolList           = " << m_userDataCalcTools );
      ATH_MSG_INFO( " using userDataNameList               = " << m_userDataNameList );
      ATH_MSG_INFO( " using userDataMinCutList             = " << m_userDataMinCutList );
      ATH_MSG_INFO( " using userDataMaxCutList             = " << m_userDataMaxCutList );

      ATH_MSG_INFO( " using userDataHelperTool             = " << m_userDataHelperTool );
      ATH_MSG_INFO( " using filterTool                     = " << m_filterTool );

      ATH_MSG_INFO( " using dumpStoreGate                  = " << m_dumpStoreGate );
    }



  // Get the UserData service
  ATH_CHECK( m_userDataSvc.retrieve() );

  // get the kinematic selector tool (derived class from ISelectorCore)
  ATH_CHECK( m_kinSelectorTool.retrieve() );

  // get the UserDataHelperTool 
  ATH_CHECK( m_userDataHelperTool.retrieve() );

  // get the FilterTool 
  ATH_CHECK( m_filterTool.retrieve() );

  // Get all the ISelector tools
  ATH_CHECK( m_selectionTools.retrieve() );

  // Get all the PATCore tools
  ATH_CHECK( m_selectorTools.retrieve() );

  // Get all the Association tools
  ATH_CHECK( m_associationTools.retrieve() );
  // Reserve the memory for the needed objects
  m_vecINav4MomAssocs.reserve( m_associationTools.size() );

  // Get all the UserDataCalcTools
  ATH_CHECK( m_userDataCalcTools.retrieve() );

   

  // Do some sanity checks on the user configuration
  bool problemFound(false);
  if ( m_inCollKey.empty() )
    {
      ATH_MSG_ERROR ( "Empty input collection! Please configure it properly!" );
      problemFound = true;
    }
  if ( m_outAssoCollKeys.size() != m_associationTools.size() )
    {
      ATH_MSG_ERROR ( "The outputAssociationContainerList has size = " << m_outAssoCollKeys.size()
                      << " and the associationToolList has size = " << m_associationTools.size()
                      << " but they have to have the same size! Please configure it properly..." );
      problemFound = true;
    }
  if ( m_assoMinCutList.size() != 0 && m_assoMinCutList.size() != m_associationTools.size() )
    {
      ATH_MSG_ERROR ( "The numberOfAssociationsMinCutList has size = " << m_assoMinCutList.size()
                      << " and the associationToolList has size = " << m_associationTools.size()
                      << " but they have to have the same size"
                      << " or the numberOfAssociationsMinCutList has to have zero size!"
                      << " Please configure it properly..." );
      problemFound = true;
    }
  if ( m_assoMaxCutList.size() != 0 && m_assoMaxCutList.size() != m_associationTools.size() )
    {
      ATH_MSG_ERROR ( "The numberOfAssociationsMaxCutList has size = " << m_assoMaxCutList.size()
                      << " and the associationToolList has size = " << m_associationTools.size()
                      << " but they have to have the same size"
                      << " or the numberOfAssociationsMaxCutList has to have zero size!"
                      << " Please configure it properly..." );
      problemFound = true;
    }
  if ( ( m_userDataMinCutList.size() != 0 && m_userDataNameList.size() != m_userDataMinCutList.size() )
       || ( m_userDataMaxCutList.size() != 0 && m_userDataNameList.size() != m_userDataMaxCutList.size() )
       )
    {
      ATH_MSG_ERROR ( "The userDataNameList does not have the same size as the userDataMinCutList and/or the userDataMaxCutList!"
                      << " userDataNameList.size()=" << m_userDataNameList.size()
                      << " userDataMinCutList.size()=" << m_userDataMinCutList.size()
                      << " userDataMaxCutList.size()=" << m_userDataMaxCutList.size() );
      problemFound = true;
    }
  if ( problemFound )
    {
      return StatusCode::FAILURE;
    }



  // Now, if the assoctions cut lists have zero size, fill them with the default cut (no cut)
  if ( m_associationTools.size() != 0 )
    {
      if ( m_assoMinCutList.size() == 0 )
        {
          for ( unsigned int i=0; i < m_associationTools.size(); ++i )
            {
              m_assoMinCutList.push_back( -INT_MAX );
            }
        }
      if ( m_assoMaxCutList.size() == 0 )
        {
          for ( unsigned int i=0; i < m_associationTools.size(); ++i )
            {
              m_assoMaxCutList.push_back( INT_MAX );
            }
        }
    } // End: if ( m_associationTools.size() != 0 )



  // Now, if one of the userDataMxxCutLists has zero size 
  // and the other doesn't, fill default cut values (no cut)
  if ( m_userDataNameList.size() != 0 )
    {
      if ( m_userDataMinCutList.size() ==  m_userDataNameList.size() && m_userDataMaxCutList.size() == 0 )
        {
          for ( unsigned int i=0; i < m_userDataNameList.size(); ++i )
            {
              m_userDataMaxCutList.push_back( DBL_MAX );
            }
        }
      if ( m_userDataMaxCutList.size() ==  m_userDataNameList.size() && m_userDataMinCutList.size() == 0 )
        {
          for ( unsigned int i=0; i < m_userDataNameList.size(); ++i )
            {
              m_userDataMinCutList.push_back( -DBL_MAX );
            }
        }
    }



  // Initialize the counters to zero
  m_nEventsProcessed = 0 ;
  m_nObjectsProcessed = 0 ;
  m_nObjectsPassed = 0 ;
  
  
  //--------------------------------------------------------------------------
  // Set the cut values for the selection tools
  //--------------------------------------------------------------------------
  m_kinSelectorTool->getTool()->setminPt( m_ptMin );
  m_kinSelectorTool->getTool()->setmaxPt( m_ptMax );

  m_kinSelectorTool->getTool()->setminP( m_pMin );
  m_kinSelectorTool->getTool()->setmaxP( m_pMax );

  m_kinSelectorTool->getTool()->setminEt( m_etMin );
  m_kinSelectorTool->getTool()->setmaxEt( m_etMax );

  m_kinSelectorTool->getTool()->setminE( m_eMin );
  m_kinSelectorTool->getTool()->setmaxE( m_eMax );

  m_kinSelectorTool->getTool()->setminEta( m_etaMin );
  m_kinSelectorTool->getTool()->setmaxEta( m_etaMax );

  m_kinSelectorTool->getTool()->setminAbsEta( m_absEtaMin );
  m_kinSelectorTool->getTool()->setmaxAbsEta( m_absEtaMax );

  m_kinSelectorTool->getTool()->setEtaVetoRanges( (std::string&)(m_etaVetoRanges.value()) );

  m_kinSelectorTool->getTool()->setminPhi( m_phiMin );
  m_kinSelectorTool->getTool()->setmaxPhi( m_phiMax );

  m_kinSelectorTool->getTool()->setPhiVetoRanges( (std::string&)(m_phiVetoRanges.value()) );

  m_kinSelectorTool->getTool()->setminMass( m_massMin );
  m_kinSelectorTool->getTool()->setmaxMass( m_massMax );


  ATH_MSG_DEBUG ( "KinematicSelectorTool:" << m_kinSelectorTool );



  // Determine which cut tools to run
  if ( m_selectionTools.size() > 0 )   m_doSelectionTools   = true;
  if ( m_selectorTools.size() > 0 )    m_doSelectorTools    = true;
  if ( m_assoMinCutList.size() > 0 )   m_doAssociationTools = true;
  if ( m_userDataNameList.size() > 0 ) m_doUserDataTools    = true;

  // Setup the internal cutflow stuff
  if ( m_printInternalCutflow )
    {
      if ( m_doPt )
        {
          m_idxPt = m_objCutFlow.size();
          m_objCutFlow.push_back(0);
          m_eventCutFlow.push_back( std::make_pair( Form( "%g < pt < %g", m_ptMin.value(), m_ptMax.value()), std::make_pair(0,0) ) );
        }
      if ( m_doP )
        {
          m_idxP = m_objCutFlow.size();
          m_objCutFlow.push_back(0);
          m_eventCutFlow.push_back( std::make_pair( Form( "%g < p < %g", m_pMin.value(), m_pMax.value()), std::make_pair(0,0) ) );
        }
      if ( m_doEt )
        {
          m_idxEt = m_objCutFlow.size();
          m_objCutFlow.push_back(0);
          m_eventCutFlow.push_back( std::make_pair( Form( "%g < et < %g", m_etMin.value(), m_etMax.value()), std::make_pair(0,0) ) );
        }
      if ( m_doE )
        {
          m_idxE = m_objCutFlow.size();
          m_objCutFlow.push_back(0);
          m_eventCutFlow.push_back( std::make_pair( Form( "%g < e < %g", m_eMin.value(), m_eMax.value()), std::make_pair(0,0) ) );
        }
      if ( m_doEta )
        {
          m_idxEta = m_objCutFlow.size();
          m_objCutFlow.push_back(0);
          m_eventCutFlow.push_back( std::make_pair( Form( "%g < eta < %g", m_etaMin.value(), m_etaMax.value()), std::make_pair(0,0) ) );
        }
      if ( m_doAbsEta )
        {
          m_idxAbsEta = m_objCutFlow.size();
          m_objCutFlow.push_back(0);
          m_eventCutFlow.push_back( std::make_pair( Form( "%g < |eta| < %g", m_absEtaMin.value(), m_absEtaMax.value()), std::make_pair(0,0) ) );
        }
      if ( m_doEtaVeto )
        {
          m_idxEtaVeto = m_objCutFlow.size();
          m_objCutFlow.push_back(0);
          m_eventCutFlow.push_back( std::make_pair( m_etaVetoRanges.value(), std::make_pair(0,0) ) );
        }
      if ( m_doPhi )
        {
          m_idxPhi = m_objCutFlow.size();
          m_objCutFlow.push_back(0);
          m_eventCutFlow.push_back( std::make_pair( Form( "%g < phi < %g", m_phiMin.value(), m_phiMax.value()), std::make_pair(0,0) ) );
        }
      if ( m_doPhiVeto )
        {
          m_idxPhiVeto = m_objCutFlow.size();
          m_objCutFlow.push_back(0);
          m_eventCutFlow.push_back( std::make_pair( m_phiVetoRanges.value(), std::make_pair(0,0) ) );
        }
      if ( m_doMass )
        {
          m_idxMass = m_objCutFlow.size();
          m_objCutFlow.push_back(0);
          m_eventCutFlow.push_back( std::make_pair( Form( "%g < mass < %g", m_massMin.value(), m_massMax.value()), std::make_pair(0,0) ) );
        }
    }


  //--------------------------------------------------------------------------
  // Call the initializeMore function which
  // can be overloaded in the derived classes.
  // The default is that nothing is done!
  //--------------------------------------------------------------------------
  ATH_CHECK( initializeMore() );


  // Setup the remainder of the internal cutflow stuff
  if ( m_printInternalCutflow )
    {
      if ( m_doSelectionTools )
        {
          m_idxSelectionTools = m_objCutFlow.size();
          for ( unsigned int i=0; i<m_selectionTools.size(); ++i )
            {
              m_objCutFlow.push_back(0);
              m_eventCutFlow.push_back( std::make_pair( m_selectionTools[i].name(), std::make_pair(0,0) ) );
            }
        }
      if ( m_doSelectorTools )
        {
          m_idxSelectorTools = m_objCutFlow.size();
          for ( unsigned int i=0; i<m_selectorTools.size(); ++i )
            {
              const std::string toolName = m_selectorTools[i].name();
              const Root::TAccept& tAccept = m_selectorTools[i]->getTAccept();
              for ( unsigned int cutIdx=0; cutIdx<tAccept.getNCuts(); ++cutIdx )
                {
                  std::string cutDescr = (tAccept.getCutDescription(cutIdx)).Data();
                  m_objCutFlow.push_back(0);
                  m_eventCutFlow.push_back( std::make_pair( toolName+":"+cutDescr, std::make_pair(0,0) ) );
                }
            }
        }
      if ( m_doAssociationTools )
        {
          m_idxAssociationTools = m_objCutFlow.size();
          for ( unsigned int i=0; i<m_associationTools.size(); ++i )
            {
              m_objCutFlow.push_back(0);
              m_eventCutFlow.push_back( std::make_pair( m_associationTools[i].name(), std::make_pair(0,0) ) );
            }
        }
      if ( m_doUserDataTools )
        {
          m_idxUserDataTools = m_objCutFlow.size();
          for ( unsigned int i=0; i<m_userDataNameList.size(); ++i )
            {
              m_objCutFlow.push_back(0);
              m_eventCutFlow.push_back( std::make_pair( m_userDataNameList[i], std::make_pair(0,0) ) );
            }
        }
      m_idxFinal = m_objCutFlow.size();
      m_objCutFlow.push_back(0);
      m_eventCutFlow.push_back( std::make_pair( "Final count", std::make_pair(0,0) ) );
    }


  return StatusCode::SUCCESS;
}



//=============================================================================
// Athena execute method
//=============================================================================
template < class T, class CT >
StatusCode D2PDSelectorBase< T, CT >::execute()
{
  // -----------------------------------------
  // Increase the event counter
  // -----------------------------------------
  ++m_nEventsProcessed ;


  // -----------------------------------------
  // Simple status message at the beginning of each event execute,
  // -----------------------------------------
  ATH_MSG_DEBUG ( "==> execute " << name() << " on " << m_nEventsProcessed << ". event..." );


  // -----------------------------------------
  // Setup the internal object cutflow to zero
  // -----------------------------------------
  if ( m_printInternalCutflow )
    {
      for ( unsigned int i=0; i<m_objCutFlow.size(); ++i )
        {
          m_objCutFlow[i] = 0;
        }
    }


  // -----------------------------------------
  // Retrieve the input container
  // -----------------------------------------
  unsigned long tmpInContSize(0);
  const INavigable4MomentumCollection* inContainer(NULL);
  const INav4MomLinkContainer* inLinkContainer(NULL);
  //if ( evtStore()->contains< INav4MomLinkContainer >( m_inCollKey ) ) // For some strange reason, this DOESN'T WORK!!
  const CLID inav4momLinkClid = ClassID_traits< INav4MomLinkContainer >::ID();
  const CLID inav4momClid = ClassID_traits< INavigable4MomentumCollection >::ID();
  if ( evtStore()->contains( inav4momLinkClid,  m_inCollKey ) )
    {
      m_inputIsLinkColl = true;
      ATH_CHECK( evtStore()->retrieve( inLinkContainer, m_inCollKey ) );
      if ( !inLinkContainer ) return StatusCode::SUCCESS;
      ATH_MSG_DEBUG ( "Input link collection = '" << m_inCollKey << "' retrieved from StoreGate" );
      tmpInContSize = inLinkContainer->size();
    }
  else if ( evtStore()->contains( inav4momClid,  m_inCollKey ) )
    {
      m_inputIsLinkColl = false;
      ATH_CHECK( evtStore()->retrieve( inContainer, m_inCollKey ) );
      if ( !inContainer ) return StatusCode::SUCCESS;
      ATH_MSG_DEBUG ( "Input collection = '" << m_inCollKey << "' retrieved from StoreGate" );
      tmpInContSize = inContainer->size();
    }
  else
    {
      if ( m_nEventsProcessed <= 10 )
        {
          ATH_MSG_WARNING ( "Input (link)collection = '" << m_inCollKey
                            << "' could not be retrieved from StoreGate! "
                            << " This message will only be repeated 10 times..." );
        }
      else
        {
          ATH_MSG_DEBUG ( "Input (link)collection = '" << m_inCollKey << "' could not be retrieved from StoreGate! " );
        }
      return StatusCode::SUCCESS;
    }
  const unsigned long inContSize(tmpInContSize);


  //-----------------------------------------
  // Create the output container for selected 
  // objects and record it in StoreGate
  //-----------------------------------------
  CT* outContainer(NULL);
  if ( !(m_outCollKey.empty()) )
    {
      outContainer = new CT( SG::VIEW_ELEMENTS );
      if ( outContainer == NULL )
        {
          ATH_MSG_ERROR ( "Output collection = '" << m_outCollKey << "' could not be created! " );
          return StatusCode::FAILURE;
        }
      // Reserve memory for half (rounded up) of the input size.
      // This way, the vector gets doubled at most once while
      // the memory stays smaller when no doubling is needed.
      outContainer->reserve( (int)ceil( inContSize/2.0 ) );
      ATH_CHECK( evtStore()->record ( outContainer, m_outCollKey ) );
    } // End: if ( m_outCollKey != "" )



  //-----------------------------------------
  // Create the output container for the ElementLinks
  // to the selected objects and record it in StoreGate
  //-----------------------------------------
  INav4MomLinkContainer* outLinkContainer(NULL);
  if ( !(m_outLinkCollKey.empty()) )
    {
      outLinkContainer = new INav4MomLinkContainer();
      // Reserve memory for half (rounded up) of the input size.
      // This way, the vector gets doubled at most once while
      // the memory stays smaller when no doubling is needed.
      //outLinkContainer->reserve( (int)ceil( inContSize/2.0 ) );
      ATH_CHECK( evtStore()->record ( outLinkContainer, m_outLinkCollKey ) );
    } // End: if ( m_outLinkCollKey != "" )




  //-----------------------------------------
  // Create the output INav4MomAssocs map container
  //-----------------------------------------
  // Empty the vector from the previous event
  m_vecINav4MomAssocs.clear();

  // Create the same amount of INav4MomAssocs maps as we have AssociationTools
  for ( unsigned int toolIdx=0; toolIdx < m_associationTools.size(); ++toolIdx )
    {
      INav4MomAssocs* inav4MomAssocs = new INav4MomAssocs;
      if ( !((m_outAssoCollKeys[toolIdx]).empty()) )
        {
          ATH_CHECK( evtStore()->record ( inav4MomAssocs, m_outAssoCollKeys[toolIdx] ) );
        } // End: if ( m_outAssoCollKey != "" )
      m_vecINav4MomAssocs.push_back( inav4MomAssocs );
    } // End: Add all needed INav4MomAssocs to a vector




  //--------------------------------------------------------------------------
  // Before the object loop starts, load the executeMore function which
  // can be overloaded in the derived classes.
  // The default is that nothing is done!
  //--------------------------------------------------------------------------
  ATH_CHECK( executeMore() );




  //-----------------------------------------
  // Do the selection
  //-----------------------------------------

  // Verbose message
  ATH_MSG_VERBOSE ( "Number of objects in the input container " << inContSize );

  // Create a counter for the number of selected objects
  unsigned int nSelected(0);

  // Get the  input container and loop over it
  for ( unsigned long i=0; i < inContSize; ++i )
    {
      // Increase the object counter
      ++m_nObjectsProcessed ;

      // Verbose message
      ATH_MSG_VERBOSE ( "Now on object number " << i );

      // Get the object for this iterator and cast it to the templated type
      const INavigable4Momentum* inav(NULL);
      INav4MomLink objectLink;
      const INavigable4MomentumCollection* objectContainer(NULL);
      unsigned int objectIndex;
      if ( m_inputIsLinkColl )
        {
          ATH_MSG_VERBOSE ( "Object number " << i << " is a link." );

          objectLink = (*inLinkContainer)[i];
          inav = (*objectLink);
          // Make sure we have a valid link
          if ( objectLink.isValid() )
            {
              // Get the pointer to the container that containst the positive matches
              objectContainer = objectLink.getStorableObjectPointer();
              // Get the index of the matched object in the container that containst the positive matches
              objectIndex = objectLink.index();
            }
          else
            {
              ATH_MSG_ERROR ( "Found a non-valid ElementLink in algorithm " << this->name() );
              return StatusCode::FAILURE;
            }
        }
      else
        {
          ATH_MSG_VERBOSE ( "Object number " << i << " is not a link." );
          if ( inContainer == NULL )
            {
              ATH_MSG_WARNING ( "inContainer does not exist." );
            }
          inav            = (*inContainer)[i];
          objectLink      = INav4MomLink( *inContainer, i ) ;
          objectContainer = inContainer;
          objectIndex     = i;
        }
      if ( inav == NULL )
        {
          ATH_MSG_WARNING ( "inav does not exist." );
        }
      const T* object(NULL);
      object = dynamic_cast< const T* >( inav );
      

      ATH_MSG_VERBOSE ("Now going to test the existence of object." );
      

      // Make sure we have a valid pointer
      if ( object != NULL )
        {
          ATH_MSG_VERBOSE ( "Object exists." );

          //--------------------------
          // Calculate the Associations (matching)
          //--------------------------
          // Do the calculation only if the input container is NOT a link container.
          // That way, it is guaranteed that the same association containers will be calculated
          // for every element in the input container.
          // If the user is really sure about what (s)he is doing, then (s)he can 
          // also force the calculation of the associations on an input link container.
          // In that case, the association containers will ONLY exist for those few elements of
          // the original container where the link container was pointing to!
          if ( !m_inputIsLinkColl || m_forceExecuteAssociation )
            {
              for ( unsigned int toolIdx(0); toolIdx < m_associationTools.size(); ++toolIdx )
                {
                  ATH_CHECK( m_associationTools[toolIdx]->calculateAssociations( objectContainer,
                                                                             objectIndex,
                                                                             *(m_vecINav4MomAssocs[toolIdx]) ) );
                }
            } // End: if ( !m_inputIsLinkColl || m_forceExecuteAssociation )


          
          //--------------------------
          // Calculate the UserData
          //--------------------------
          // Do the calculation only if the input container is NOT a link container.
          // That way, it is guaranteed that the same UserData will be calculated
          // for every element in the input container.
          // If the user is really sure about what (s)he is doing, then (s)he can 
          // also force the calculation of the UserData on an input link container.
          // In that case, the UserData will ONLY exist for those few elements of
          // the original container where the link container was pointing to!
          if ( !m_inputIsLinkColl || m_forceExecuteUserData )
            {
              ToolHandleArray<IUserDataCalcTool>::const_iterator toolItr    = m_userDataCalcTools.begin();
              ToolHandleArray<IUserDataCalcTool>::const_iterator toolItrEnd = m_userDataCalcTools.end();
              for ( ; toolItr != toolItrEnd; ++toolItr )
                {
                  ATH_CHECK( (*toolItr)->calculateElementUserData( inav ) );
                }
            } // End: if ( !m_inputIsLinkColl || m_forceExecuteUserData )




          //--------------------------
          // Do the actual selections
          //--------------------------
          bool passAll = true;
          
          ATH_MSG_VERBOSE ( "Now going to perform the selections." );
          
          // transverse momentum selection
          if ( m_doPt && passAll )
            {
              passAll = m_kinSelectorTool->getTool()->passPt( inav );
              ATH_MSG_VERBOSE ( "Object passes the transverse momentum cut " << passAll );
              if ( passAll && m_printInternalCutflow ) { m_objCutFlow[m_idxPt] += 1; }
            }
          // momentum selection
          if ( m_doP && passAll )
            {
              passAll = m_kinSelectorTool->getTool()->passP( inav );
              ATH_MSG_VERBOSE ( "Object passes the momentum cut " << passAll );
              if ( passAll && m_printInternalCutflow ) { m_objCutFlow[m_idxP] += 1; }
            }
          // transverse energy selection
          if ( m_doEt && passAll )
            {
              passAll = m_kinSelectorTool->getTool()->passEt( inav );
              ATH_MSG_VERBOSE ( "Object passes the transverse energy cut " << passAll );
              if ( passAll && m_printInternalCutflow ) { m_objCutFlow[m_idxEt] += 1; }
            }
          // energy selection
          if ( m_doE && passAll )
            {
              passAll = m_kinSelectorTool->getTool()->passE( inav );
              ATH_MSG_VERBOSE ( "Object passes the energy cut " << passAll );
              if ( passAll && m_printInternalCutflow ) { m_objCutFlow[m_idxE] += 1; }
            }
          // eta selection
          if ( m_doEta && passAll )
            {
              passAll = m_kinSelectorTool->getTool()->passEta( inav );
              ATH_MSG_VERBOSE ( "Object passes the eta cut " << passAll );
              if ( passAll && m_printInternalCutflow ) { m_objCutFlow[m_idxEta] += 1; }
            }
          // |eta| selection
          if ( m_doAbsEta && passAll )
            {
              passAll = m_kinSelectorTool->getTool()->passAbsEta( inav );
              ATH_MSG_VERBOSE ( "Object passes the |eta| cut " << passAll );
              if ( passAll && m_printInternalCutflow ) { m_objCutFlow[m_idxAbsEta] += 1; }
            }
          // eta veto selection
          if ( m_doEtaVeto && passAll )
            {
              passAll = m_kinSelectorTool->getTool()->passEtaVetoRanges( inav );
              ATH_MSG_VERBOSE ( "Object passes the eta veto cut " << passAll );
              if ( passAll && m_printInternalCutflow ) { m_objCutFlow[m_idxEtaVeto] += 1; }
            }
          // phi selection
          if ( m_doPhi && passAll )
            {
              passAll = m_kinSelectorTool->getTool()->passPhi( inav );
              ATH_MSG_VERBOSE ( "Object passes the phi cut " << passAll );
              if ( passAll && m_printInternalCutflow ) { m_objCutFlow[m_idxPhi] += 1; }
            }
          // phi veto selection
          if ( m_doPhiVeto && passAll )
            {
              passAll = m_kinSelectorTool->getTool()->passPhiVetoRanges( inav );
              ATH_MSG_VERBOSE ( "Object passes the phi veto cut " << passAll );
              if ( passAll && m_printInternalCutflow ) { m_objCutFlow[m_idxPhiVeto] += 1; }
            }
          // mass selection
          if ( m_doMass && passAll )
            {
              passAll = m_kinSelectorTool->getTool()->passMass( inav );
              ATH_MSG_VERBOSE ( "Object passes the mass cut " << passAll );
              if ( passAll && m_printInternalCutflow ) { m_objCutFlow[m_idxMass] += 1; }
            }

          

          //----------------------------------------------------------
          // Now, execute some more stuff that the derived class may
          // overload.
          //----------------------------------------------------------
          if ( passAll )
            {
              ATH_MSG_VERBOSE ( "Object is going into processObject method" );
              ATH_CHECK( processObject( object, passAll ) );
            } // End: if passAll, executeMore



          //----------------------------------------------------------
          // Now, execute the selections based on provided ISelector tools
          //----------------------------------------------------------
          if ( m_doSelectionTools && passAll )
            {
              ATH_MSG_VERBOSE ( "Object going into running the selection tools" );
              // Loop over all ISelector tools that the user provided
              // and check if this inav is accepted by the ISelector tools
              ToolHandleArray<ISelector>::const_iterator toolItr    = m_selectionTools.begin();
              ToolHandleArray<ISelector>::const_iterator toolItrEnd = m_selectionTools.end();
              unsigned int idxISelTool(0);
              for ( ; toolItr != toolItrEnd; ++toolItr )
                {
                  if ( passAll )
                    {
                      passAll = passAll && (*toolItr)->getTool()->accept( const_cast< INavigable4Momentum* > (inav) );
                      ATH_MSG_VERBOSE ( "Object passes the " << idxISelTool << "th ISelectorTool cut " << passAll );
                      if ( passAll && m_printInternalCutflow ) { m_objCutFlow[m_idxSelectionTools+idxISelTool] += 1; }
                    }
                  ++idxISelTool;
                } // End: loop over ISelector tools
            } // End: if passAll




          //----------------------------------------------------------
          // Now, execute the selections based on provided PATCore tools
          //----------------------------------------------------------
          if ( m_doSelectorTools && passAll )
            {
              ATH_MSG_VERBOSE ( "Object going into running the selector tools" );
              // Loop over all PATCore tools that the user provided
              // and check if this inav is accepted by the ISelector tools
              ToolHandleArray<IAthSelectorTool>::const_iterator toolItr    = m_selectorTools.begin();
              ToolHandleArray<IAthSelectorTool>::const_iterator toolItrEnd = m_selectorTools.end();
              unsigned int idxToolPlusCut(0);
              for ( ; toolItr != toolItrEnd; ++toolItr )
                {
                  if ( passAll )
                    {
                      if ( !m_printInternalCutflow )
                        {
                          if ( passAll )
                            {
                              passAll = passAll && (*toolItr)->accept( inav );
                            }
                        }
                      else
                        {
                          const Root::TAccept& tAccept = (*toolItr)->accept( inav );
                          unsigned int nCuts = tAccept.getNCuts();
                          ATH_MSG_VERBOSE ( "Found " << nCuts << " cuts for tool with name: " << (*toolItr)->name() );
                          for ( unsigned int cutIdx=0; cutIdx<nCuts; ++cutIdx )
                            {
                              passAll = passAll && tAccept.getCutResult(cutIdx);
                              if ( passAll ) { m_objCutFlow[m_idxSelectorTools+idxToolPlusCut] += 1; }
                              ++idxToolPlusCut;
                            }
                        }
                      ATH_MSG_VERBOSE ( "Object passes the " << (*toolItr)->name() << " tool cut: " << passAll );
                    }
                } // End: loop over PATCore tools
            } // End: if passAll




          //----------------------------------------------------------
          // Now, execute the selections based on how many associations (matches) were made
          //----------------------------------------------------------
          if ( m_doAssociationTools && passAll )
            {
              ATH_MSG_VERBOSE ( "Object going into running the association tools" );
              // Loop over all association tools that the user provided
              // and check if this inav has enough associations
              if ( !m_inputIsLinkColl || m_forceExecuteAssociation )
                {
                  for ( unsigned int toolIdx(0); toolIdx < m_associationTools.size(); ++toolIdx )
                    {
                      if ( passAll )
                        {
                          int nAssos = (int)(m_vecINav4MomAssocs[toolIdx]->getNumberOfAssociations( const_cast< INavigable4Momentum* > (inav) ));
                          passAll = passAll && m_assoMinCutList[toolIdx] <= nAssos;
                          passAll = passAll && nAssos <= m_assoMaxCutList[toolIdx];
                          ATH_MSG_VERBOSE ( "Object passes the " << toolIdx << "th AssociationTool cut " << passAll );
                          if ( passAll && m_printInternalCutflow ) { m_objCutFlow[m_idxAssociationTools+toolIdx] += 1; }
                        } // End: if passAll
                    } // End: loop over association tools
                } // End: if ( !m_inputIsLinkColl || m_forceExecuteAssociation )
            } // End: if passAll




          //----------------------------------------------------------
          // Now, execute the selections based on provided UserData variables
          //----------------------------------------------------------
          if ( m_doUserDataTools && passAll )
            {
              ATH_MSG_VERBOSE ( "Object going into running the user data tools" );
              for ( unsigned int i=0; i < m_userDataNameList.size(); ++i )
                {
                  if ( passAll )
                    {
                      ATH_CHECK( m_userDataHelperTool->passElementUserDataCut( inav,
                                                                               m_userDataNameList[i],
                                                                               m_userDataMinCutList[i],
                                                                               m_userDataMaxCutList[i],
                                                                               passAll ) );
                      ATH_MSG_VERBOSE ( "Object passes the " << i << "th UserData cut " << passAll );
                      if ( passAll && m_printInternalCutflow ) { m_objCutFlow[m_idxUserDataTools+i] += 1; }
                    }
                } // End: Loop over provided UserData names and place the selection cuts
            } // End: if passAll



          //----------------------------------------------------------
          // Write out the object (links) if all cuts are passed
          //----------------------------------------------------------
          if ( passAll )
            {
              ATH_MSG_VERBOSE ( "Object is going to be written out, if requested" );
              // Update the counter of number of selected objects
              nSelected++;
              if ( m_printInternalCutflow ) { m_objCutFlow[m_idxFinal] += 1; }
              // Increase the object counter
              ++m_nObjectsPassed;


              // Actually create an ElementLink to the selected electron
              // and add this ElementLink to the output link container
              if ( !(m_outLinkCollKey.empty()) )
                {
                  outLinkContainer->push_back( objectLink );
                  ATH_MSG_VERBOSE ( "Object Link added to output link container." );
                }

              // Add the objects that pass all selections 
              // to the output container
              if ( !(m_outCollKey.empty()) )
                {
                  outContainer->push_back( const_cast<T*>(object) );
                  ATH_MSG_VERBOSE ( "Object added to output container." );
                }
              
            } // End: if passAll
          
        } // End: if object is a valid pointer
      
    } // End: Get the input container and loop over it

  
  // Some debug statements for the log file
  if ( !(m_outCollKey.empty()) && !(m_outLinkCollKey.empty()) )
    {
      ATH_MSG_DEBUG ( "In event number " << m_nEventsProcessed
                      << "  Input collection size = " << inContSize
                      << "  Output collection size = " << outContainer->size()
                      << "  Output link collection size = " << outLinkContainer->size() );
    }
  else
    {
      ATH_MSG_DEBUG ( "In event number " << m_nEventsProcessed
                      << "  Input collection size = " << inContSize
                      << "  Number of seleced objects = " << nSelected );
    }


  //-----------------------------------------
  // Set the output container of selected objects as const
  //-----------------------------------------
  if ( !(m_outCollKey.empty()) )
    {
      ATH_CHECK( evtStore()->setConst( outContainer ) );
    } // End: if ( m_outCollKey != "" )


  //-----------------------------------------
  // Set the output link container of selected electrons as const
  //-----------------------------------------
  if ( !(m_outLinkCollKey.empty()) )
    {
      ATH_CHECK( evtStore()->setConst( outLinkContainer ) );
    } // End: if ( m_outLinkCollKey != "" )



  //-----------------------------------------
  // Set the output association containers as const
  //-----------------------------------------
  for ( unsigned int toolIdx=0; toolIdx < m_associationTools.size(); ++toolIdx )
    {
      if ( !((m_outAssoCollKeys[toolIdx]).empty()) )
        {
          ATH_CHECK( evtStore()->setConst( (m_vecINav4MomAssocs[toolIdx]) ) );
        } // End: Loop over all association maps and set them as const in StoreGate
    } // End: if ( m_outAssoCollKey != "" )



  // -----------------------------------------
  // Transfer the object cutflow numbers to the event cutflow numbers
  // -----------------------------------------
  if ( m_printInternalCutflow )
    {
      if ( m_objCutFlow.size() != m_eventCutFlow.size() )
        {
          ATH_MSG_ERROR ( "Something with the internal cutflow went wrong!"
                          " objCutFlow size = " << m_objCutFlow.size() <<
                          "  and eventCutFlow size = " << m_eventCutFlow.size() );
        }
      for ( unsigned int i=0; i<m_objCutFlow.size(); ++i )
        {
          if ( m_objCutFlow[i] >= m_minNumberPassed 
               && m_objCutFlow[i] <= m_maxNumberPassed )
            {
              m_eventCutFlow[i].second.first  += m_objCutFlow[i];
              m_eventCutFlow[i].second.second += 1;
            }
        }
    }



  //-----------------------------------------
  // Determine if this event is accepted
  //-----------------------------------------
  if ( nSelected >= m_minNumberPassed 
       && nSelected <= m_maxNumberPassed )
    {
      ATH_MSG_DEBUG ( " Event " << m_nEventsProcessed
                      << " passed, found " << nSelected
                      << " objects. Required were minNumber=" << m_minNumberPassed
                      << " and maxNumber=" << m_maxNumberPassed );
      setFilterPassed(true);
    }
  else
    {
      ATH_MSG_DEBUG ( " Event " << m_nEventsProcessed
                      << " failed, found " << nSelected
                      << " objects. Required were minNumber=" << m_minNumberPassed
                      << " and maxNumber=" << m_maxNumberPassed );
      setFilterPassed(false);
    }
  


  // Writing out all containers in StoreGate to the log file
  if ( m_dumpStoreGate )
    {
      ATH_MSG_INFO ( "StoreGateDump: \n" << evtStore()->dump() );
    } // End: if ( m_dumpStoreGate )

  
  return StatusCode::SUCCESS ;
}





//=============================================================================
// Athena finalize method
//=============================================================================
template < class T, class CT >
StatusCode D2PDSelectorBase< T, CT >::finalize()
{
  //-----------------------------------------
  // Default info message printed to the log file.
  // To let you know that you are in this method.
  //-----------------------------------------
  if ( m_printSummary || msgLvl(MSG::DEBUG) )
    {
      ATH_MSG_INFO ( "FINALIZING AFTER ALL EVENTS ARE PROCESSED" );

      // Print the object counter info
      ATH_MSG_INFO ( "Processed " << m_nObjectsProcessed
                     << ", accepted " << m_nObjectsPassed
                     << " objects." );
    }


  // -----------------------------------------
  // Print the internal event cutflow numbers
  // -----------------------------------------
  if ( m_printInternalCutflow && m_nEventsProcessed && m_nObjectsProcessed )
    {
      std::string filler("");
      if ( m_nDigits > 90 )
        {
          filler += Form( "%-*.*s", m_nDigits-90, m_nDigits-90, "=================================================================================================" );
        }
      ATH_MSG_INFO ( "================================================================== begin ==================================================================="
                     << filler );
      ATH_MSG_INFO ( Form( "%-*.*s ::         objects       ::         events       ", m_nDigits, m_nDigits, " " ) );
      ATH_MSG_INFO ( Form( "%-*.*s :: N accepted : ratio[%%] :: N accepted : ratio[%%]", m_nDigits, m_nDigits, "Event filter description" ) );
      ATH_MSG_INFO ( Form( "%-*.*s%s", m_nDigits, m_nDigits,
                           "--------------------------------------------------------------------------------------------------------------------------------------",
                           "--------------------------------------------------" ) );
      ATH_MSG_INFO ( Form( "%-*.*s :: %10lu :  100.000 :: %10lu :  100.000 ", m_nDigits, m_nDigits,
                           "Total number of objects/events processed                                                  ", m_nObjectsProcessed, m_nEventsProcessed ) );

      float invEvents  = 100.0 / float(m_nEventsProcessed) ;
      float invObjects = 100.0 / float(m_nObjectsProcessed) ;
      for ( unsigned int i=0; i<m_eventCutFlow.size(); ++i )
        {
          std::string cutDescription = m_eventCutFlow[i].first;
          unsigned int nObjPassed = m_eventCutFlow[i].second.first;
          unsigned int nEvtPassed = m_eventCutFlow[i].second.second;
          float ratioObj = invObjects*float(nObjPassed);
          float ratioEvt = invEvents*float(nEvtPassed);
          ATH_MSG_INFO ( Form( "%-*.*s :: %10u : %8.5g :: %10u : %8.5g", m_nDigits, m_nDigits, cutDescription.c_str(), nObjPassed, ratioObj, nEvtPassed, ratioEvt ) );
        }
      ATH_MSG_INFO ( "=================================================================== end ===================================================================="
                     << filler );
    }


  //--------------------------------------------------------------------------
  // Call the finalizeMore function which
  // can be overloaded in the derived classes.
  // The default is that nothing is done!
  //--------------------------------------------------------------------------
  ATH_CHECK( finalizeMore() );
  
  // Releasing the used tools and services
  ATH_CHECK( m_userDataSvc.release() );
  ATH_CHECK( m_kinSelectorTool.release() );
  ATH_CHECK( m_userDataHelperTool.release() );
  ATH_CHECK( m_filterTool.release() );
  ATH_CHECK( m_selectionTools.release() );
  ATH_CHECK( m_selectorTools.release() );
  ATH_CHECK( m_associationTools.release() );
  ATH_CHECK( m_userDataCalcTools.release() );

  return StatusCode::SUCCESS;
}






//=============================================================================
// Default method that does nothing.
// Overload this one in your derived class for initializing more.
// This method will be run before the event loop starts!
//=============================================================================
template < class T, class CT >
StatusCode D2PDSelectorBase< T, CT >::initializeMore()
{
  //-----------------------------------------
  // Default debug message printed to the log file.
  // To let you know that you are in this method.
  //-----------------------------------------
  ATH_MSG_DEBUG ( "Initialize more..." );


  //--------------------------------------------------------------------------
  // In the derived class, enter your code below this point!
  //--------------------------------------------------------------------------


  return StatusCode::SUCCESS;
}







//=============================================================================
// Default method that does nothing.
// Overload this one in your derived class for executing more.
// This method will be executed ONCE PER EVENT!
//=============================================================================
template < class T, class CT >
StatusCode D2PDSelectorBase< T, CT >::executeMore()
{
  //-----------------------------------------
  // Default debug message printed to the log file.
  // To let you know that you are in this method.
  //-----------------------------------------
  ATH_MSG_DEBUG ( "Executing more in this event..." );


  //--------------------------------------------------------------------------
  // In the derived class, enter your code below this point!
  //--------------------------------------------------------------------------


  return StatusCode::SUCCESS;
}







//=============================================================================
// Default method that does nothing.
// Overload this one in your derived class for running more in finalize.
// This method will run after the event loop is over
//=============================================================================
template < class T, class CT >
StatusCode D2PDSelectorBase< T, CT >::finalizeMore()
{
  //-----------------------------------------
  // Default debug message printed to the log file.
  // To let you know that you are in this method.
  //-----------------------------------------
  ATH_MSG_DEBUG ( "Finalize more..." );


  //--------------------------------------------------------------------------
  // In the derived class, enter your code below this point!
  //--------------------------------------------------------------------------


  return StatusCode::SUCCESS;
}







//=============================================================================
// Default method that does nothing.
// Overload this one in your derived class for executing more.
// This method will be executed ONCE FOR EVERY OBJECT AT HAND!!
//=============================================================================
template < class T, class CT >
StatusCode D2PDSelectorBase< T, CT >::processObject( const T* object, bool &isPassed )
{
  //-----------------------------------------
  // Default debug message printed to the log file.
  // To let you know that you are in this method.
  //-----------------------------------------
  ATH_MSG_DEBUG ( "Now, processing more for this object..." );

  //-----------------------------------------
  // The default value for the isPassed return
  //-----------------------------------------
  isPassed = true;


  //--------------------------------------------------------------------------
  // In the derived class, enter your code below this point!
  //--------------------------------------------------------------------------

  // Double check that the object exists
  if ( object != NULL )
    {

    }


  return StatusCode::SUCCESS;
}

