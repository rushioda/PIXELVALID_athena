/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

// $Id: RootReaderD3PD_v1.cxx 462802 2011-10-12 16:06:24Z krasznaa $

// STL/system include(s):
#include <iostream>
#include <fstream>
#include <ctime>

// Gaudi/Athena include(s):
#include "GaudiKernel/System.h"
#include "AthenaKernel/errorcheck.h"

// Local include(s):
#include "RootReaderD3PD_v1.h"

/// A little header for all the generated source files
static const char* CODE_COMMENT =
   "// Dear emacs, this is -*- c++ -*-\n"
   "// -------------------------------------------------------------\n"
   "//             Code produced by D3PDMakerReader\n"
   "//\n"
   "//  author: Attila Krasznahorkay <Attila.Krasznahorkay@cern.ch>\n"
   "// -------------------------------------------------------------";

/// Namespace into which all the code should be put
static const char* CODE_NAMESPACE = "D3PDReader";

namespace D3PD {

   RootReaderD3PD_v1::RootReaderD3PD_v1() {

   }

   /**
    * This is the most interesting function of this class. It generates a C++ header
    * and source file from all the information that it gathered so far.
    *
    * @param classname Name of the C++ class to generate
    * @param dir Directory where the generated sources should be put
    * @param prefix Common prefix of the declared variables
    */
   StatusCode RootReaderD3PD_v1::createReader( const std::string& classname,
                                               const std::string& dir ) const {

      //
      // Create the source files:
      //
      CHECK( writeHeader( classname, dir ) );
      CHECK( writeSource( classname, dir ) );

      return StatusCode::SUCCESS;
   }

   StatusCode RootReaderD3PD_v1::writeHeader( const std::string& classname,
                                              const std::string& dir ) const {

      // Let everyone know what we're doing:
      REPORT_MESSAGE_WITH_CONTEXT( MSG::INFO, "RootReaderD3PD_v1" )
         << "Generating file: " << dir << "/" << classname << ".h";

      // Open the header file (overwriting a possibly existing file):
      std::fstream header( ( dir + "/" + classname + ".h" ).c_str(),
                           std::fstream::out | std::fstream::trunc );

      // Write a header for the file:
      header << CODE_COMMENT << std::endl;
      header << "#ifndef D3PDREADER_" << classname << "_H" << std::endl;
      header << "#define D3PDREADER_" << classname << "_H" << std::endl << std::endl;

      // Include some STL headers if they're needed:
      addSTLHeader( header, "vector" );
      addSTLHeader( header, "map" );
      addSTLHeader( header, "string" );
      header << std::endl;

      // ROOT include(s):
      header << "#include <TNamed.h>" << std::endl;
      header << "#include <TString.h>" << std::endl << std::endl;

      // Forward declaration(s):
      header << "class TTree;" << std::endl;
      header << "class TBranch;" << std::endl << std::endl;

      //
      // Declare the class itself:
      //
      header << "namespace " << CODE_NAMESPACE << " {" << std::endl << std::endl;
      header << "   /**" << std::endl;
      header << "    * Code generated by RootD3PDReader_v1 on:" << std::endl;
      header << "    *  host = " << System::hostName() << std::endl;
      header << "    *  OS   = " << System::osName() << " / " << System::osVersion()
             << std::endl;
      header << "    *  user = " << System::accountName() << std::endl;
      time_t rawtime = time( NULL );
      header << "    *  time = " << ctime( &rawtime );
      header << "    */" << std::endl;
      header << "   class " << classname << " : public TNamed {" << std::endl << std::endl;
      header << "   public:" << std::endl;

      //
      // Declare the constructor:
      //
      header << "      /// Constructor specifying the needed parameters" << std::endl;
      header << "      " << classname << "( Long64_t* master, const char* prefix = \""
             << m_metadata.prefix() << "\" );" << std::endl << std::endl; 

      //
      // Declare some functions:
      //
      header << "      /// Get the currently configured prefix value" << std::endl;
      header << "      const char* getPrefix() const;" << std::endl;
      header << "      /// Set the prefix to the ntuple variables" << std::endl;
      header << "      void setPrefix( const char* prefix );" << std::endl << std::endl;
      header << "      /// Connect the object to a new TTree" << std::endl;
      header << "      void connect( TTree* tree );" << std::endl << std::endl;

      //
      // Declare the variable accessor function(s):
      //
      std::set< D3PD::ObjectMetadata::Variable >::const_iterator itr =
         m_metadata.variables().begin();
      std::set< D3PD::ObjectMetadata::Variable >::const_iterator end =
         m_metadata.variables().end();
      for( ; itr != end; ++itr ) {
         if( itr->doc() != "" ) {
            header << "      /// " << itr->doc() << std::endl; 
         }
         header << "      " << itr->type()
                << ( itr->primitive() ? " " : "* " ) << itr->name() << "();"
                << std::endl;
      }

      header << std::endl << "   private:" << std::endl;

      //
      // Declare the member variable(s):
      //
      header << "      // Variables used in the TTree reading:" << std::endl;
      itr = m_metadata.variables().begin();
      end = m_metadata.variables().end();
      for( ; itr != end; ++itr ) {
         header << "      " << itr->type()
                << ( itr->primitive() ? "" : "*" ) << " m_"
                << itr->name() << ";" << std::endl;
      }

      header << std::endl;

      //
      // Declare the branch(es):
      //
      header << "      // TBranch variables used in the TTree reading:" << std::endl;
      itr = m_metadata.variables().begin();
      end = m_metadata.variables().end();
      for( ; itr != end; ++itr ) {
         header << "      ::TBranch* m_b_" << itr->name() << "; //!" << std::endl;
      }

      // Declare the additional member variable(s):
      header << std::endl << "      ::TTree* m_tree;" << std::endl;
      header << "      Long64_t* m_master;" << std::endl;
      header << "      ::TString m_prefix;" << std::endl << std::endl;

      // Close the class definition:
      header << "      ClassDef( " << classname << ", 0 )" << std::endl << std::endl;
      header << "   }; // class " << classname << std::endl << std::endl;
      header << "} // namespace " << CODE_NAMESPACE << std::endl << std::endl;
      header << "#endif // D3PDREADER_" << classname << "_H" << std::endl;

      header.close();

      return StatusCode::SUCCESS;
   }

   StatusCode RootReaderD3PD_v1::writeSource( const std::string& classname,
                                              const std::string& dir ) const {

      // Let everyone know what we're doing:
      REPORT_MESSAGE_WITH_CONTEXT( MSG::INFO, "RootReaderD3PD_v1" )
         << "Generating file: " << dir << "/" << classname << ".cxx";

      // Open the header file (overwriting a possibly existing file):
      std::fstream source( ( dir + "/" + classname + ".cxx" ).c_str(),
                           std::fstream::out | std::fstream::trunc );

      // Add the common header to the file:
      source << CODE_COMMENT << std::endl << std::endl;

      // Add the necessary ROOT include(s):
      source << "#include <TTree.h>" << std::endl;
      source << "#include <TBranch.h>" << std::endl << std::endl;

      // Include the class's header:
      source << "#include \"" << classname << ".h\"" << std::endl << std::endl;

      source << "ClassImp( D3PDReader::" << classname << " )" << std::endl << std::endl;

      source << "namespace " << CODE_NAMESPACE << " {" << std::endl << std::endl;

      //
      // Produce the constructor:
      //
      source << "   /**" << std::endl;
      source << "    * @param master Pointer to the variable holding the current "
             << "event number" << std::endl;
      source << "    * @param prefix Prefix of the variables in the D3PD" << std::endl;
      source << "    */" << std::endl;
      source << "   " << classname << "::" << classname
             << "( Long64_t* master, const char* prefix )" << std::endl;
      source << "      : TNamed( \"" << classname << "\", \"D3PDReader class\" ),"
             << std::endl;
      std::set< D3PD::ObjectMetadata::Variable >::const_iterator itr =
         m_metadata.variables().begin();
      std::set< D3PD::ObjectMetadata::Variable >::const_iterator end =
         m_metadata.variables().end();
      for( ; itr != end; ++itr ) {
         if( itr->primitive() ) continue;
         source << "        m_" << itr->name() << "( 0 )," << std::endl;
      }
      itr = m_metadata.variables().begin();
      end = m_metadata.variables().end();
      for( ; itr != end; ++itr ) {
         source << "        m_b_" << itr->name() << "( 0 )," << std::endl;
      }
      source << "        m_tree( 0 ), m_master( master )," << std::endl;
      source << "        m_prefix( prefix ) {" << std::endl << std::endl;
      source << "   }" << std::endl << std::endl;

      //
      // Produce the prefix handling functions:
      //
      source << "   const char* " << classname << "::getPrefix() const {" << std::endl
             << std::endl;
      source << "      return m_prefix;" << std::endl;
      source << "   }" << std::endl << std::endl;
      source << "   void " << classname << "::setPrefix( const char* prefix ) {"
             << std::endl << std::endl;
      source << "      m_prefix = prefix;" << std::endl;
      source << "      return;" << std::endl;
      source << "   }" << std::endl << std::endl;

      //
      // Produce the connect(...) function:
      //
      source << "   /**" << std::endl;
      source << "    * This function should be called every time a new TFile is opened"
             << std::endl;
      source << "    * by your analysis code." << std::endl;
      source << "    *" << std::endl;
      source << "    * @param tree Pointer to the TTree with the variables" << std::endl;
      source << "    */" << std::endl;
      source << "   void " << classname << "::connect( TTree* tree ) {" << std::endl
             << std::endl;
      itr = m_metadata.variables().begin();
      end = m_metadata.variables().end();
      for( ; itr != end; ++itr ) {
         if( ! itr->primitive() ) {
            source << "      if( m_" << itr->name() << " ) delete m_" << itr->name()
                   << ";" << std::endl;
            source << "      m_" << itr->name() << " = 0;" << std::endl;
         }
         source << "      m_b_" << itr->name() << " = 0;" << std::endl << std::endl;
      }
      source << "      m_tree = tree;" << std::endl << std::endl;
      source << "      return;" << std::endl;
      source << "   }" << std::endl << std::endl;

      //
      // Produce the accessor functions:
      //
      itr = m_metadata.variables().begin();
      end = m_metadata.variables().end();
      for( ; itr != end; ++itr ) {
         source << "   " << itr->type() << ( itr->primitive() ? " " : "* " )
                << classname << "::" << itr->name()
                << "() {" << std::endl << std::endl;
         source << "      if( ! m_b_" << itr->name() << " ) {" << std::endl;
         source << "         if( ! m_tree ) {" << std::endl;
         source << "            Error( \"Connect\", \"Object not connected yet!\" );"
                << std::endl;
         source << "            return 0;" << std::endl;
         source << "         }" << std::endl;
         source << "         if( ! m_tree->GetBranch( m_prefix + \"" << itr->name()
                << "\" ) ) {" << std::endl;
         source << "            Error( \"Connect\", "
                << "\"The following variable doesn't exist: %s\", "
                << "( m_prefix + \"" << itr->name() << "\" ).Data() );" << std::endl;
         source << "            return 0;" << std::endl;
         source << "         }" << std::endl;
         source << "         m_tree->SetBranchAddress( m_prefix + \"" << itr->name()
                << "\", &m_" << itr->name() << ", &m_b_" << itr->name() << " );"
                << std::endl;
         source << "      }" << std::endl;
         source << "      if( *m_master != m_b_" << itr->name() << "->GetReadEntry() ) {"
                << std::endl;
         source << "         m_b_" << itr->name() << "->GetEntry( *m_master );"
                << std::endl;
         source << "      }" << std::endl;
         source << "      return m_" << itr->name() << ";" << std::endl;
         source << "   }" << std::endl << std::endl;
      }

      source << "} // namespace " << CODE_NAMESPACE << std::endl;

      source.close();

      return StatusCode::SUCCESS;
   }

} // namespace D3PD
