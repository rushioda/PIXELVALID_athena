// Dear emacs, this is -*- c++ -*-

/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

// $Id: CodeGenerator_v2_constants.h 600807 2014-06-08 15:26:51Z krasznaa $
#ifndef D3PDMAKERREADER_ROOTREADERD3PD_V2_CONSTANTS_H
#define D3PDMAKERREADER_ROOTREADERD3PD_V2_CONSTANTS_H

static const char* VARHANDLE_HEADER_NAME = "VarHandle.h";
static const char* VARHANDLE_HEADER = 
   "// Dear emacs, this is -*- c++ -*-\n"
   "// $Id: CodeGenerator_v2_constants.h 600807 2014-06-08 15:26:51Z krasznaa $\n"
   "#ifndef D3PDREADER_VARHANDLE_H\n"
   "#define D3PDREADER_VARHANDLE_H\n\n"
   "// ROOT include(s):\n"
   "#include <TString.h>\n"
   "#include <TDataType.h>\n\n"
   "// Local include(s):\n"
   "#include \"D3PDReadStats.h\"\n\n"
   "// Forward declaration(s):\n"
   "class TTree;\n"
   "class TBranch;\n\n"
   "namespace D3PDReader {\n\n"
   "   /**\n"
   "    *  @short Base class for the different kind of VarHandle specializations\n"
   "    *\n"
   "    *         This class is used to keep a list of all the VarHandle members of\n"
   "    *         a D3PDObject class. It makes some operations much easier.\n"
   "    *\n"
   "    * $Revision: 600807 $\n"
   "    * $Date: 2014-06-08 17:26:51 +0200 (Sun, 08 Jun 2014) $\n"
   "    */\n"
   "   class VarHandleBase {\n\n"
   "   protected:\n"
   "      /// Custom enumeration describing the availability of the branch\n"
   "      enum BranchAvailability {\n"
   "         UNKNOWN = 0, ///< The input TTree has not yet been checked\n"
   "         AVAILABLE = 1, ///< The input branch is available\n"
   "         UNAVAILABLE = 2 ///< The input branch is not available\n"
   "      };\n\n"
   "   public:\n"
   "      /// Constructor specifying all the needed parameters\n"
   "      VarHandleBase( const char* name = \"\",\n"
   "                     const ::Long64_t* master = 0 );\n"
   "      /// The destructor is actually only useful in the specialized class...\n"
   "      virtual ~VarHandleBase() {}\n\n"
   "      /// Get the name of the branch handled by this class\n"
   "      const char* GetName() const;\n"
   "      /// Set the name of the branch handled by this class\n"
   "      void SetName( const char* name );\n\n"
   "      /// Get the type name of the branch handled by this object\n"
   "      const char* GetType() const;\n"
   "      /// Set the type name of the branch handled by this object\n"
   "      void SetType( const char* type );\n\n"
   "      /// Get a pointer to the master entry variable\n"
   "      const ::Long64_t* GetMaster() const;\n"
   "      /// Set the pointer to the master entry variable\n"
   "      void SetMaster( const ::Long64_t* master );\n\n"
   "      /// Connect the object to an input tree\n"
   "      virtual void ReadFrom( ::TTree* tree ) = 0;\n"
   "      /// Connect the object to an output tree\n"
   "      virtual ::TBranch* WriteTo( ::TTree* tree ) = 0;\n\n"
   "      /// Check if this variable is \"active\" at the moment\n"
   "      ::Bool_t IsActive() const;\n"
   "      /// Set the \"activity level\" of the variable\n"
   "      void SetActive( ::Bool_t active = kTRUE );\n\n"
   "      /// Check if the variable is available in the input\n"
   "      virtual ::Bool_t IsAvailable() const;\n\n"
   "      /// Read in the current entry from the branch\n"
   "      virtual void ReadCurrentEntry() const = 0;\n\n"
   "      /// \"Clear\" the variable of its contents\n"
   "      virtual void Clear() = 0;\n\n"
   "      /// Get information about the read statistics\n"
   "      virtual VariableStats GetStatistics() const;\n\n"
   "   protected:\n"
   "      /// Connect the variable to the branch\n"
   "      ::Bool_t ConnectVariable( void* var, ::TClass* realClass,\n"
   "                                EDataType dtype, Bool_t isptr ) const;\n"
   "      /// Update the variable to the current entry in the D3PD\n"
   "      void UpdateBranch() const;\n"
   "      /// Switch to a new tree in the statistics gathering\n"
   "      void UpdateStat( ::TBranch* br ) const;\n"
   "      /// Translate the typeid() type name to something ROOT understands\n"
   "      const char* RootType( const char* typeid_type ) const;\n"
   "      /// Translate the typeid() type name to a huma-readable ROOT type name\n"
   "      const char* RootCppType( const char* typeid_type ) const;\n\n"
   "      const ::Long64_t* fMaster; ///< Pointer to the current entry number\n"
   "      ::Bool_t fFromInput; ///< Flag showing if the variable is read from an input TTree\n"
   "      ::TTree* fInTree; ///< The input TTree\n"
   "      mutable ::TBranch* fInBranch; /// The input branch belonging to this variable\n"
   "      mutable BranchAvailability fAvailable; ///< Availability of the branch\n\n"
   "   private:\n"
   "      ::TString fName; ///< Name of the branch to handle\n"
   "      ::Bool_t fActive; ///< Flag telling if the variable can be written to the output\n\n"
   "      ::TString fType; ///< Variable type\n"
   "      mutable std::vector< ::Long64_t > fEntriesRead; ///< Number of read entries for each tree\n"
   "      mutable std::vector< ::Float_t > fBranchSize; ///< Unzipped entry size for each tree\n"
   "      mutable std::vector< ::Float_t > fZippedSize; ///< Zipped entry size for each tree\n\n"
   "   }; // class VarHandleBase\n\n"
   "   /**\n"
   "    *  @short Class responsible for reading primitive types from the D3PD\n"
   "    *\n"
   "    *         This class is used by all the D3PDReader classes to physically\n"
   "    *         handle the branches of the input TTree.\n"
   "    *\n"
   "    * @author Attila Krasznahorkay <Attila.Krasznahorkay@cern.ch>\n"
   "    *\n"
   "    * $Revision: 600807 $\n"
   "    * $Date: 2014-06-08 17:26:51 +0200 (Sun, 08 Jun 2014) $\n"
   "    */\n"
   "   template< typename Type >\n"
   "   class VarHandle : public VarHandleBase {\n\n"
   "   public:\n"
   "      /// Convenience typedef of the used variable\n"
   "      typedef Type& result_type;\n"
   "      /// Convenience typedef of the used variable (const version)\n"
   "      typedef const Type& const_result_type;\n\n"
   "      /// Constructor specifying all the needed parameters\n"
   "      VarHandle( const char* name = \"\",\n"
   "                 const ::Long64_t* master = 0 );\n"
   "      /// The destructor is actually only useful in the specialized class...\n"
   "      ~VarHandle();\n\n"
   "      /// Connect the object to an input tree\n"
   "      virtual void ReadFrom( ::TTree* tree );\n"
   "      /// Connect the object to an output tree\n"
   "      virtual ::TBranch* WriteTo( ::TTree* tree );\n\n"
   "      /// Operator used to access the branch itself\n"
   "      result_type operator()();\n"
   "      /// Operator used to access the branch itself (constant version)\n"
   "      const_result_type operator()() const;\n\n"
   "      /// Read in the current entry from the branch\n"
   "      virtual void ReadCurrentEntry() const;\n\n"
   "      /// \"Clear\" the variable of its contents\n"
   "      virtual void Clear();\n\n"
   "      /// Set the value of the variable. Used primarily from Python.\n"
   "      void Set( Type value );\n\n"
   "   private:\n"
   "      mutable Type fVariable; ///< The variable in memory\n\n"
   "   }; // class VarHandle\n\n"
   "   /**\n"
   "    *  @short Class responsible for reading STL objects from the D3PD\n"
   "    *\n"
   "    *         This specialization of the template class makes it possible to\n"
   "    *         handle branches describing primitive types and branches describing\n"
   "    *         STL collections a little differently.\n"
   "    *\n"
   "    * @author Attila Krasznahorkay <Attila.Krasznahorkay@cern.ch>\n"
   "    *\n"
   "    * $Revision: 600807 $\n"
   "    * $Date: 2014-06-08 17:26:51 +0200 (Sun, 08 Jun 2014) $\n"
   "    */\n"
   "   template< typename Type >\n"
   "   class VarHandle< Type* > : public VarHandleBase {\n\n"
   "   public:\n"
   "      /// Convenience typedef of the used variable\n"
   "      typedef Type* result_type;\n"
   "      /// Convenience typedef of the used variable (const version)\n"
   "      typedef const Type* const_result_type;\n\n"
   "      /// Constructor specifying all the needed parameters\n"
   "      VarHandle( const char* name = \"\",\n"
   "                 const ::Long64_t* master = 0 );\n"
   "      /// This destructor actually does something...\n"
   "      ~VarHandle();\n\n"
   "      /// Connect the object to an input tree\n"
   "      virtual void ReadFrom( ::TTree* tree );\n"
   "      /// Connect the object to an output tree\n"
   "      virtual ::TBranch* WriteTo( ::TTree* tree );\n\n"
   "      /// Operator used to access the branch itself\n"
   "      result_type operator()();\n"
   "      /// Operator used to access the branch itself (constant version)\n"
   "      const_result_type operator()() const;\n\n"
   "      /// Read in the current entry from the branch\n"
   "      virtual void ReadCurrentEntry() const;\n\n"
   "      /// \"Clear\" the variable of its contents\n"
   "      virtual void Clear();\n\n"
   "      /// Set the value of the variable. Used primarily from Python.\n"
   "      void Set( const_result_type value );\n\n"
   "   private:\n"
   "      mutable Type* fVariable; ///< The variable in memory\n\n"
   "   }; // class VarHandle\n\n"
   "} // namespace D3PDReader\n\n"
   "// Include the implementation:\n"
   "#ifndef __CINT__\n"
   "#include \"VarHandle.icc\"\n"
   "#endif // __CINT__\n\n"
   "#endif // D3PDREADER_VARHANDLE_H";

static const char* VARHANDLE_IMPL_NAME = "VarHandle.icc";
static const char* VARHANDLE_IMPL =
   "// Dear emacs, this is -*- c++ -*-\n"
   "// $Id: CodeGenerator_v2_constants.h 600807 2014-06-08 15:26:51Z krasznaa $\n"
   "#ifndef D3PDREADER_VARHANDLE_ICC\n"
   "#define D3PDREADER_VARHANDLE_ICC\n\n"
   "// System include(s):\n"
   "#include <string.h>\n"
   "#include <cxxabi.h>\n"
   "#include <cstdlib>\n\n"
   "// ROOT include(s):\n"
   "#include <TObject.h>\n"
   "#include <TClass.h>\n"
   "#include <TTree.h>\n"
   "#include <TBranch.h>\n"
   "#include <TError.h>\n\n"
   "namespace D3PDReader {\n\n"
   "   template< typename Type >\n"
   "   VarHandle< Type >::VarHandle( const char* name,\n"
   "                                 const ::Long64_t* master )\n"
   "      : VarHandleBase( name, master ),\n"
   "        fVariable() {\n\n"
   "      SetType( RootCppType( typeid( Type ).name() ) );\n"
   "   }\n\n"
   "   template< typename Type >\n"
   "   VarHandle< Type >::~VarHandle() {\n\n"
   "   }\n\n"
   "   template< typename Type >\n"
   "   void VarHandle< Type >::ReadFrom( ::TTree* tree ) {\n\n"
   "      fInTree = tree;\n"
   "      fFromInput = kTRUE;\n"
   "      fVariable = 0;\n"
   "      fInBranch = 0;\n"
   "      fAvailable = UNKNOWN;\n\n"
   "      return;\n"
   "   }\n\n"
   "   template< typename Type >\n"
   "   ::TBranch* VarHandle< Type >::WriteTo( ::TTree* tree ) {\n\n"
   "      if( ! IsActive() ) return 0;\n\n"
   "      ::TBranch* branch = tree->GetBranch( GetName() );\n"
   "      if( branch ) return branch;\n\n"
   "      branch = tree->Branch( GetName(), &fVariable,\n"
   "                             ::TString::Format( \"%s/%s\", GetName(),\n"
   "                                                RootType( typeid( Type ).name() ) ) );\n"
   "      if( ! branch ) {\n"
   "         ::Error( \"D3PDReader::VarHandle::WriteTo\",\n"
   "                  \"Couldn't add variable %s to tree %s\",\n"
   "                  GetName(), tree->GetName() );\n"
   "      } else {\n"
   "         for( ::Long64_t i = 0; i < tree->GetEntries(); ++i ) {\n"
   "            branch->Fill();\n"
   "         }\n"
   "      }\n\n"
   "      return branch;\n"
   "   }\n\n"
   "   template< typename Type >\n"
   "   typename VarHandle< Type >::result_type VarHandle< Type >::operator()() {\n\n"
   "      if( ! fFromInput ) return fVariable;\n\n"
   "      if( ! fInBranch ) {\n"
   "         if( ! ConnectVariable( &fVariable, TClass::GetClass( typeid( Type ) ),\n"
   "                                TDataType::GetType( typeid( Type ) ), kFALSE ) ) {\n"
   "            ::Error( ::TString( \"D3PDReader::VarHandle::\" ) + GetName() + \"()\",\n"
   "                     \"Failed connecting to D3PD\" );\n"
   "            return fVariable;\n"
   "         }\n"
   "      }\n"
   "      UpdateBranch();\n\n"
   "      return fVariable;\n"
   "   }\n\n"
   "   template< typename Type >\n"
   "   typename VarHandle< Type >::const_result_type VarHandle< Type >::operator()() const {\n\n"
   "      if( ! fFromInput ) return fVariable;\n\n"
   "      if( ! fInBranch ) {\n"
   "         if( ! ConnectVariable( &fVariable, TClass::GetClass( typeid( Type ) ),\n"
   "                                TDataType::GetType( typeid( Type ) ), kFALSE ) ) {\n"
   "            ::Error( ::TString( \"D3PDReader::VarHandle::\" ) + GetName() + \"()\",\n"
   "                     \"Failed connecting to D3PD\" );\n"
   "            return fVariable;\n"
   "         }\n"
   "      }\n"
   "      UpdateBranch();\n\n"
   "      return fVariable;\n"
   "   }\n\n"
   "   template< typename Type >\n"
   "   void VarHandle< Type >::ReadCurrentEntry() const {\n\n"
   "      if( IsAvailable() ) {\n"
   "         this->operator()();\n"
   "      } else {\n"
   "         fVariable = 0;\n"
   "      }\n"
   "      return;\n"
   "   }\n\n"
   "   template< typename Type >\n"
   "   void VarHandle< Type >::Clear() {\n\n"
   "      this->operator()() = 0;\n"
   "      return;\n"
   "   }\n\n"
   "   template< typename Type >\n"
   "   void VarHandle< Type >::Set( Type value ) {\n\n"
   "      fVariable = value;\n"
   "      return;\n"
   "   }\n\n"
   "   template< typename Type >\n"
   "   VarHandle< Type* >::VarHandle( const char* name,\n"
   "                                  const ::Long64_t* master )\n"
   "      : VarHandleBase( name, master ),\n"
   "        fVariable( 0 ) {\n\n"
   "      int status;\n"
   "      char* type_name = abi::__cxa_demangle( typeid( Type ).name(), 0, 0, &status );\n"
   "      if( ! status ) {\n"
   "         SetType( type_name );\n"
   "         ::free( type_name );\n"
   "      }\n"
   "   }\n\n"
   "   template< typename Type >\n"
   "   VarHandle< Type* >::~VarHandle() {\n\n"
   "      if( fVariable ) delete fVariable;\n"
   "   }\n\n"
   "   template< typename Type >\n"
   "   void VarHandle< Type* >::ReadFrom( ::TTree* tree ) {\n\n"
   "      fInTree = tree;\n"
   "      fFromInput = kTRUE;\n"
   "      if( fVariable ) fVariable->clear();\n"
   "      fInBranch = 0;\n"
   "      fAvailable = UNKNOWN;\n\n"
   "      return;\n"
   "   }\n\n"
   "   template< typename Type >\n"
   "   ::TBranch* VarHandle< Type* >::WriteTo( ::TTree* tree ) {\n\n"
   "      if( ! IsActive() ) return 0;\n\n"
   "      ::TBranch* branch = tree->GetBranch( GetName() );\n"
   "      if( branch ) return branch;\n\n"
   "      if( ! ::strcmp( GetType(), \"\" ) ) {\n"
   "         ::Error( \"D3PDReader::VarHandle::WriteTo\",\n"
   "                  \"Couldn't demangle type name: %s\",\n"
   "                  typeid( Type ).name() );\n"
   "         return 0;\n"
   "      }\n"
   "      if( ! fVariable ) {\n"
   "         fVariable = new Type();\n"
   "      }\n"
   "      branch = tree->Bronch( GetName(), GetType(), &fVariable );\n"
   "      if( ! branch ) {\n"
   "         ::Error( \"D3PDReader::VarHandle::WriteTo\",\n"
   "                  \"Couldn't add variable %s to tree %s\",\n"
   "                  GetName(), tree->GetName() );\n"
   "      } else {\n"
   "         for( ::Long64_t i = 0; i < tree->GetEntries(); ++i ) {\n"
   "            branch->Fill();\n"
   "         }\n"
   "      }\n\n"
   "      return branch;\n"
   "   }\n\n"
   "   template< typename Type >\n"
   "   typename VarHandle< Type* >::result_type\n"
   "   VarHandle< Type* >::operator()() {\n\n"
   "      if( ! fFromInput ) {\n"
   "         if( ! fVariable ) fVariable = new Type();\n"
   "         return fVariable;\n"
   "      }\n\n"
   "      if( ! fInBranch ) {\n"
   "         if( ! ConnectVariable( &fVariable, TClass::GetClass( typeid( Type ) ),\n"
   "                                TDataType::GetType( typeid( Type ) ), kTRUE ) ) {\n"
   "            ::Error( ::TString( \"D3PDReader::VarHandle::\" ) + GetName() + \"()\",\n"
   "                     \"Failed connecting to D3PD\" );\n"
   "            return fVariable;\n"
   "         }\n"
   "      }\n"
   "      UpdateBranch();\n\n"
   "      return fVariable;\n"
   "   }\n\n"
   "   template< typename Type >\n"
   "   typename VarHandle< Type* >::const_result_type\n"
   "   VarHandle< Type* >::operator()() const {\n\n"
   "      if( ! fFromInput ) {\n"
   "         if( ! fVariable ) fVariable = new Type();\n"
   "         return fVariable;\n"
   "      }\n\n"
   "      if( ! fInBranch ) {\n"
   "         if( ! ConnectVariable( &fVariable, TClass::GetClass( typeid( Type ) ),\n"
   "                                TDataType::GetType( typeid( Type ) ), kTRUE ) ) {\n"
   "            ::Error( ::TString( \"D3PDReader::VarHandle::\" ) + GetName() + \"()\",\n"
   "                     \"Failed connecting to D3PD\" );\n"
   "            return fVariable;\n"
   "         }\n"
   "      }\n"
   "      UpdateBranch();\n\n"
   "      return fVariable;\n"
   "   }\n\n"
   "   template< typename Type >\n"
   "   void VarHandle< Type* >::ReadCurrentEntry() const {\n\n"
   "      if( IsAvailable() ) {\n"
   "         this->operator()();\n"
   "      } else {\n"
   "         if( ! fVariable ) fVariable = new Type();\n"
   "         fVariable->clear();\n"
   "      }\n"
   "      return;\n"
   "   }\n\n"
   "   template< typename Type >\n"
   "   void VarHandle< Type* >::Clear() {\n\n"
   "      this->operator()()->clear();\n"
   "      return;\n"
   "   }\n\n"
   "   template< typename Type >\n"
   "   void VarHandle< Type* >::Set( const_result_type value ) {\n\n"
   "      *fVariable = *value;\n"
   "      return;\n"
   "   }\n\n"
   "} // namespace D3PDReader\n\n"
   "#endif // D3PDREADER_VARHANDLE_ICC";

static const char* VARHANDLE_CXX_NAME = "VarHandle.cxx";
static const char* VARHANDLE_CXX =
   "// $Id: CodeGenerator_v2_constants.h 600807 2014-06-08 15:26:51Z krasznaa $\n\n"
   "// ROOT include(s):\n"
   "#include <TError.h>\n\n"
   "// Local include(s):\n"
   "#include \"VarHandle.h\"\n"
   "#include \"D3PDPerfStats.h\"\n\n"
   "namespace D3PDReader {\n\n"
   "   VarHandleBase::VarHandleBase( const char* name,\n"
   "                                 const ::Long64_t* master )\n"
   "      : fMaster( master ), fFromInput( kFALSE ),\n"
   "        fInTree( 0 ), fInBranch( 0 ), fAvailable( UNKNOWN ), fName( name ),\n"
   "        fActive( kFALSE ), fType( \"\" ),\n"
   "        fEntriesRead(), fBranchSize(), fZippedSize() {\n\n"
   "#ifdef COLLECT_D3PD_READING_STATISTICS\n"
   "      D3PDPerfStats::Instance();\n"
   "#endif // COLLECT_D3PD_READING_STATISTICS\n"
   "   }\n\n"
   "   const char* VarHandleBase::GetName() const {\n\n"
   "      return fName;\n"
   "   }\n\n"
   "   void VarHandleBase::SetName( const char* name ) {\n\n"
   "      fName = name;\n"
   "      return;\n"
   "   }\n\n"
   "   const char* VarHandleBase::GetType() const {\n\n"
   "      return fType;\n"
   "   }\n\n"
   "   void VarHandleBase::SetType( const char* type ) {\n\n"
   "      fType = type;\n"
   "      return;\n"
   "   }\n\n"
   "   const ::Long64_t* VarHandleBase::GetMaster() const {\n\n"
   "      return fMaster;\n"
   "   }\n\n"
   "   void VarHandleBase::SetMaster( const ::Long64_t* master ) {\n\n"
   "      fMaster = master;\n"
   "      return;\n"
   "   }\n\n"
   "   ::Bool_t VarHandleBase::IsActive() const {\n\n"
   "      return fActive;\n"
   "   }\n\n"
   "   void VarHandleBase::SetActive( ::Bool_t active ) {\n\n"
   "      fActive = active;\n"
   "      return;\n"
   "   }\n\n"
   "   ::Bool_t VarHandleBase::IsAvailable() const {\n\n"
   "      if( ! fFromInput ) return kTRUE;\n"
   "      switch( fAvailable ) {\n\n"
   "      case AVAILABLE:\n"
   "         return kTRUE;\n"
   "         break;\n"
   "      case UNAVAILABLE:\n"
   "         return kFALSE;\n"
   "         break;\n"
   "      case UNKNOWN:\n"
   "         {\n"
   "            if( ! fInTree ) return kTRUE;\n"
   "            ::Bool_t temp = kFALSE;\n"
   "            fAvailable = ( temp = fInTree->GetBranch( GetName() ) ) ? AVAILABLE :\n"
   "                         UNAVAILABLE;\n"
   "            return temp;\n"
   "         }\n"
   "         break;\n"
   "      default:\n"
   "         // This should really never be reached...\n"
   "         break;\n"
   "      }\n\n"
   "      // It's just here to make the compiler happy:\n"
   "      return kFALSE;\n"
   "   }\n\n"
   "   VariableStats VarHandleBase::GetStatistics() const {\n\n"
   "      // Calculate the statistics:\n"
   "      ::Long64_t readEntries = 0;\n"
   "      ::Long64_t unzippedBytes = 0;\n"
   "      ::Long64_t zippedBytes = 0;\n"
   "      for( size_t i = 0; i < fEntriesRead.size(); ++i ) { \n"
   "         readEntries += fEntriesRead[ i ];\n"
   "         unzippedBytes += static_cast< ::Long64_t >( fBranchSize[ i ] *\n"
   "                                                     fEntriesRead[ i ] );\n"
   "         zippedBytes += static_cast< ::Long64_t >( fZippedSize[ i ] *\n"
   "                                                   fEntriesRead[ i ] );\n"
   "      }\n\n"
   "      // Now return the \"smart\" object:\n"
   "      return VariableStats( GetName(), GetType(),\n"
   "                            fEntriesRead.size(), readEntries,\n"
   "                            unzippedBytes, zippedBytes );\n"
   "   }\n\n"
   "   ::Bool_t VarHandleBase::ConnectVariable( void* var, ::TClass* realClass,\n"
   "                                            EDataType dtype, Bool_t isptr ) const {\n\n"
   "      if( ! fInTree ) {\n"
   "         ::Error( \"D3PDReader::VarHandleBase::ConnectVariable\",\n"
   "                  \"Object not connected yet!\" );\n"
   "         return kFALSE;\n"
   "      }\n"
   "      if( ! fInTree->GetBranch( GetName() ) ) {\n"
   "         ::Error( \"D3PDReader::VarHandleBase::ConnectVariable\",\n"
   "                  \"The following variable doesn't exist: %s\",\n"
   "                  GetName() );\n"
   "         return kFALSE;\n"
   "      }\n"
   "#ifdef ACTIVATE_BRANCHES\n"
   "      // Only call this function when the user asks for it. It's quite expensive...\n"
   "      fInTree->SetBranchStatus( ::TString( GetName() ) + \"*\", 1 );\n"
   "#endif // ACTIVATE_BRANCHES\n"
   "      if( fInTree->SetBranchAddress( GetName(), var, &fInBranch,\n"
   "                                     realClass, dtype, isptr ) ) {\n"
   "         ::Error( \"D3PDReader::VarHandleBase::ConnectVariable\",\n"
   "                  \"Couldn't connect variable to branch: %s\", GetName() );\n"
   "         return kFALSE;\n"
   "      }\n\n"
   "#ifdef COLLECT_D3PD_READING_STATISTICS\n"
   "      UpdateStat( fInBranch );\n"
   "#endif // COLLECT_D3PD_READING_STATISTICS\n\n"
   "      return kTRUE;\n"
   "   }\n\n"
   "   void VarHandleBase::UpdateBranch() const {\n\n"
   "      if( *fMaster != fInBranch->GetReadEntry() ) {\n"
   "         fInBranch->GetEntry( *fMaster );\n"
   "#ifdef COLLECT_D3PD_READING_STATISTICS\n"
   "         ++( fEntriesRead.back() );\n"
   "#endif // COLLECT_D3PD_READING_STATISTICS\n"
   "      }\n\n"
   "      return;\n"
   "   }\n\n"
   "   void VarHandleBase::UpdateStat( ::TBranch* br ) const {\n\n"
   "      fEntriesRead.push_back( 0 );\n"
   "      fBranchSize.push_back( ( ::Float_t ) br->GetTotalSize( \"*\" ) /\n"
   "                             ( ::Float_t ) br->GetEntries() );\n"
   "      fZippedSize.push_back( ( ::Float_t ) br->GetZipBytes( \"*\" ) /\n"
   "                             ( ::Float_t ) br->GetEntries() );\n\n"
   "      D3PDPerfStats::Instance()->NewTreeAccessed( fInTree );\n\n"
   "      return;\n"
   "   }\n\n"
   "   const char* VarHandleBase::RootType( const char* typeid_type ) const {\n\n"
   "      if( strlen( typeid_type ) != 1 ) {\n"
   "         ::Error( \"D3PDReader::VarHandleBase::RootType\",\n"
   "                  \"Received complex object description\" );\n"
   "         return \"\";\n"
   "      }\n\n"
   "      switch( typeid_type[ 0 ] ) {\n\n"
   "      case 'c':\n"
   "         return \"B\";\n"
   "         break;\n"
   "      case 'h':\n"
   "         return \"b\";\n"
   "         break;\n"
   "      case 's':\n"
   "         return \"S\";\n"
   "         break;\n"
   "      case 't':\n"
   "         return \"s\";\n"
   "         break;\n"
   "      case 'i':\n"
   "         return \"I\";\n"
   "         break;\n"
   "      case 'j':\n"
   "         return \"i\";\n"
   "         break;\n"
   "      case 'f':\n"
   "         return \"F\";\n"
   "         break;\n"
   "      case 'd':\n"
   "         return \"D\";\n"
   "         break;\n"
   "      case 'x':\n"
   "         return \"L\";\n"
   "         break;\n"
   "      case 'y':\n"
   "         return \"l\";\n"
   "         break;\n"
   "      case 'b':\n"
   "         return \"O\";\n"
   "         break;\n\n"
   "      }\n\n"
   "      ::Error( \"D3PDReader::VarHandleBase::RootType\",\n"
   "               \"Unknown primitive type encountered: %s\",\n"
   "               typeid_type );\n"
   "      return \"\";\n"
   "   }\n\n"
   "   const char* VarHandleBase::RootCppType( const char* typeid_type ) const {\n\n"
   "      if( strlen( typeid_type ) != 1 ) {\n"
   "         ::Error( \"D3PDReader::VarHandleBase::RootCppType\",\n"
   "                  \"Received complex object description\" );\n"
   "         return \"\";\n"
   "      }\n\n"
   "      switch( typeid_type[ 0 ] ) {\n\n"
   "      case 'c':\n"
   "         return \"Char_t\";\n"
   "         break;\n"
   "      case 'h':\n"
   "         return \"UChar_t\";\n"
   "         break;\n"
   "      case 's':\n"
   "         return \"Short_t\";\n"
   "         break;\n"
   "      case 't':\n"
   "         return \"UShort_t\";\n"
   "         break;\n"
   "      case 'i':\n"
   "         return \"Int_t\";\n"
   "         break;\n"
   "      case 'j':\n"
   "         return \"UInt_t\";\n"
   "         break;\n"
   "      case 'f':\n"
   "         return \"Float_t\";\n"
   "         break;\n"
   "      case 'd':\n"
   "         return \"Double_t\";\n"
   "         break;\n"
   "      case 'x':\n"
   "         return \"Long64_t\";\n"
   "         break;\n"
   "      case 'y':\n"
   "         return \"ULong64_t\";\n"
   "         break;\n"
   "      case 'b':\n"
   "         return \"Bool_t\";\n"
   "         break;\n\n"
   "      }\n\n"
   "      ::Error( \"D3PDReader::VarHandleBase::RootCppType\",\n"
   "               \"Unknown primitive type encountered: %s\",\n"
   "               typeid_type );\n"
   "      return \"\";\n"
   "   }\n\n"
   "} // namespace D3PDReader";

static const char* VARPROXY_HEADER_NAME = "VarProxy.h";
static const char* VARPROXY_HEADER =
   "// Dear emacs, this is -*- c++ -*-\n"
   "// $Id: CodeGenerator_v2_constants.h 600807 2014-06-08 15:26:51Z krasznaa $\n"
   "#ifndef D3PDREADER_VARPROXY_H\n"
   "#define D3PDREADER_VARPROXY_H\n\n"
   "// STL include(s):\n"
   "#include <vector>\n\n"
   "// Local include(s):\n"
   "#include \"VarHandle.h\"\n\n"
   "namespace D3PDReader {\n\n"
   "   /**\n"
   "    *  @short Base class for the VarProxy versions\n"
   "    *\n"
   "    *         This class is needed for technical reasons in order to handle\n"
   "    *         user defined variables in a nice way.\n"
   "    *\n"
   "    * @author Attila Krasznahorkay <Attila.Krasznahorkay@cern.ch>\n"
   "    *\n"
   "    * $Revision: 600807 $\n"
   "    * $Date: 2014-06-08 17:26:51 +0200 (Sun, 08 Jun 2014) $\n"
   "    */\n"
   "   class VarProxyBase {\n\n"
   "   public:\n"
   "      /// Destructor, to make vtable happy\n"
   "      virtual ~VarProxyBase() {}\n\n"
   "      /// Check if the variable is available in the input\n"
   "      virtual ::Bool_t IsAvailable() const = 0;\n\n"
   "   }; // class VarProxyBase\n\n"
   "   /**\n"
   "    *  @short Class acting as a proxy to one element of an std::vector\n"
   "    *\n"
   "    *         This class is used in the \"Element\" classes to represent one\n"
   "    *         object from a collection.\n"
   "    *\n"
   "    * @author Attila Krasznahorkay <Attila.Krasznahorkay@cern.ch>\n"
   "    *\n"
   "    * $Revision: 600807 $\n"
   "    * $Date: 2014-06-08 17:26:51 +0200 (Sun, 08 Jun 2014) $\n"
   "    */\n"
   "   template< typename Type >\n"
   "   class VarProxy : public VarProxyBase {\n\n"
   "   public:\n"
   "      /// Convenience typedef of the used variable\n"
   "      typedef Type& result_type;\n"
   "      /// Convenience typedef of the used variable (const version)\n"
   "      typedef const Type& const_result_type;\n\n"
   "      /// Constructor specifying the handle object this proxy uses\n"
   "      VarProxy( const VarHandle< std::vector< Type >* >& handle, size_t i );\n"
   "      /// Copy constructor\n"
   "      VarProxy( const VarProxy< Type >& parent );\n"
   "      /// Copy operator\n"
   "      VarProxy< Type >& operator=( const VarProxy< Type >& parent );\n\n"
   "      /// Check if the variable is available in the input\n"
   "      virtual ::Bool_t IsAvailable() const;\n\n"
   "      /// Operator returning the variable belonging to this object\n"
   "      result_type operator()();\n"
   "      /// Operator returning the variable belonging to this object (constant version)\n"
   "      const_result_type operator()() const;\n\n"
   "   private:\n"
   "      VarHandle< std::vector< Type >* >* fHandle; ///< Pointer to the handle object\n"
   "      size_t fIndex; ///< Index inside the handle object's vector\n"
   "      Type fDummy; ///< Object returned by default\n\n"
   "   }; // class VarProxy\n\n"
   "} // namespace D3PDReader\n\n"
   "// Include the implementation:\n"
   "#ifndef __CINT__\n"
   "#include \"VarProxy.icc\"\n"
   "#endif // __CINT__\n\n"
   "#endif // D3PDREADER_VARPROXY_H";

static const char* VARPROXY_IMPL_NAME = "VarProxy.icc";
static const char* VARPROXY_IMPL =
   "// Dear emacs, this is -*- c++ -*-\n"
   "// $Id: CodeGenerator_v2_constants.h 600807 2014-06-08 15:26:51Z krasznaa $\n"
   "#ifndef D3PDREADER_VARPROXY_ICC\n"
   "#define D3PDREADER_VARPROXY_ICC\n\n"
   "// ROOT include(s):\n"
   "#include <TError.h>\n\n"
   "namespace D3PDReader {\n\n"
   "   template< typename Type >\n"
   "   VarProxy< Type >::VarProxy( const VarHandle< std::vector< Type >* >& handle,\n"
   "                               size_t i )\n"
   "      : fHandle( const_cast< VarHandle< std::vector< Type >* >* >( &handle ) ),\n"
   "        fIndex( i ), fDummy() {\n\n"
   "   }\n\n"
   "   template< typename Type >\n"
   "   VarProxy< Type >::VarProxy( const VarProxy< Type >& parent )\n"
   "      : VarProxyBase(), fHandle( parent.fHandle ), fIndex( parent.fIndex ),\n"
   "        fDummy() {\n\n"
   "   }\n\n"
   "   template< typename Type >\n"
   "   VarProxy< Type >& VarProxy< Type >::operator=( const VarProxy< Type >& parent ) {\n\n"
   "      fHandle = parent.fHandle;\n"
   "      fIndex  = parent.fIndex;\n\n"
   "      return *this;\n"
   "   }\n\n"
   "   template< typename Type >\n"
   "   ::Bool_t VarProxy< Type >::IsAvailable() const {\n\n"
   "      return fHandle->IsAvailable();\n"
   "   }\n\n"
   "   template< typename Type >\n"
   "   typename VarProxy< Type >::result_type VarProxy< Type >::operator()() {\n\n"
   "      if( fHandle->IsAvailable() ) {\n"
   "         return ( ( *( *fHandle )() ) )[ fIndex ];\n"
   "      } else {\n"
   "         ::Warning( ::TString( \"D3PDReader::VarProxy::\" ) + fHandle->GetName() + \"()\",\n"
   "                    \"Variable not available on input. Returning 0\" );\n"
   "         return fDummy;\n"
   "      }\n"
   "   }\n\n"
   "   template< typename Type >\n"
   "   typename VarProxy< Type >::const_result_type VarProxy< Type >::operator()() const {\n\n"
   "      if( fHandle->IsAvailable() ) {\n"
   "         return ( ( *( *fHandle )() ) )[ fIndex ];\n"
   "      } else {\n"
   "         ::Warning( ::TString( \"D3PDReader::VarProxy::\" ) + fHandle->GetName() + \"()\",\n"
   "                    \"Variable not available on input. Returning 0\" );\n"
   "         return fDummy;\n"
   "      }\n"
   "   }\n\n"
   "} // namespace D3PDReader\n\n"
   "#endif // D3PDREADER_VARPROXY_ICC";

static const char* D3PDOBJECTBASE_HEADER_NAME = "D3PDObjectBase.h";
static const char* D3PDOBJECTBASE_HEADER =
   "// Dear emacs, this is -*- c++ -*-\n"
   "// $Id: CodeGenerator_v2_constants.h 600807 2014-06-08 15:26:51Z krasznaa $\n"
   "#ifndef D3PDREADER_D3PDOBJECTBASE_H\n"
   "#define D3PDREADER_D3PDOBJECTBASE_H\n\n"
   "// ROOT include(s):\n"
   "#include <TNamed.h>\n"
   "#include <TString.h>\n\n"
   "// Local include(s):\n"
   "#include \"D3PDReadStats.h\"\n\n"
   "// Forward declaration(s):\n"
   "class TTree;\n\n"
   "namespace D3PDReader {\n\n"
   "   /**\n"
   "    *  @short Common base class for all main D3PDReader classes\n"
   "    *\n"
   "    *         To make the classes a bit easier to handle in \"smart\" code\n"
   "    *         they inherit from a common base that defines all of their\n"
   "    *         common features.\n"
   "    *\n"
   "    * @author Attila Krasznahorkay <Attila.Krasznahorkay@cern.ch>\n"
   "    *\n"
   "    * $Revision: 600807 $\n"
   "    * $Date: 2014-06-08 17:26:51 +0200 (Sun, 08 Jun 2014) $\n"
   "    */\n"
   "   class D3PDObjectBase : public ::TNamed {\n\n"
   "   public:\n"
   "      /// Default constructor\n"
   "      D3PDObjectBase() : ::TNamed() {}\n\n"
   "      /// Get the currently configured prefix value\n"
   "      virtual const char* GetPrefix() const = 0;\n"
   "      /// Set the prefix for the variables\n"
   "      virtual void SetPrefix( const char* prefix ) = 0;\n\n"
   "      /// Connect the object to an input TTree\n"
   "      virtual void ReadFrom( ::TTree* tree ) = 0;\n"
   "      /// Connect the object to an output TTree\n"
   "      virtual void WriteTo( ::TTree* tree ) = 0;\n\n"
   "      /// Turn (selected) branches either on or off\n"
   "      virtual void SetActive( ::Bool_t active = kTRUE,\n"
   "                              const ::TString& pattern = \".*\" ) = 0;\n\n"
   "      /// Read in all the variables that we need to write out as well\n"
   "      virtual void ReadAllActive() = 0;\n\n"
   "      /// Get the D3PD reading statistics\n"
   "      virtual D3PDReadStats GetStatistics() const = 0;\n\n"
   "      ClassDef( D3PDObjectBase, 0 )\n\n"
   "   }; // class D3PDObjectBase\n\n"
   "} // namespace D3PDReader\n\n"
   "#endif // D3PDREADER_D3PDOBJECTBASE_H";

static const char* D3PDREADSTATS_HEADER_NAME = "D3PDReadStats.h";
static const char* D3PDREADSTATS_HEADER =
   "// Dear emacs, this is -*- c++ -*-\n"
   "// $Id: CodeGenerator_v2_constants.h 600807 2014-06-08 15:26:51Z krasznaa $\n"
   "#ifndef D3PDREADER_D3PDREADSTATS_H\n"
   "#define D3PDREADER_D3PDREADSTATS_H\n\n"
   "// STL include(s):\n"
   "#include <map>\n"
   "#include <vector>\n\n"
   "// ROOT include(s):\n"
   "#include <TNamed.h>\n"
   "#include <TString.h>\n\n"
   "// Forward declaration(s):\n"
   "class TCollection;\n"
   "class TTree;\n"
   "class TH1;\n\n"
   "namespace D3PDReader {\n\n"
   "   // Forward declaration(s):\n"
   "   class D3PDPerfStats;\n\n"
   "   /**\n"
   "    *  @short Class describing the access statistics of one variable\n"
   "    *\n"
   "    *         Objects of this class are used to describe a single D3PD variable's\n"
   "    *         access pattern.\n"
   "    *\n"
   "    * @author Attila Krasznahorkay <Attila.Krasznahorkay@cern.ch>\n"
   "    *\n"
   "    * $Revision: 600807 $\n"
   "    * $Date: 2014-06-08 17:26:51 +0200 (Sun, 08 Jun 2014) $\n"
   "    */\n"
   "   class VariableStats : public ::TNamed {\n\n"
   "   public:\n"
   "      /// Constructor specifying all parameters\n"
   "      VariableStats( const char* name = \"d3pd_variable\",\n"
   "                     const char* type = \"Int_t\",\n"
   "                     ::Int_t nTreesAccessed = 0, ::Long64_t nReadEntries = 0,\n"
   "                     ::Long64_t nUnzippedBytes = 0, ::Long64_t nZippedBytes = 0 );\n"
   "      /// Copy constructor\n"
   "      VariableStats( const VariableStats& parent );\n\n"
   "      /// Assignment operator\n"
   "      VariableStats& operator= ( const VariableStats& parent );\n\n"
   "      /// Get how many trees were accessed to read this variable\n"
   "      ::Int_t GetTreesAccessed() const;\n"
   "      /// Set how many trees were accessed to read this variable\n"
   "      void SetTreesAccessed( ::Int_t nTreesAccessed );\n\n"
   "      /// Get how many entries were read from this branch\n"
   "      ::Long64_t GetReadEntries() const;\n"
   "      /// Set how many entries were read from this branch\n"
   "      void SetReadEntries( ::Long64_t nReadEntries );\n\n"
   "      /// Get how many unzipped bytes were read from this branch in total\n"
   "      ::Long64_t GetUnzippedBytesRead() const;\n"
   "      /// Set how many unzipped bytes were read from this branch in total\n"
   "      void SetUnzippedBytesRead( ::Long64_t nUnzippedBytes );\n\n"
   "      /// Get how many zipped bytes were read from this branch in total\n"
   "      ::Long64_t GetZippedBytesRead() const;\n"
   "      /// Set how many zipped bytes were read from this branch in total\n"
   "      void SetZippedBytesRead( ::Long64_t nZippedBytes );\n\n"
   "      /// Function merging two objects\n"
   "      VariableStats& Add( const VariableStats& rh );\n"
   "      /// Operator merging two objects\n"
   "      VariableStats& operator+= ( const VariableStats& rh );\n\n"
   "      /// Function merging the information from multiple objects\n"
   "      ::Int_t Merge( ::TCollection* coll );\n\n"
   "      /// Print information about the collected statistics\n"
   "      void Print( ::Option_t* option = \"\" ) const;\n\n"
   "   private:\n"
   "      ::Int_t fTreesAccessed; ///< Number of trees accessed for this variable\n"
   "      ::Long64_t fReadEntries; ///< Number of entries read from this branch\n"
   "      ::Long64_t fUnzippedBytes; ///< Number of unzipped bytes read from this branch\n"
   "      ::Long64_t fZippedBytes; ///< Number of zipped bytes read from this branch\n\n"
   "      ClassDef( VariableStats, 1 )\n\n"
   "   }; // class VariableStats\n\n"
   "   /**\n"
   "    *  @short Class describing the access statistics of a collection of branches\n"
   "    *\n"
   "    *         Objects of this class are used to describe the access pattern of a D3PD\n"
   "    *         analysis. The object can also be used to optimize the caching for the\n"
   "    *         analysis in subsequent runs.\n"
   "    *\n"
   "    * @author Attila Krasznahorkay <Attila.Krasznahorkay@cern.ch>\n"
   "    *\n"
   "    * $Revision: 600807 $\n"
   "    * $Date: 2014-06-08 17:26:51 +0200 (Sun, 08 Jun 2014) $\n"
   "    */\n"
   "   class D3PDReadStats : public ::TNamed {\n\n"
   "   public:\n"
   "      /// Type of the internal object gathering information\n"
   "      /**\n"
   "       * Notice that I can't write <code>::TString</code> here, because\n"
   "       * the generated dictionary would then have code with <code><::</code>\n"
   "       * in it, which is not a valid C++ operator.\n"
   "       */\n"
   "      typedef std::map< ::TString, VariableStats > Map_t;\n\n"
   "      /// Constructor just specifying the name of the object\n"
   "      D3PDReadStats( const char* name = \"D3PDReadStats\",\n"
   "                     const char* title = \"D3PD reading statistics\" );\n"
   "      /// Copy constructor\n"
   "      D3PDReadStats( const D3PDReadStats& parent );\n\n"
   "      /// Assignment operator\n"
   "      D3PDReadStats& operator= ( const D3PDReadStats& parent );\n\n"
   "      /// Clear the statistics information\n"
   "      void Clear( ::Option_t* opt = \"\" );\n\n"
   "      /// Set how many bytes were read in total during the analysis\n"
   "      void SetBytesRead( ::Long64_t num );\n"
   "      /// Get how many bytes were read in total during the analysis\n"
   "      ::Long64_t GetBytesRead() const;\n\n"
   "      /// Set the total number of variables of the input\n"
   "      void SetVariableNum( ::Int_t num );\n"
   "      /// Get the total number of variables of the input\n"
   "      ::Int_t GetVariableNum() const;\n\n"
   "      /// Set the total number of file read calls\n"
   "      void SetFileReads( ::Int_t num );\n"
   "      /// Get the total number of file read calls\n"
   "      ::Int_t GetFileReads() const;\n\n"
   "      /// Set the TTreeCache size used\n"
   "      void SetCacheSize( ::Int_t size );\n"
   "      /// Get the TTreeCache size used\n"
   "      ::Int_t GetCacheSize() const;\n\n"
   "      /// Set the time spent in unzipping the data\n"
   "      void SetUnzipTime( ::Double_t time );\n"
   "      /// Get the time spent in unzipping the data\n"
   "      ::Double_t GetUnzipTime() const;\n\n"
   "      /// Set the time spent in processing events\n"
   "      void SetProcessTime( ::Double_t time );\n"
   "      /// Get the time spent in processing events\n"
   "      ::Double_t GetProcessTime() const;\n\n"
   "      /// Add information about a variable to the object\n"
   "      D3PDReadStats& AddVariable( const VariableStats& var );\n"
   "      /// Get information about a specific variable\n"
   "      const VariableStats* GetVariable( const char* name ) const;\n"
   "      /// Get all variable information\n"
   "      const Map_t& GetVariables() const;\n\n"
   "      /// Function checking if two objects are \"compatible\"\n"
   "      ::Bool_t IsCompatible( const D3PDReadStats& rh ) const;\n"
   "      /// Function merging two objects\n"
   "      D3PDReadStats& Add( const D3PDReadStats& rh );\n"
   "      /// Operator merging two objects\n"
   "      D3PDReadStats& operator+= ( const D3PDReadStats& rh );\n\n"
   "      /// Add all branches that were ever accessed, to the TTreeCache\n"
   "      void AddToTreeCache( ::TTree* tree ) const;\n"
   "      /// Add the branches accessed more than n times to the TTreeCache\n"
   "      void AddToTreeCacheByEntries( ::TTree* tree, ::Long64_t minEntries ) const;\n"
   "      /// Add the branches accessed more than a given fraction of times to the TTreeCache\n"
   "      void AddToTreeCacheByEntryFrac( ::TTree* tree,\n"
   "                                      ::Double_t minEvFraction ) const;\n"
   "      /// Add the branches from which more than x bytes were read, to the TTreeCache\n"
   "      void AddToTreeCacheByBytes( ::TTree* tree, ::Long64_t minBytes ) const;\n"
   "      /// Add the branches from whith more than a given fraction of the bytes were read, to the TTreeCache\n"
   "      void AddToTreeCacheByByteFrac( ::TTree* tree,\n"
   "                                     ::Double_t minByteFraction ) const;\n\n"
   // "::" is not put in front of TString for a reason here. The generated dictionary
   // fails to compile if we have that in.
   "      /// Get the branches accessed more than n times\n"
   "      std::vector< TString > GetBranchesByEntries( ::Long64_t minEntries ) const;\n"
   "      /// Get the branches accessed more than a given fraction of times\n"
   "      std::vector< TString > GetBranchesByEntryFrac( ::Double_t minEvFraction ) const;\n"
   "      /// Get the branches from which more than x bytes were read\n"
   "      std::vector< TString > GetBranchesByBytes( ::Long64_t minBytes ) const;\n"
   "      /// Get the branches from which more than a given fraction of bytes were read\n"
   "      std::vector< TString > GetBranchesByByteFrac( ::Double_t minByteFraction ) const;\n\n"
   "      /// Get a histogram with the TTree access statistics\n"
   "      ::TH1* GetTreeAccessStat() const;\n"
   "      /// Get a histogram with the entry reading statistics\n"
   "      ::TH1* GetEntryReadStat() const;\n"
   "      /// Get a histogram with the zipped byte reading statistics\n"
   "      ::TH1* GetZippedByteReadStat() const;\n"
   "      /// Get a histogram with the unzipped byte reading statistics\n"
   "      ::TH1* GetUnzippedByteReadStat() const;\n\n"
   "      /// Function merging the information from multiple objects\n"
   "      ::Int_t Merge( ::TCollection* coll );\n\n"
   "      /// Print information about the collected statistics\n"
   "      void Print( ::Option_t* option = \"\" ) const;\n\n"
   "   private:\n"
   "      /// Statistics about the variables\n"
   "      Map_t fVariables;\n"
   "      /// Total number of bytes read\n"
   "      ::Long64_t fBytesRead;\n"
   "      /// Total number of variables in the input D3PD TTree\n"
   "      ::Int_t fVariableNum;\n"
   "      /// Total number of file reading operations during the analysis\n"
   "      ::Int_t fFileReads;\n"
   "      /// Cache size used in the analysis\n"
   "      ::Int_t fCacheSize;\n"
   "      /// Time spent unzipping the events\n"
   "      ::Double_t fUnzipTime;\n"
   "      /// Time spent in processing the events\n"
   "      ::Double_t fProcessTime;\n\n"
   "      ClassDef( D3PDReadStats, 1 )\n\n"
   "   }; // class D3PDReadStats\n\n"
   "} // namespace D3PDReader\n\n"
   "#endif // D3PDREADER_D3PDREADSTATS_H";

static const char* D3PDREADSTATS_CXX_NAME = "D3PDReadStats.cxx";
static const char* D3PDREADSTATS_CXX =
   "// $Id: CodeGenerator_v2_constants.h 600807 2014-06-08 15:26:51Z krasznaa $\n\n"
   "// System include(s):\n"
   "#include <cstring>\n"
   "#include <functional>\n"
   "#include <algorithm>\n\n"
   "// ROOT include(s):\n"
   "#include <TCollection.h>\n"
   "#include <TTree.h>\n"
   "#include <TH1.h>\n\n"
   "// Local include(s):\n"
   "#include \"D3PDReadStats.h\"\n"
   "#include \"Utils.h\"\n\n"
   "ClassImp( D3PDReader::VariableStats )\n"
   "ClassImp( D3PDReader::D3PDReadStats )\n\n"
   "namespace {\n\n"
   "   /// Strict weak ordering based on the number of trees accessed by a variable\n"
   "   /**\n"
   "    * This helper function is used together with the STL std::sort algorithm\n"
   "    * to sort the D3PD variables based on how many trees they had to access\n"
   "    * during an analysis.\n"
   "    *\n"
   "    * @param v1 The first variable's access statistics\n"
   "    * @param v2 The second variable's access statistics\n"
   "    * @returns <code>kTRUE</code> if the first variable accessed more trees\n"
   "    *          than the second one. <code>kFALSE</code> otherwise.\n"
   "    */\n"
   "   ::Bool_t SortByTrees( const D3PDReader::VariableStats& v1,\n"
   "                         const D3PDReader::VariableStats& v2 ) {\n\n"
   "      return ( v1.GetTreesAccessed() > v2.GetTreesAccessed() );\n"
   "   }\n\n"
   "   /// Strict weak ordering based on the number of entries read from a variable\n"
   "   /**\n"
   "    * This helper function is used together with the STL std::sort algorithm\n"
   "    * to sort the D3PD variables based on how many events they were read in.\n"
   "    *\n"
   "    * @param v1 The first variable's access statistics\n"
   "    * @param v2 The second variable's access statistics\n"
   "    * @returns <code>kTRUE</code> if the first variable was accessed more times\n"
   "    *          than the second one. <code>kFALSE</code> otherwise.\n"
   "    */\n"
   "   ::Bool_t SortByEntries( const D3PDReader::VariableStats& v1,\n"
   "                           const D3PDReader::VariableStats& v2 ) {\n\n"
   "      return ( v1.GetReadEntries() > v2.GetReadEntries() );\n"
   "   }\n\n"
   "   /// Strict weak ordering based on the number of bytes read from a variable\n"
   "   /**\n"
   "    * This helper function is used together with the STL std::sort algorithm\n"
   "    * to sort the D3PD variables based on how much data was read from them.\n"
   "    *\n"
   "    * The ordering is based on the amount of compressed data read from disk.\n"
   "    * That is usually the more interesting one for disk access optimizations.\n"
   "    *\n"
   "    * @param v1 The first variable's access statistics\n"
   "    * @param v2 The second variable's access statistics\n"
   "    * @returns <code>kTRUE</code> if the first variable read more data\n"
   "    *          than the second one. <code>kFALSE</code> otherwise.\n"
   "    */\n"
   "   ::Bool_t SortByZippedBytes( const D3PDReader::VariableStats& v1,\n"
   "                               const D3PDReader::VariableStats& v2 ) {\n\n"
   "      return ( v1.GetZippedBytesRead() > v2.GetZippedBytesRead() );\n"
   "   }\n\n"
   "   /// Strict weak ordering based on the number of bytes unpacked from a variable\n"
   "   /**\n"
   "    * This helper function is used together with the STL std::sort algorithm\n"
   "    * to sort the D3PD variables based on how much data was unpacked from them.\n"
   "    *\n"
   "    * @param v1 The first variable's access statistics\n"
   "    * @param v2 The second variable's access statistics\n"
   "    * @returns <code>kTRUE</code> if the first variable unpacked more data\n"
   "    *          than the second one. <code>kFALSE</code> otherwise.\n"
   "    */\n"
   "   ::Bool_t SortByUnzippedBytes( const D3PDReader::VariableStats& v1,\n"
   "                                 const D3PDReader::VariableStats& v2 ) {\n\n"
   "      return ( v1.GetUnzippedBytesRead() > v2.GetUnzippedBytesRead() );\n"
   "   }\n\n"
   "   /**\n"
   "    *  @short Smart class for selecting branches for caching\n"
   "    *\n"
   "    *         This class can be used to select branches for the cache which\n"
   "    *         were accessed more than some number of times in a previous job.\n"
   "    *\n"
   "    * @author Attila Krasznahorkay <Attila.Krasznahorkay@cern.ch>\n"
   "    *\n"
   "    * $Revision: 600807 $\n"
   "    * $Date: 2014-06-08 17:26:51 +0200 (Sun, 08 Jun 2014) $\n"
   "    */\n"
   "   class SelectByEntries :\n"
   "      public std::unary_function< const D3PDReader::VariableStats&,\n"
   "                                  ::Bool_t > {\n\n"
   "   public:\n"
   "      /// Constructor specifying the minimum number of entries\n"
   "      SelectByEntries( ::Long64_t entries ) : fEntries( entries ) {}\n"
   "      /// Constructor finding the minimum number of entries\n"
   "      SelectByEntries( const D3PDReader::D3PDReadStats::Map_t& vars,\n"
   "                       ::Double_t minEvFrac )\n"
   "         : fEntries( 0 ) {\n\n"
   "         ::Long64_t maxEntries = 0;\n"
   "         D3PDReader::D3PDReadStats::Map_t::const_iterator itr = vars.begin();\n"
   "         D3PDReader::D3PDReadStats::Map_t::const_iterator end = vars.end();\n"
   "         for( ; itr != end; ++itr ) {\n"
   "            if( itr->second.GetReadEntries() > maxEntries ) {\n"
   "               maxEntries = itr->second.GetReadEntries();\n"
   "            }\n"
   "         }\n\n"
   "         fEntries = static_cast< ::Long64_t >( minEvFrac * maxEntries );\n"
   "      }\n\n"
   "      /// Operator evaluating if a variable should be selected\n"
   "      result_type operator()( argument_type var ) const {\n\n"
   "         if( var.GetReadEntries() < fEntries ) {\n"
   "            return kFALSE;\n"
   "         } else {\n"
   "            return kTRUE;\n"
   "         }\n"
   "      }\n\n"
   "   private:\n"
   "      ::Long64_t fEntries; ///< Minimum number of entries for variable\n\n"
   "   }; // class SelectByEntries\n\n"
   "   /**\n"
   "    *  @short Smart class for selecting branches for caching\n"
   "    *\n"
   "    *         This class can be used to select branches for the cache from which\n"
   "    *         more than some number bytes were read in a previous job.\n"
   "    *\n"
   "    * @author Attila Krasznahorkay <Attila.Krasznahorkay@cern.ch>\n"
   "    *\n"
   "    * $Revision: 600807 $\n"
   "    * $Date: 2014-06-08 17:26:51 +0200 (Sun, 08 Jun 2014) $\n"
   "    */\n"
   "   class SelectByBytes :\n"
   "      public std::unary_function< const D3PDReader::VariableStats&,\n"
   "                                  ::Bool_t > {\n\n"
   "   public:\n"
   "      /// Constructor specifying the minimum number of bytes read\n"
   "      SelectByBytes( ::Long64_t bytes ) : fBytes( bytes ) {}\n\n"
   "      /// Constructor finding the minimum number of bytes read\n"
   "      SelectByBytes( const D3PDReader::D3PDReadStats::Map_t& vars,\n"
   "                     ::Double_t minByteFrac )\n"
   "         : fBytes( 0 ) {\n\n"
   "         ::Long64_t maxBytes = 0;\n"
   "         D3PDReader::D3PDReadStats::Map_t::const_iterator itr = vars.begin();\n"
   "         D3PDReader::D3PDReadStats::Map_t::const_iterator end = vars.end();\n"
   "         for( ; itr != end; ++itr ) {\n"
   "            if( itr->second.GetZippedBytesRead() > maxBytes ) {\n"
   "               maxBytes = itr->second.GetZippedBytesRead();\n"
   "            }\n"
   "         }\n\n"
   "         fBytes = static_cast< ::Long64_t >( minByteFrac * maxBytes );\n"
   "      }\n\n"
   "      /// Operator evaluating if a variable should be selected\n"
   "      result_type operator()( argument_type var ) const {\n\n"
   "         if( var.GetZippedBytesRead() < fBytes ) {\n"
   "            return kFALSE;\n"
   "         } else {\n"
   "            return kTRUE;\n"
   "         }\n"
   "      }\n\n"
   "   private:\n"
   "      ::Long64_t fBytes; ///< Minimum number of bytes read from variable\n\n"
   "   }; // class SelectByEntries\n\n"
   "   /// Function adding branches to the TTreeCache\n"
   "   /**\n"
   "    * The code internally uses this function to select which branches to add to the\n"
   "    * TTreeCache.\n"
   "    *\n"
   "    * @param tree The TTree to enable the caching for\n"
   "    * @param vars All the D3PD variables we know about\n"
   "    * @param selector Functor selecting the variables to cache\n"
   "    * @returns The number of variables added to the cache\n"
   "    */\n"
   "   template< class SELECTOR >\n"
   "   ::Int_t AddToCache( ::TTree* tree, const D3PDReader::D3PDReadStats::Map_t& vars,\n"
   "                       const SELECTOR& selector ) {\n\n"
   "      ::Int_t result = 0;\n\n"
   "      D3PDReader::D3PDReadStats::Map_t::const_iterator itr = vars.begin();\n"
   "      D3PDReader::D3PDReadStats::Map_t::const_iterator end = vars.end();\n"
   "      for( ; itr != end; ++itr ) {\n"
   "         if( ! selector( itr->second ) ) continue;\n"
   "         if( tree ) tree->AddBranchToCache( itr->first, kTRUE );\n"
   "         ++result;\n"
   "      }\n\n"
   "      return result;\n"
   "   }\n\n"
   "   /// Function selecting branches with some condition\n"
   "   /**\n"
   "    * This function is used internally to select branch names.\n"
   "    *\n"
   "    * @param vars All the D3PD variables we know about\n"
   "    * @param selector Functor selecting the variables\n"
   "    * @returns The selected variable names\n"
   "    */\n"
   "   template< class SELECTOR >\n"
   "   std::vector< ::TString >\n"
   "   GetBranches( const D3PDReader::D3PDReadStats::Map_t& vars,\n"
   "                const SELECTOR& selector ) {\n\n"
   "      // The result object:\n"
   "      std::vector< ::TString > result;\n\n"
   "      // Iterate over all the variables:\n"
   "      D3PDReader::D3PDReadStats::Map_t::const_iterator itr = vars.begin();\n"
   "      D3PDReader::D3PDReadStats::Map_t::const_iterator end = vars.end();\n"
   "      for( ; itr != end; ++itr ) {\n"
   "         // Ignore the ones failing the selection:\n"
   "         if( ! selector( itr->second ) ) continue;\n"
   "         // Add this variable to the result:\n"
   "         result.push_back( itr->first );\n"
   "      }\n\n"
   "      return result;\n"
   "   }\n\n"
   "} // private namespace\n\n"
   "namespace D3PDReader {\n\n"
   "   /**\n"
   "    * The constructor can specify all properties of the object in one go. All\n"
   "    * the parameters take a default value, to make it possible to create the\n"
   "    * object without giving the constructor any parameters. (Needed by CINT.)\n"
   "    *\n"
   "    * @param name Name of the variable being described\n"
   "    * @param type Full type name of the variable being described\n"
   "    * @param nTreesAccessed Number of TTrees accessed to read this variable\n"
   "    * @param nReadEntries Number of GetEntry(...) operations performed on this variable\n"
   "    * @param nUnzippedBytes Number of bytes read after decompression\n"
   "    * @param nZippedBytes Number of bytes physically read from disk\n"
   "    */\n"
   "   VariableStats::VariableStats( const char* name, const char* type,\n"
   "                                 ::Int_t nTreesAccessed, ::Long64_t nReadEntries,\n"
   "                                 ::Long64_t nUnzippedBytes, ::Long64_t nZippedBytes )\n"
   "     : TNamed( name, type ), fTreesAccessed( nTreesAccessed ),\n"
   "       fReadEntries( nReadEntries ), fUnzippedBytes( nUnzippedBytes ),\n"
   "       fZippedBytes( nZippedBytes ) {\n\n"
   "   }\n\n"
   "   /**\n"
   "    * It's probably not needed actually, but I wanted to be explicit about how the\n"
   "    * copy constructor should behave.\n"
   "    *\n"
   "    * @param parent The object that's being copied\n"
   "    */\n"
   "   VariableStats::VariableStats( const VariableStats& parent )\n"
   "      : TNamed( parent ), fTreesAccessed( parent.fTreesAccessed ),\n"
   "        fReadEntries( parent.fReadEntries ), fUnzippedBytes( parent.fUnzippedBytes ),\n"
   "        fZippedBytes( parent.fZippedBytes ) {\n\n"
   "   }\n\n"
   "   /**\n"
   "    * The assignment operator is quite an important piece of code, as it's\n"
   "    * used all the time when using such objects in STL containers.\n"
   "    *\n"
   "    * @param parent The object that's being copied\n"
   "    * @returns A reference to the copied object\n"
   "    */\n"
   "   VariableStats& VariableStats::operator= ( const VariableStats& parent ) {\n\n"
   "      // Set the properties of TNamed:\n"
   "      SetName( parent.GetName() );\n"
   "      SetTitle( parent.GetTitle() );\n\n"
   "      // Set the properties of this class:\n"
   "      fTreesAccessed = parent.fTreesAccessed;\n"
   "      fReadEntries   = parent.fReadEntries;\n"
   "      fUnzippedBytes = parent.fUnzippedBytes;\n"
   "      fZippedBytes   = parent.fZippedBytes;\n\n"
   "      return *this;\n"
   "   }\n\n"
   "   ::Int_t VariableStats::GetTreesAccessed() const {\n\n"
   "      return fTreesAccessed;\n"
   "   }\n\n"
   "   void VariableStats::SetTreesAccessed( ::Int_t nTreesAccessed ) {\n\n"
   "      fTreesAccessed = nTreesAccessed;\n"
   "      return;\n"
   "   }\n\n"
   "   ::Long64_t VariableStats::GetReadEntries() const {\n\n"
   "      return fReadEntries;\n"
   "   }\n\n"
   "   void VariableStats::SetReadEntries( ::Long64_t nReadEntries ) {\n\n"
   "      fReadEntries = nReadEntries;\n"
   "      return;\n"
   "   }\n\n"
   "   ::Long64_t VariableStats::GetUnzippedBytesRead() const {\n\n"
   "      return fUnzippedBytes;\n"
   "   }\n\n"
   "   void VariableStats::SetUnzippedBytesRead( ::Long64_t nUnzippedBytes ) {\n\n"
   "      fUnzippedBytes = nUnzippedBytes;\n"
   "      return;\n"
   "   }\n\n"
   "   ::Long64_t VariableStats::GetZippedBytesRead() const {\n\n"
   "      return fZippedBytes;\n"
   "   }\n\n"
   "   void VariableStats::SetZippedBytesRead( ::Long64_t nZippedBytes ) {\n\n"
   "      fZippedBytes = nZippedBytes;\n"
   "      return;\n"
   "   }\n\n"
   "   VariableStats& VariableStats::Add( const VariableStats& rh ) {\n\n"
   "      // Set the properties of TNamed:\n"
   "      SetName( rh.GetName() );\n"
   "      SetTitle( rh.GetTitle() );\n\n"
   "      // Accumulate the gathered statistics:\n"
   "      fTreesAccessed += rh.GetTreesAccessed();\n"
   "      fReadEntries   += rh.GetReadEntries();\n"
   "      fUnzippedBytes += rh.GetUnzippedBytesRead();\n"
   "      fZippedBytes   += rh.GetZippedBytesRead();\n\n"
   "      return *this;\n"
   "   }\n\n"
   "   VariableStats& VariableStats::operator+= ( const VariableStats& rh ) {\n\n"
   "      return Add( rh );\n"
   "   }\n\n"
   "   /**\n"
   "    * This function makes it possible to properly merge objects coming from\n"
   "    * PROOF workers.\n"
   "    *\n"
   "    * @param coll A collection of D3PDReader::VariableStats objects\n"
   "    * @returns <code>0</code> in case of failure, a positive number\n"
   "    *          in case of success\n"
   "    */\n"
   "   ::Int_t VariableStats::Merge( ::TCollection* coll ) {\n\n"
   "      // Some security checks:\n"
   "      if( ! coll ) return 0;\n"
   "      if( coll->IsEmpty() ) return 0;\n\n"
   "      // Iterate over the elements of the collection:\n"
   "      ::TIter next( coll );\n"
   "      ::TObject* obj = 0;\n"
   "      while( ( obj = next() ) ) {\n\n"
   "         // Check that the element is of the right type:\n"
   "         VariableStats* vobj = dynamic_cast< VariableStats* >( obj );\n"
   "         if( ! vobj ) {\n"
   "            Error( \"Merge\", \"Unknown object type encountered: %s\",\n"
   "                   obj->ClassName() );\n"
   "            return 0;\n"
   "         }\n\n"
   "         // Add this element to this object:\n"
   "         Add( *vobj );\n"
   "      }\n\n"
   "      return 1;\n"
   "   }\n\n"
   "   /**\n"
   "    * Standard ROOT printing function. It prints all information about the\n"
   "    * statistics gathered about a single D3PD variable.\n"
   "    *\n"
   "    * The option parameter understands the following value(s):\n"
   "    *   - \"All\": Prints the most verbose information available\n"
   "    *\n"
   "    * @param option Possible options for the printing verbosity\n"
   "    */\n"
   "   void VariableStats::Print( ::Option_t* option ) const {\n\n"
   "      // Print the most basic info:\n"
   "      Info( \"Print\", \"Variable name \\\"%s\\\", type \\\"%s\\\"\",\n"
   "            GetName(), GetTitle() );\n\n"
   "      // Print the access statistics only if requested:\n"
   "      if( ! ::strcmp( option, \"All\" ) ) {\n"
   "         Info( \"Print\", \"  TTrees accessed for this variable: %i\",\n"
   "               fTreesAccessed );\n"
   "         Info( \"Print\", \"  Number of entries read           : %lli\"\n,"
   "               fReadEntries );\n"
   "         Info( \"Print\", \"  Number of unzipped bytes read    : %lli\",\n"
   "               fUnzippedBytes );\n"
   "         Info( \"Print\", \"  Number of zipped bytes read      : %lli\",\n"
   "               fZippedBytes );\n"
   "      }\n\n"
   "      return;\n"
   "   }\n\n"
   "   /**\n"
   "    * In order to be able to stream such objects, they have to have an\n"
   "    * explicit name. It can be specified using this constructor, but\n"
   "    * usually leaving the default is just fine.\n"
   "    *\n"
   "    * @param name Name for the object\n"
   "    * @param title Optional title for the object (not used for anything)\n"
   "    */\n"
   "   D3PDReadStats::D3PDReadStats( const char* name, const char* title )\n"
   "      : ::TNamed( name, title ), fVariables(),\n"
   "        fBytesRead( 0 ), fVariableNum( 0 ),\n"
   "        fFileReads( 0 ), fCacheSize( 0 ),\n"
   "        fUnzipTime( 0.0 ), fProcessTime( 0.0 ) {\n\n"
   "   }\n\n"
   "   /**\n"
   "    * It's probably not needed actually, but I wanted to be explicit about how the\n"
   "    * copy constructor should behave.\n"
   "    *\n"
   "    * @param parent The object that's being copied\n"
   "    */\n"
   "   D3PDReadStats::D3PDReadStats( const D3PDReadStats& parent )\n"
   "      : ::TNamed( parent ), fVariables( parent.fVariables ),\n"
   "        fBytesRead( parent.fBytesRead ), fVariableNum( parent.fVariableNum ),\n"
   "        fFileReads( parent.fFileReads ), fCacheSize( parent.fCacheSize ),\n"
   "        fUnzipTime( parent.fUnzipTime ), fProcessTime( parent.fProcessTime ) {\n\n"
   "   }\n\n"
   "   /**\n"
   "    * This is probably not needed either, but again, I wanted to be\n"
   "    * explicit.\n"
   "    *\n"
   "    * @param parent The object that's being copied\n"
   "    * @returns A reference to the copied object\n"
   "    */\n"
   "   D3PDReadStats& D3PDReadStats::operator= ( const D3PDReadStats& parent ) {\n\n"
   "      // Set the properties of TNamed:\n"
   "      SetName( parent.GetName() );\n"
   "      SetTitle( parent.GetTitle() );\n\n"
   "      // Set the properties of this class:\n"
   "      fVariables   = parent.fVariables;\n"
   "      fBytesRead   = parent.fBytesRead;\n"
   "      fVariableNum = parent.fVariableNum;\n"
   "      fFileReads   = parent.fFileReads;\n"
   "      fCacheSize   = parent.fCacheSize;\n"
   "      fUnzipTime   = parent.fUnzipTime;\n"
   "      fProcessTime = parent.fProcessTime;\n\n"
   "      return *this;\n"
   "   }\n\n"
   "   void D3PDReadStats::Clear( ::Option_t* ) {\n\n"
   "      // Clear all accumulated statistics:\n"
   "      fVariables.clear();\n"
   "      fBytesRead = 0;\n"
   "      fVariableNum = 0;\n"
   "      fFileReads = 0;\n"
   "      fCacheSize = 0;\n"
   "      fUnzipTime = 0.0;\n"
   "      fProcessTime = 0.0;\n\n"
   "      return;\n"
   "   }\n\n"
   "   void D3PDReadStats::SetBytesRead( ::Long64_t num ) {\n\n"
   "      fBytesRead = num;\n"
   "      return;\n"
   "   }\n\n"
   "   ::Long64_t D3PDReadStats::GetBytesRead() const {\n\n"
   "      return fBytesRead;\n"
   "   }\n\n"
   "   void D3PDReadStats::SetVariableNum( ::Int_t num ) {\n\n"
   "      fVariableNum = num;\n"
   "      return;\n"
   "   }\n\n"
   "   ::Int_t D3PDReadStats::GetVariableNum() const {\n\n"
   "      return fVariableNum;\n"
   "   }\n\n"
   "   void D3PDReadStats::SetFileReads( ::Int_t num ) {\n\n"
   "      fFileReads = num;\n"
   "      return;\n"
   "   }\n\n"
   "   ::Int_t D3PDReadStats::GetFileReads() const {\n\n"
   "      return fFileReads;\n"
   "   }\n\n"
   "   void D3PDReadStats::SetCacheSize( ::Int_t size ) {\n\n"
   "      fCacheSize = size;\n"
   "      return;\n"
   "   }\n\n"
   "   ::Int_t D3PDReadStats::GetCacheSize() const {\n\n"
   "      return fCacheSize;\n"
   "   }\n\n"
   "   void D3PDReadStats::SetUnzipTime( ::Double_t time ) {\n\n"
   "      fUnzipTime = time;\n"
   "      return;\n"
   "   }\n\n"
   "   ::Double_t D3PDReadStats::GetUnzipTime() const {\n\n"
   "      return fUnzipTime;\n"
   "   }\n\n"
   "   void D3PDReadStats::SetProcessTime( ::Double_t time ) {\n\n"
   "      fProcessTime = time;\n"
   "      return;\n"
   "   }\n\n"
   "   ::Double_t D3PDReadStats::GetProcessTime() const {\n\n"
   "      return fProcessTime;\n"
   "   }\n\n"
   "   /**\n"
   "    * Add information about a single variable to the statistics. Note that\n"
   "    * it's perfectly valid to add multiple objects describing the same variable.\n"
   "    * In that case the information is accumulated properly.\n"
   "    *\n"
   "    * @param var Access statistics for a single variable\n"
   "    * @returns A reference to the modified object\n"
   "    */\n"
   "   D3PDReadStats& D3PDReadStats::AddVariable( const VariableStats& var ) {\n\n"
   "      // Do the accumulation quite simply:\n"
   "      fVariables[ var.GetName() ] += var;\n\n"
   "      return *this;\n"
   "   }\n\n"
   "   /**\n"
   "    * Get the access statistics of a single D3PD variable.\n"
   "    *\n"
   "    * @param name The name of the D3PD variable\n"
   "    * @returns A pointer to the object describing the access statistics,\n"
   "    *          or a null pointer if the variable is unknown\n"
   "    */\n"
   "   const VariableStats* D3PDReadStats::GetVariable( const char* name ) const {\n\n"
   "      // Search for the variable:\n"
   "      Map_t::const_iterator itr = fVariables.find( name );\n"
   "      if( itr != fVariables.end() ) {\n"
   "         return &( itr->second );\n"
   "      }\n\n"
   "      // Return a null pointer if the object was not found:\n"
   "      return 0;\n"
   "   }\n\n"
   "   const D3PDReadStats::Map_t& D3PDReadStats::GetVariables() const {\n\n"
   "      return fVariables;\n"
   "   }\n\n"
   "   /**\n"
   "    * This function checks whether two objects are \"compatible\" with\n"
   "    * each other. This just means that it checks whether it appears as\n"
   "    * if the two statistics objects would've been recorded from the same\n"
   "    * input type or not.\n"
   "    *\n"
   "    * @param rh Object to compare to this object\n"
   "    * @returns <code>kTRUE</code> if the two objects are compatible,\n"
   "    *          <code>kFALSE</code> otherwise\n"
   "    */\n"
   "   ::Bool_t D3PDReadStats::IsCompatible( const D3PDReadStats& rh ) const {\n\n"
   "      if( ( fVariableNum == rh.GetVariableNum() ) &&\n"
   "          ( fCacheSize   == rh.GetCacheSize() ) ) {\n"
   "         return kTRUE;\n"
   "      } else {\n"
   "         return kFALSE;\n"
   "      }\n"
   "   }\n\n"
   "   /**\n"
   "    * This function is used to merge the information from two objects.\n"
   "    *\n"
   "    * @param rh The object to be merged into this one\n"
   "    * @returns A reference to the merged object\n"
   "    */\n"
   "   D3PDReadStats& D3PDReadStats::Add( const D3PDReadStats& rh ) {\n\n"
   "      // Merge the variable statistics one by one:\n"
   "      Map_t::const_iterator itr = rh.GetVariables().begin();\n"
   "      Map_t::const_iterator end = rh.GetVariables().end();\n"
   "      for( ; itr != end; ++itr ) {\n"
   "         fVariables[ itr->first ] += itr->second;\n"
   "      }\n\n"
   "      // Sum up the simple statistics:\n"
   "      fBytesRead   += rh.GetBytesRead();\n"
   "      fFileReads   += rh.GetFileReads();\n"
   "      fUnzipTime   += rh.GetUnzipTime();\n"
   "      fProcessTime += rh.GetProcessTime();\n\n"
   "      return *this;\n"
   "   }\n\n"
   "   D3PDReadStats& D3PDReadStats::operator+= ( const D3PDReadStats& rh ) {\n\n"
   "      return Add( rh );\n"
   "   }\n\n"
   "   /**\n"
   "    * This function can be used to add all the branches that this object\n"
   "    * knows about, to the cache of the TTree given to the function.\n"
   "    *\n"
   "    * It can be useful for blankly enabling caching for all the variables\n"
   "    * that a D3PDReader object can possibly access.\n"
   "    *\n"
   "    * @param tree Tree for which the caching should be configured\n"
   "    */\n"
   "   void D3PDReadStats::AddToTreeCache( ::TTree* tree ) const {\n\n"
   "      // Add all the branches to the cache:\n"
   "      const ::Int_t counter = AddToCache( tree, fVariables,\n"
   "                                          SelectByEntries( 0 ) );\n\n"
   "      // Let the user know what we did:\n"
   "      Info( \"AddToTreeCache\", \"Added %i branches to the TTreeCache\",\n"
   "            counter );\n\n"
   "      return;\n"
   "   }\n\n"
   "   /**\n"
   "    * This should be one of the most useful functions of this class. It can\n"
   "    * be used to selectively enable the caching for the branches which were\n"
   "    * accessed more than a specified number of times in a previous running.\n"
   "    *\n"
   "    * @param tree Tree for which the caching should be configured\n"
   "    * @param minEntries Minimum number of entries read from the variable to\n"
   "    *                   qualify for caching\n"
   "    */\n"
   "   void D3PDReadStats::AddToTreeCacheByEntries( ::TTree* tree,\n"
   "                                                ::Long64_t minEntries ) const {\n\n"
   "      // Add the selected branches to the cache:\n"
   "      const ::Int_t counter = AddToCache( tree, fVariables,\n"
   "                                          SelectByEntries( minEntries ) );\n\n"
   "      // Let the user know what we did:\n"
   "      Info( \"AddToTreeCacheByEntries\", \"Added %i branches to the TTreeCache\",\n"
   "            counter );\n\n"
   "      return;\n"
   "   }\n\n"
   "   /**\n"
   "    * This should be one of the most useful functions of this class. It can\n"
   "    * be used to selectively enable the caching for the branches which were\n"
   "    * accessed more than a specified fraction of times in a previous running.\n"
   "    * This is slightly more general than the version of this function expecting\n"
   "    * an absolute entry number.\n"
   "    *\n"
   "    * @param tree Tree for which the caching should be configured\n"
   "    * @param minEvFraction Minimum fraction of entries read from the branches\n"
   "    *                      that should be added to the cache\n"
   "    */\n"
   "   void D3PDReadStats::AddToTreeCacheByEntryFrac( ::TTree* tree,\n"
   "                                                  ::Double_t minEvFraction ) const {\n\n"
   "      // Add the selected branches to the cache:\n"
   "      const ::Int_t counter = AddToCache( tree, fVariables,\n"
   "                                          SelectByEntries( fVariables,\n"
   "                                                           minEvFraction ) );\n\n"
   "      // Let the user know what we did:\n"
   "      Info( \"AddToTreeCacheByEntries\", \"Added %i branches to the TTreeCache\",\n"
   "            counter );\n\n"
   "      return;\n"
   "   }\n\n"
   "   /**\n"
   "    * This function can be used to add all the variables to the cache\n"
   "    * from which more than some bytes were read in a previous running.\n"
   "    *\n"
   "    * @param tree Tree for which the caching should be configured\n"
   "    * @param minBytes Minimum number of bytes read from the variable to\n"
   "    *                 qualify for caching\n"
   "    */\n"
   "   void D3PDReadStats::AddToTreeCacheByBytes( ::TTree* tree,\n"
   "                                              ::Long64_t minBytes ) const {\n\n"
   "      // Add the selected branches to the cache:\n"
   "      const ::Int_t counter = AddToCache( tree, fVariables,\n"
   "                                          SelectByBytes( minBytes ) );\n\n"
   "      // Let the user know what we did:\n"
   "      Info( \"AddToTreeCacheByBytes\", \"Added %i branches to the TTreeCache\",\n"
   "            counter );\n\n"
   "      return;\n"
   "   }\n\n"
   "   /**\n"
   "    * This function can be used to add all the variables to the cache\n"
   "    * from which more than some fraction of the bytes were read in a\n"
   "    * previous running.\n"
   "    *\n"
   "    * @param tree Tree for which the caching should be configured\n"
   "    * @param minByteFraction Minimum fraction of bytes read from the\n"
   "    *                        variable to qualify for caching\n"
   "    */\n"
   "   void D3PDReadStats::AddToTreeCacheByByteFrac( ::TTree* tree,\n"
   "                                                 ::Double_t minByteFraction ) const {\n\n"
   "      // Add the selected branches to the cache:\n"
   "      const ::Int_t counter = AddToCache( tree, fVariables,\n"
   "                                          SelectByBytes( fVariables,\n"
   "                                                         minByteFraction ) );\n\n"
   "      // Let the user know what we did:\n"
   "      Info( \"AddToTreeCacheByBytes\", \"Added %i branches to the TTreeCache\",\n"
   "            counter );\n\n"
   "      return;\n"
   "   }\n\n"
   "   /**\n"
   "    * This function can be used to get a list of branch names that were\n"
   "    * accessed more than a specified number of times in the analysis.\n"
   "    *\n"
   "    * @param minEntries Minimum number of entries read from the variables\n"
   "    * @returns A list of variable names fulfilling the requirement\n"
   "    */\n"
   "   std::vector< ::TString >\n"
   "   D3PDReadStats::GetBranchesByEntries( ::Long64_t minEntries ) const {\n\n"
   "      return GetBranches( fVariables, SelectByEntries( minEntries ) );\n"
   "   }\n\n"
   "   /**\n"
   "    * This function can be used to get a list of branch names that were\n"
   "    * accessed more than some fraction of times in the analysis.\n"
   "    *\n"
   "    * @param minEvFrac Minimum fraction of entries read from the variables\n"
   "    * @returns A list of variable names fulfilling the requirement\n"
   "    */\n"
   "   std::vector< ::TString >\n"
   "   D3PDReadStats::GetBranchesByEntryFrac( ::Double_t minEvFrac ) const {\n\n"
   "      return GetBranches( fVariables,\n"
   "                          SelectByEntries( fVariables, minEvFrac ) );\n"
   "   }\n\n"
   "   /**\n"
   "    * This function can be used to get a list of branch names from which\n"
   "    * more than a specified number of bytes were read in the analysis.\n"
   "    *\n"
   "    * @param minBytes Minimum number of bytes read from the variables\n"
   "    * @returns A list of variable names fulfilling the requirement\n"
   "    */\n"
   "   std::vector< ::TString >\n"
   "   D3PDReadStats::GetBranchesByBytes( ::Long64_t minBytes ) const {\n\n"
   "      return GetBranches( fVariables, SelectByBytes( minBytes ) );\n"
   "   }\n\n"
   "   /**\n"
   "    * This function can be used to get a list of branch names from which\n"
   "    * more than a specified fraction of bytes were read in the analysis.\n"
   "    *\n"
   "    * @param minByteFraction Minimum fraction of bytes read from the\n"
   "    *                        variables\n"
   "    * @returns A list of variable names fulfilling the requirement\n"
   "    */\n"
   "   std::vector< ::TString >\n"
   "   D3PDReadStats::GetBranchesByByteFrac( ::Double_t minByteFraction ) const {\n\n"
   "      return GetBranches( fVariables,\n"
   "                          SelectByBytes( fVariables, minByteFraction ) );\n"
   "   }\n\n"
   "   /**\n"
   "    * This function can be used to produce a nice histogram showing how many\n"
   "    * TTrees were accessed by how many of the branches.\n"
   "    *\n"
   "    * Note that the caller is responsible for deleting the created histogram.\n"
   "    *\n"
   "    * @returns The histogram showing the distribution\n"
   "    */\n"
   "   ::TH1* D3PDReadStats::GetTreeAccessStat() const {\n\n"
   "      // Find the branch(es) which accessed the most trees:\n"
   "      ::Long64_t maxTrees = 0;\n"
   "      Map_t::const_iterator itr = fVariables.begin();\n"
   "      Map_t::const_iterator end = fVariables.end();\n"
   "      for( ; itr != end; ++itr ) {\n"
   "         if( itr->second.GetTreesAccessed() > maxTrees ) {\n"
   "            maxTrees = itr->second.GetTreesAccessed();\n"
   "         }\n"
   "      }\n\n"
   "      // Create the histogram:\n"
   "      ::TH1* result = new ::TH1D( \"TreeAccessStat\",\n"
   "                                  \"TTree access statistics;TTrees;Branches\",\n"
   "                                  100, 0.0, ( ( ::Double_t ) maxTrees ) * 1.1 );\n\n"
   "      // Fill the histogram by looping over the variables once more:\n"
   "      itr = fVariables.begin();\n"
   "      end = fVariables.end();\n"
   "      for( ; itr != end; ++itr ) {\n"
   "         result->Fill( ( ::Double_t ) itr->second.GetTreesAccessed() );\n"
   "      }\n\n"
   "      return result;\n"
   "   }\n\n"
   "   /**\n"
   "    * This function can be used to produce a nice histogram showing how many\n"
   "    * entries were accessed by how many of the branches.\n"
   "    *\n"
   "    * Note that the caller is responsible for deleting the created histogram.\n"
   "    *\n"
   "    * @returns The histogram showing the distribution\n"
   "    */\n"
   "   ::TH1* D3PDReadStats::GetEntryReadStat() const {\n\n"
   "      // Find the branch(es) which accessed the most entries:\n"
   "      ::Long64_t maxEntries = 0;\n"
   "      Map_t::const_iterator itr = fVariables.begin();\n"
   "      Map_t::const_iterator end = fVariables.end();\n"
   "      for( ; itr != end; ++itr ) {\n"
   "         if( itr->second.GetReadEntries() > maxEntries ) {\n"
   "            maxEntries = itr->second.GetReadEntries();\n"
   "         }\n"
   "      }\n\n"
   "      // Create the histogram:\n"
   "      ::TH1* result = new ::TH1D( \"EntryAccessStat\",\n"
   "                                  \"Entry access statistics;Entries;Branches\",\n"
   "                                  100, 0.0, ( ( ::Double_t ) maxEntries ) * 1.1 );\n\n"
   "      // Fill the histogram by looping over the variables once more:\n"
   "      itr = fVariables.begin();\n"
   "      end = fVariables.end();\n"
   "      for( ; itr != end; ++itr ) {\n"
   "         result->Fill( ( ::Double_t ) itr->second.GetReadEntries() );\n"
   "      }\n\n"
   "      return result;\n"
   "   }\n\n"
   "   /**\n"
   "    * This function can be used to produce a nice histogram showing how many\n"
   "    * raw bytes were accessed by how many of the branches.\n"
   "    *\n"
   "    * Note that the caller is responsible for deleting the created histogram.\n"
   "    *\n"
   "    * @returns The histogram showing the distribution\n"
   "    */\n"
   "   ::TH1* D3PDReadStats::GetZippedByteReadStat() const {\n\n"
   "      // Find the branch(es) which accessed the most bytes:\n"
   "      ::Long64_t maxBytes = 0;\n"
   "      Map_t::const_iterator itr = fVariables.begin();\n"
   "      Map_t::const_iterator end = fVariables.end();\n"
   "      for( ; itr != end; ++itr ) {\n"
   "         if( itr->second.GetZippedBytesRead() > maxBytes ) {\n"
   "            maxBytes = itr->second.GetZippedBytesRead();\n"
   "         }\n"
   "      }\n\n"
   "      // Create the histogram:\n"
   "      ::TH1* result = new ::TH1D( \"ZippedByteAccessStat\",\n"
   "                                  \"Zipped byte access statistics;Bytes;Branches\",\n"
   "                                  100, 0.0, ( ( ::Double_t ) maxBytes ) * 1.1 );\n\n"
   "      // Fill the histogram by looping over the variables once more:\n"
   "      itr = fVariables.begin();\n"
   "      end = fVariables.end();\n"
   "      for( ; itr != end; ++itr ) {\n"
   "         result->Fill( ( ::Double_t ) itr->second.GetZippedBytesRead() );\n"
   "      }\n\n"
   "      return result;\n"
   "   }\n\n"
   "   /**\n"
   "    * This function can be used to produce a nice histogram showing how many\n"
   "    * uncompressed bytes were accessed by how many of the branches.\n"
   "    *\n"
   "    * Note that the caller is responsible for deleting the created histogram.\n"
   "    *\n"
   "    * @returns The histogram showing the distribution\n"
   "    */\n"
   "   ::TH1* D3PDReadStats::GetUnzippedByteReadStat() const {\n\n"
   "      // Find the branch(es) which accessed the most bytes:\n"
   "      ::Long64_t maxBytes = 0;\n"
   "      Map_t::const_iterator itr = fVariables.begin();\n"
   "      Map_t::const_iterator end = fVariables.end();\n"
   "      for( ; itr != end; ++itr ) {\n"
   "         if( itr->second.GetUnzippedBytesRead() > maxBytes ) {\n"
   "            maxBytes = itr->second.GetUnzippedBytesRead();\n"
   "         }\n"
   "      }\n\n"
   "      // Create the histogram:\n"
   "      ::TH1* result = new ::TH1D( \"UnzippedByteAccessStat\",\n"
   "                                  \"Unzipped byte access statistics;Bytes;Branches\",\n"
   "                                  100, 0.0, ( ( ::Double_t ) maxBytes ) * 1.1 );\n\n"
   "      // Fill the histogram by looping over the variables once more:\n"
   "      itr = fVariables.begin();\n"
   "      end = fVariables.end();\n"
   "      for( ; itr != end; ++itr ) {\n"
   "         result->Fill( ( ::Double_t ) itr->second.GetUnzippedBytesRead() );\n"
   "      }\n\n"
   "      return result;\n"
   "   }\n\n"
   "   /**\n"
   "    * This function makes it possible to properly merge objects coming from\n"
   "    * PROOF workers.\n"
   "    *\n"
   "    * @param coll A collection of D3PDReader::VariableStats objects\n"
   "    * @returns <code>0</code> in case of failure, a positive number\n"
   "    *          in case of success\n"
   "    */\n"
   "   ::Int_t D3PDReadStats::Merge( ::TCollection* coll ) {\n\n"
   "      // Some security checks:\n"
   "      if( ! coll ) return 0;\n"
   "      if( coll->IsEmpty() ) return 0;\n\n"
   "      // Iterate over the elements of the collection:\n"
   "      ::TIter next( coll );\n"
   "      ::TObject* obj = 0;\n"
   "      while( ( obj = next() ) ) {\n\n"
   "         // Check that the element is of the right type:\n"
   "         D3PDReadStats* dobj = dynamic_cast< D3PDReadStats* >( obj );\n"
   "         if( ! dobj ) {\n"
   "            Error( \"Merge\", \"Unknown object type encountered: %s\",\n"
   "                   obj->ClassName() );\n"
   "            return 0;\n"
   "         }\n\n"
   "         // The compatibility of the objects is no longer checked. When\n"
   "         // processing a large dataset, it's probable that the objects\n"
   "         // created by the different PROOF workers will not be \"compatible\".\n\n"
   "         // Add this element to this object:\n"
   "         Add( *dobj );\n"
   "      }\n\n"
   "      return 1;\n"
   "   }\n\n"
   "   /**\n"
   "    * Standard ROOT printing function. It prints the gathered information\n"
   "    * about the variables accessed in an analysis.\n"
   "    *\n"
   "    * The option parameter understands the following value(s):\n"
   "    *   - \"Summary\": Only the summary information is printed.\n"
   "    *   - \"ByEntries\": Order the variables by the number of entries\n"
   "    *     read from them.\n"
   "    *   - \"ByBytes\": Order the variables by the number of bytes\n"
   "    *     read from them.\n"
   "    *\n"
   "    * @param option Possible options for the printing\n"
   "    */\n"
   "   void D3PDReadStats::Print( ::Option_t* option ) const {\n\n"
   "      Info( \"Print\", \"Printing D3PD usage statistics\" );\n\n"
   "      // Calculate how many bytes were used during the analysis:\n"
   "      ::Long64_t bytesUsed = 0;\n"
   "      Map_t::const_iterator map_itr = fVariables.begin();\n"
   "      Map_t::const_iterator map_end = fVariables.end();\n"
   "      for( ; map_itr != map_end; ++map_itr ) {\n"
   "         bytesUsed += map_itr->second.GetZippedBytesRead();\n"
   "      }\n\n"
   "      // Print the summary information:\n"
   "      Info( \"Print\", \"  Number of variables in the input D3PD : %i\",\n"
   "            fVariableNum );\n"
   "      Info( \"Print\", \"  Variables with D3PDReader objects     : %i\",\n"
   "            static_cast< Int_t >( fVariables.size() ) );\n"
   "      Info( \"Print\", \"  TTreeCache size used                  : %s\",\n"
   "            SizeToString( fCacheSize ).Data() );\n"
   "      Info( \"Print\", \"  Total number of bytes read            : %s\",\n"
   "            SizeToString( fBytesRead ).Data() );\n"
   "      Info( \"Print\", \"  Total number of bytes used            : %s (%g%%)\",\n"
   "            SizeToString( bytesUsed ).Data(),\n"
   "            ( ( ::Double_t ) bytesUsed /\n"
   "              ( ::Double_t ) fBytesRead * 100.0 ) );\n"
   "      Info( \"Print\", \"  Data reading speed per process        : %s\",\n"
   "            SpeedToString( fBytesRead / fProcessTime ).Data() );\n"
   "      Info( \"Print\", \"  Useful data processing speed per proc.: %s\",\n"
   "            SpeedToString( bytesUsed / fProcessTime ).Data() );\n"
   "      Info( \"Print\", \"  Total number of file read operations  : %i\",\n"
   "            fFileReads );\n"
   "      Info( \"Print\", \"  Data read in one go (on average)      : %s\",\n"
   "            SizeToString( ( ::Long64_t ) ( ( ::Double_t ) fBytesRead /\n"
   "                                           ( ::Double_t ) fFileReads ) ).Data() );\n"
   "      Info( \"Print\", \"  Cumulative time spent processing data : %s\",\n"
   "            TimeToString( fProcessTime ).Data() );\n"
   "      Info( \"Print\", \"  Cumulative time spent unzipping data  : %s\",\n"
   "            TimeToString( fUnzipTime ).Data() );\n\n"
   "      // If we just needed summary information, stop here:\n"
   "      if( ! ::strcmp( option, \"Summary\" ) ) {\n"
   "         return;\n"
   "      }\n\n"
   "      // Create a temporary vector of the objects, so they can be ordered\n"
   "      // if necessary:\n"
   "      std::vector< VariableStats > vars;\n"
   "      map_itr = fVariables.begin();\n"
   "      map_end = fVariables.end();\n"
   "      for( ; map_itr != map_end; ++map_itr ) {\n"
   "         vars.push_back( map_itr->second );\n"
   "      }\n\n"
   "      // Select the kind of ordering for the variables:\n"
   "      if( ! ::strcmp( option, \"ByEntries\" ) ) {\n"
   "         Info( \"Print\", \"Variables, sorted by number of accesses:\" );\n"
   "         std::sort( vars.begin(), vars.end(), SortByEntries );\n"
   "      } else if( ! ::strcmp( option, \"ByBytes\" ) ) {\n"
   "         Info( \"Print\", \"Variables, sorted by number of bytes read:\" );\n"
   "         std::sort( vars.begin(), vars.end(), SortByUnzippedBytes );\n"
   "      } else {\n"
   "         Info( \"Print\", \"Variables, sorted by name:\" );\n"
   "      }\n\n"
   "      // Print the statistics from each variable:\n"
   "      std::vector< VariableStats >::const_iterator vec_itr =\n"
   "         vars.begin();\n"
   "      std::vector< VariableStats >::const_iterator vec_end =\n"
   "         vars.end();\n"
   "      for( ; vec_itr != vec_end; ++vec_itr ) {\n"
   "         vec_itr->Print();\n"
   "      }\n\n"
   "      return;\n"
   "   }\n\n"
   "} // namespace D3PDReader";

static const char* D3PDPERFSTATS_HEADER_NAME = "D3PDPerfStats.h";
static const char* D3PDPERFSTATS_HEADER =
   "// Dear emacs, this is -*- c++ -*-\n"
   "// $Id: CodeGenerator_v2_constants.h 600807 2014-06-08 15:26:51Z krasznaa $\n"
   "#ifndef D3PDREADER_D3PDPERFSTATS_H\n"
   "#define D3PDREADER_D3PDPERFSTATS_H\n\n"
   "// ROOT include(s):\n"
   "#include <TVirtualPerfStats.h>\n\n"
   "// Local include(s):\n"
   "#include \"D3PDReadStats.h\"\n\n"
   "// Forward declaration(s):\n"
   "class TTree;\n\n"
   "namespace D3PDReader {\n\n"
   "   /**\n"
   "    *  @short Specific class for collecting information about a D3PD file access pattern\n"
   "    *\n"
   "    *         This class is used for collecting the basic information about the file\n"
   "    *         access during a D3PD analysis.\n"
   "    *\n"
   "    * @author Attila Krasznahorkay <Attila.Krasznahorkay@cern.ch>\n"
   "    *\n"
   "    * $Revision: 600807 $\n"
   "    * $Date: 2014-06-08 17:26:51 +0200 (Sun, 08 Jun 2014) $\n"
   "    */\n"
   "   class D3PDPerfStats : public ::TVirtualPerfStats {\n\n"
   "   public:\n"
   "      /// Destructor, sometimes called by PROOF\n"
   "      ~D3PDPerfStats();\n\n"
   "      /// Function accessing the singleton instance\n"
   "      static D3PDPerfStats* Instance();\n\n"
   "      /// Function for accessing the collected statistics information\n"
   "      const D3PDReadStats& GetStats() const;\n\n"
   "      /// Function that should be called when a new TTree is accessed\n"
   "      void NewTreeAccessed( ::TTree* tree );\n\n"
   "      /// Start the statistics collection\n"
   "      void Start( ::Bool_t clear = kTRUE );\n"
   "      /// Stop the statistics collection\n"
   "      void Stop();\n\n"
   "      //\n"
   "      // Functions inherited from TVirtualPerfStats:\n"
   "      //\n"
   "      virtual void SimpleEvent( EEventType type );\n"
   "      virtual void PacketEvent( const char *slave, const char *slavename, const char *filename,\n"
   "                                ::Long64_t eventsprocessed, ::Double_t latency,\n"
   "                                ::Double_t proctime, ::Double_t cputime,\n"
   "                                ::Long64_t bytesRead );\n"
   "      virtual void FileEvent( const char *slave, const char *slavename, const char *nodename,\n"
   "                              const char *filename, ::Bool_t isStart );\n"
   "      virtual void FileOpenEvent( ::TFile *file, const char *filename, ::Double_t start );\n"
   "      virtual void FileReadEvent( ::TFile *file, ::Int_t len, ::Double_t start );\n"
   "#if ROOT_VERSION_CODE < ROOT_VERSION( 5, 99, 0 )\n"
   "      virtual void FileUnzipEvent( ::TFile *file, ::Long64_t pos, ::Double_t start, ::Int_t complen,\n"
   "                                   ::Int_t objlen );\n"
   "#else\n"
   "      virtual void UnzipEvent( ::TObject* tree, ::Long64_t pos, ::Double_t start,\n"
   "                               ::Int_t complen, ::Int_t objlen );\n"
   "#endif // ROOT 6\n"
   "      virtual void RateEvent( ::Double_t proctime, ::Double_t deltatime,\n"
   "                              ::Long64_t eventsprocessed, ::Long64_t bytesRead );\n"
   "      virtual void SetBytesRead( ::Long64_t num );\n"
   "      virtual ::Long64_t GetBytesRead() const;\n"
   "      virtual void SetNumEvents( ::Long64_t num );\n"
   "      virtual ::Long64_t GetNumEvents() const;\n\n"
   "   protected:\n"
   "      /// The constructor is protected, as it's a singleton\n"
   "      D3PDPerfStats();\n\n"
   "   private:\n"
   "      /// The single instance of the object\n"
   "      static D3PDPerfStats* fInstance;\n\n"
   "      /// Another performance monitoring object\n"
   "      ::TVirtualPerfStats* fOtherPerfStats;\n\n"
   "      /// Flag showing whether the statistic collection is ongoing or not\n"
   "      ::Bool_t fRunning;\n"
   "      /// Time when the statistics collection was started\n"
   "      ::Double_t fStartTime;\n\n"
   "      /// The tree we're currently investigating\n"
   "      ::TTree* fTree;\n"
   "      /// The currently open D3PD file\n"
   "      ::TFile* fFile;\n\n"
   "      /// Flag showing whether some information message has already been printed\n"
   "      ::Bool_t fTreeWarningPrinted;\n\n"
   "      /// Internal object for keeping track of the collected statistics\n"
   "      D3PDReadStats fStats;\n\n"
   "      ClassDef( D3PDPerfStats, 0 )\n\n"
   "   }; // class D3PDPerfStats\n\n"
   "} // namespace D3PDReader\n\n"
   "#endif // D3PDREADER_D3PDPERFSTATS_H";

static const char* D3PDPERFSTATS_CXX_NAME = "D3PDPerfStats.cxx";
static const char* D3PDPERFSTATS_CXX =
   "// $Id: CodeGenerator_v2_constants.h 600807 2014-06-08 15:26:51Z krasznaa $\n\n"
   "// ROOT include(s):\n"
   "#include <TTree.h>\n"
   "#include <TChain.h>\n"
   "#include <TTimeStamp.h>\n\n"
   "// Local include(s):\n"
   "#include \"D3PDPerfStats.h\"\n"
   "#include \"Utils.h\"\n\n"
   "ClassImp( D3PDReader::D3PDPerfStats )\n\n"
   "namespace D3PDReader {\n\n"
   "   // Initialize the static variable(s):\n"
   "   D3PDPerfStats* D3PDPerfStats::fInstance = 0;\n\n"
   "   /**\n"
   "    * The destructor is a quite important function in this class.\n"
   "    * it makes sure that the static fInstance variable gets reset,\n"
   "    * and that all TVirtualPerfStats objects really get deleted.\n"
   "    */\n"
   "   D3PDPerfStats::~D3PDPerfStats() {\n\n"
   "      // Since this object can only be deleted by deleting the global\n"
   "      // gPerfStats object, make sure that all the objects get deleted\n"
   "      // if the user asked for it...\n"
   "      fInstance = 0;\n"
   "      if( fOtherPerfStats ) {\n"
   "         delete fOtherPerfStats;\n"
   "      }\n"
   "   }\n\n"
   "   /**\n"
   "    * Everywhere in the code this function should be used to access\n"
   "    * the one and only D3PDPerfStats object in memory.\n"
   "    *\n"
   "    * @returns A pointer to the D3PDPerfStats singleton\n"
   "    */\n"
   "   D3PDPerfStats* D3PDPerfStats::Instance() {\n\n"
   "      // Construct the object if it is now available at the moment:\n"
   "      if( ! fInstance ) {\n"
   "         fInstance = new D3PDPerfStats();\n"
   "      }\n\n"
   "      // Make sure that this is still the object that receives\n"
   "      // monitoring information:\n"
   "      gPerfStats = fInstance;\n\n"
   "      return fInstance;\n"
   "   }\n\n"
   "   const D3PDReadStats& D3PDPerfStats::GetStats() const {\n\n"
   "      return fStats;\n"
   "   }\n\n"
   "   /**\n"
   "    * This function is called from VarHanle::UpdateStat(...) when a new TTree\n"
   "    * is given to the object. This way the variables get set a bit too many\n"
   "    * times, but hopefully it's not too much of a performance problem.\n"
   "    *\n"
   "    * @param tree The TTree that's going to be used for reading\n"
   "    */\n"
   "   void D3PDPerfStats::NewTreeAccessed( ::TTree* tree ) {\n\n"
   "      // Check if information extracted previously is the same\n"
   "      // as what we see in this TTree:\n"
   "      if( fStats.GetVariableNum() &&\n"
   "          ( fStats.GetVariableNum() != tree->GetNbranches() ) &&\n"
   "          ( ! fTreeWarningPrinted ) ) {\n"
   "         Info( \"NewTreeAccessed\", \"Reading trees with varying sizes\" );\n"
   "         Info( \"NewTreeAccessed\", \"Information about number of branches\"\n"
   "               \" won't be reliable\" );\n"
   "         fTreeWarningPrinted = kTRUE;\n"
   "      }\n\n"
   "      // Check if the cache size has changed. This can happen when\n"
   "      // caching is not configured explicitly:\n"
   "      if( fStats.GetCacheSize() &&\n"
   "          ( fStats.GetCacheSize() != tree->GetCacheSize() ) ) {\n"
   "         Info( \"NewTreeAccessed\", \"TTreeCache size changed. Old: %s, New: %s\",\n"
   "               SizeToString( fStats.GetCacheSize() ).Data(),\n"
   "               SizeToString( tree->GetCacheSize() ).Data() );\n"
   "      }\n\n"
   "      // Extract some information about the TTree:\n"
   "      if( tree->GetNbranches() > fStats.GetVariableNum() ) {\n"
   "         fStats.SetVariableNum( tree->GetNbranches() );\n"
   "      }\n"
   "      fStats.SetCacheSize( tree->GetCacheSize() );\n\n"
   "      // Cache some information:\n"
   "      fTree = tree;\n"
   "      ::TChain* chain = dynamic_cast< ::TChain* >( tree );\n"
   "      if( chain ) {\n"
   "         fFile = chain->GetFile();\n"
   "      } else {\n"
   "         fFile = tree->GetCurrentFile();\n"
   "      }\n\n"
   "      return;\n"
   "   }\n\n"
   "   /**\n"
   "    * The user is supposed to call this function after the initialization of his/her\n"
   "    * analysis code finished, but before the event processing starts.\n"
   "    *\n"
   "    * @param clear Clear the statistics gathered so far\n"
   "    */\n"
   "   void D3PDPerfStats::Start( ::Bool_t clear ) {\n\n"
   "      // Return right away if we are running already:\n"
   "      if( fRunning ) return;\n\n"
   "      // Clear the statistics collected so far if required:\n"
   "      if( clear ) fStats.Clear();\n\n"
   "      // Let the user know what we're doing:\n"
   "      Info( \"Start\", \"Starting performance monitoring\" );\n\n"
   "      // Record the starting time:\n"
   "      fStartTime = TTimeStamp();\n"
   "      // Remember that we are running:\n"
   "      fRunning = kTRUE;\n\n"
   "      return;\n"
   "   }\n\n"
   "   /**\n"
   "    * The user is supposed to call this function once his/her analysis code finished\n"
   "    * with the event processing.\n"
   "    */\n"
   "   void D3PDPerfStats::Stop() {\n\n"
   "      // Return right away if we are not running:\n"
   "      if( ! fRunning ) return;\n\n"
   "      // Calculate the time elapsed from when the analysis started:\n"
   "      const ::Double_t elapsed = TTimeStamp().AsDouble() -\n"
   "         fStartTime;\n"
   "      // Save it:\n"
   "      fStats.SetProcessTime( fStats.GetProcessTime() + elapsed );\n"
   "      // Remember that we are stopped:\n"
   "      fRunning = kFALSE;\n\n"
   "      // Let the user know what we've done:\n"
   "      Info( \"Stop\", \"Performance monitoring stopped after %s\",\n"
   "            TimeToString( elapsed ).Data() );\n\n"
   "      return;\n"
   "   }\n\n"
   "   void D3PDPerfStats::SimpleEvent( EEventType type ) {\n\n"
   "      // Forward the call if possible:\n"
   "      if( fOtherPerfStats ) {\n"
   "         fOtherPerfStats->SimpleEvent( type );\n"
   "      }\n\n"
   "      return;\n"
   "   }\n\n"
   "   void D3PDPerfStats::PacketEvent( const char* slave, const char* slavename,\n"
   "                                    const char* filename,\n"
   "                                    ::Long64_t eventsprocessed, ::Double_t latency,\n"
   "                                    ::Double_t proctime, ::Double_t cputime,\n"
   "                                    ::Long64_t bytesRead ) {\n\n"
   "      // Forward the call if possible:\n"
   "      if( fOtherPerfStats ) {\n"
   "         fOtherPerfStats->PacketEvent( slave, slavename, filename, eventsprocessed,\n"
   "                                       latency, proctime, cputime, bytesRead );\n"
   "      }\n\n"
   "      return;\n"
   "   }\n\n"
   "   void D3PDPerfStats::FileEvent( const char* slave, const char* slavename,\n"
   "                                  const char* nodename, const char* filename,\n"
   "                                  ::Bool_t isStart ) {\n\n"
   "      // Forward the call if possible:\n"
   "      if( fOtherPerfStats ) {\n"
   "         fOtherPerfStats->FileEvent( slave, slavename, nodename, filename, isStart );\n"
   "      }\n\n"
   "      return;\n"
   "   }\n\n"
   "   void D3PDPerfStats::FileOpenEvent( ::TFile* file, const char* filename,\n"
   "                                      ::Double_t start ) {\n\n"
   "      // Forward the call if possible:\n"
   "      if( fOtherPerfStats ) {\n"
   "         fOtherPerfStats->FileOpenEvent( file, filename, start );\n"
   "      }\n\n"
   "      return;\n"
   "   }\n\n"
   "   void D3PDPerfStats::FileReadEvent( ::TFile* file, ::Int_t len, ::Double_t start ) {\n\n"
   "      // Do nothing if we're not running:\n"
   "      if( ( ! fRunning ) || ( file != fFile ) ) return;\n\n"
   "      // Accumulate the amount of read data:\n"
   "      fStats.SetBytesRead( fStats.GetBytesRead() + len );\n"
   "      fStats.SetFileReads( fStats.GetFileReads() + 1 );\n\n"
   "      // Forward the call if possible:\n"
   "      if( fOtherPerfStats ) {\n"
   "         fOtherPerfStats->FileReadEvent( file, len, start );\n"
   "      }\n\n"
   "      return;\n"
   "   }\n\n"
   "#if ROOT_VERSION_CODE < ROOT_VERSION( 5, 99, 0 )\n"
   "   void D3PDPerfStats::FileUnzipEvent( ::TFile* file, ::Long64_t pos, ::Double_t start,\n"
   "                                       ::Int_t complen, ::Int_t objlen ) {\n\n"
   "      // Do the calculation without delay:\n"
   "      const ::Double_t tnow = TTimeStamp();\n"
   "      const ::Double_t dtime = tnow - start;\n\n"
   "      // Do nothing if we're not running:\n"
   "      if( ( ! fRunning ) || ( file != fFile ) ) return;\n\n"
   "      // Just accumulate the zipping time statistics:\n"
   "      fStats.SetUnzipTime( fStats.GetUnzipTime() + dtime );\n\n"
   "      // This function was only added in a 5.28 patch...\n"
   "#if ROOT_VERSION_CODE > ROOT_VERSION( 5, 28, 0 )\n"
   "      // Forward the call if possible:\n"
   "      if( fOtherPerfStats ) {\n"
   "         fOtherPerfStats->FileUnzipEvent( file, pos, start, complen, objlen );\n"
   "      }\n"
   "#endif // ROOT_VERSION...\n\n"
   "      return;\n"
   "   }\n"
   "#else\n"
   "   void D3PDPerfStats::UnzipEvent( ::TObject*, ::Long64_t, ::Double_t, ::Int_t,\n"
   "                                   ::Int_t ) {\n\n"
   "      return;\n"
   "   }\n"
   "#endif // ROOT 6\n\n"
   "   void D3PDPerfStats::RateEvent( ::Double_t proctime, ::Double_t deltatime,\n"
   "                                  ::Long64_t eventsprocessed, ::Long64_t bytesRead ) {\n\n"
   "      // Forward the call if possible:\n"
   "      if( fOtherPerfStats ) {\n"
   "         fOtherPerfStats->RateEvent( proctime, deltatime, eventsprocessed, bytesRead );\n"
   "      }\n\n"
   "      return;\n"
   "   }\n\n"
   "   /**\n"
   "    * In single process running this function is basically never called.\n"
   "    * It's only active when running on PROOF, in which case we should not\n"
   "    * care about the values given to it, but just forward it to\n"
   "    * TPerfStats. The actual amount of data read for D3PD monitoring\n"
   "    * is coming in through the FileReadEvent(...) function...\n"
   "    *\n"
   "    * @param num Number of bytes read in \"some operation\"\n"
   "    */\n"
   "   void D3PDPerfStats::SetBytesRead( ::Long64_t num ) {\n\n"
   "      // Forward the call if possible:\n"
   "      if( fOtherPerfStats ) {\n"
   "         fOtherPerfStats->SetBytesRead( num );\n"
   "      }\n\n"
   "      return;\n"
   "   }\n\n"
   "   ::Long64_t D3PDPerfStats::GetBytesRead() const {\n\n"
   "      // Forward the call if possible:\n"
   "      if( fOtherPerfStats ) {\n"
   "         return fOtherPerfStats->GetBytesRead();\n"
   "      } else {\n"
   "         return fStats.GetBytesRead();\n"
   "      }\n"
   "   }\n\n"
   "   /**\n"
   "    * This function is not called with anything meaningful in standalone\n"
   "    * ROOT analyses, so it just forwards the call to a possible other\n"
   "    * TVirtualPerfStats object.\n"
   "    *\n"
   "    * @param num Number of events\n"
   "    */\n"
   "   void D3PDPerfStats::SetNumEvents( ::Long64_t num ) {\n\n"
   "      // Forward the call if possible:\n"
   "      if( fOtherPerfStats ) {\n"
   "         fOtherPerfStats->SetNumEvents( num );\n"
   "      }\n\n"
   "      return;\n"
   "   }\n\n"
   "   /**\n"
   "    * The function just gets the number of events from the other\n"
   "    * TVirtualPerfStats object if it exists, otherwise it just returns\n"
   "    * zero.\n"
   "    *\n"
   "    * @returns The number of events\n"
   "    */\n"
   "   ::Long64_t D3PDPerfStats::GetNumEvents() const {\n\n"
   "      // Forward the call if possible:\n"
   "      if( fOtherPerfStats ) {\n"
   "         return fOtherPerfStats->GetNumEvents();\n"
   "      }\n\n"
   "      return 0;\n"
   "   }\n\n"
   "   /**\n"
   "    * The constructor needs to do a few things. If there is already\n"
   "    * another TVirtualPerfStats object defined under gPerfStats, then\n"
   "    * it stores that pointer in order to be able to forward monitoring\n"
   "    * information to that object later on. It then overwrites\n"
   "    * gPerfStats to point to this object.\n"
   "    */\n"
   "   D3PDPerfStats::D3PDPerfStats()\n"
   "      : fOtherPerfStats( 0 ), fRunning( kFALSE ), fStartTime( 0.0 ),\n"
   "        fTree( 0 ), fFile( 0 ), fTreeWarningPrinted( kFALSE ),\n"
   "        fStats( \"D3PDReadStats\", \"D3PD reading statistics\" ) {\n\n"
   "      // Remember a possible former performance monitoring object:\n"
   "      if( gPerfStats && ( gPerfStats != this ) ) {\n"
   "         fOtherPerfStats = gPerfStats;\n"
   "         Info( \"D3PDPerfStats\",\n"
   "               \"Will forward calls to former gPerfStats object\" );\n"
   "      }\n\n"
   "      // This object is now the performance monitoring object:\n"
   "      gPerfStats = this;\n"
   "   }\n\n"
   "} // namespace D3PDReader";

static const char* UTILS_HEADER_NAME = "Utils.h";
static const char* UTILS_HEADER =
   "// Dear emacs, this is -*- c++ -*-\n"
   "// $Id: CodeGenerator_v2_constants.h 600807 2014-06-08 15:26:51Z krasznaa $\n"
   "#ifndef D3PDREADER_UTILS_H\n"
   "#define D3PDREADER_UTILS_H\n\n"
   "// ROOT include(s):\n"
   "#include <TString.h>\n\n"
   "namespace D3PDReader {\n\n"
   "   /// Function creating a human-readable elapsed time printout\n"
   "   ::TString TimeToString( ::Double_t secs );\n\n"
   "   /// Function for printing data sizes in human-readable format\n"
   "   ::TString SizeToString( ::Long64_t bytes );\n\n"
   "   /// Function for printing data processing speeds in a human-readable format\n"
   "   ::TString SpeedToString( ::Double_t bytespersec );\n\n"
   "} // namespace D3PDReader\n\n"
   "#endif // D3PDREADER_UTILS_H";

static const char* UTILS_CXX_NAME = "Utils.cxx";
static const char* UTILS_CXX =
   "// $Id: CodeGenerator_v2_constants.h 600807 2014-06-08 15:26:51Z krasznaa $\n\n"
   "// STL include(s):\n"
   "#include <cmath>\n\n"
   "// Local include(s):\n"
   "#include \"Utils.h\"\n\n"
   "namespace {\n\n"
   "   /**\n"
   "    *  @short Simple structure describing an elapsed amount of time\n"
   "    *\n"
   "    *         In order to print some elapsed times in a nice way, the\n"
   "    *         private functions of this source file use this structure.\n"
   "    *\n"
   "    *         The amount of times measured by the code should be\n"
   "    *         representable by this structure. (We shouldn't care about\n"
   "    *         sub-milisecond times, or longer running periods than a\n"
   "    *         few days...)\n"
   "    *\n"
   "    * @author Attila Krasznahorkay <Attila.Krasznahorkay@cern.ch>\n"
   "    *\n"
   "    * $Revision: 600807 $\n"
   "    * $Date: 2014-06-08 17:26:51 +0200 (Sun, 08 Jun 2014) $\n"
   "    */\n"
   "   struct TimeStruct {\n"
   "      ::Int_t miliseconds; ///< Elapsed milisecods\n"
   "      ::Int_t seconds; ///< Elapsed seconds\n"
   "      ::Int_t minutes; ///< Elapsed minutes\n"
   "      ::Int_t hours; ///< Elapsed hours\n"
   "      ::Int_t days; ///< Elapsed days\n"
   "   }; // struct TimeStruct\n\n"
   "   /// Function creating a time structure\n"
   "   /**\n"
   "    * This function is used to break down a simple elapsed time expressed in\n"
   "    * seconds into an easy-to-print structure. Shame that I couldn't find something\n"
   "    * in standard C/C++ to do it...\n"
   "    *\n"
   "    * @param secs The elapsed time expressed in seconds\n"
   "    * @returns A structure describing the elapsed time\n"
   "    */\n"
   "   TimeStruct TimeToStruct( ::Double_t secs ) {\n\n"
   "      // Create the structure, fill its miliseconds variable,\n"
   "      // and reset all the rest:\n"
   "      TimeStruct result;\n"
   "      result.miliseconds =\n"
   "         static_cast< ::Int_t >( std::fmod( secs, 1.0 ) * 1000.0 );\n"
   "      result.seconds = 0; result.minutes = 0; result.hours = 0;\n"
   "      result.days = 0;\n\n"
   "      // If the elapsed time was less than a second, finish here:\n"
   "      secs -= ( result.miliseconds / 1000.0 );\n"
   "      if( std::abs( secs ) < 0.5 ) return result;\n\n"
   "      // Calculate the number of seconds passed, and finish if the\n"
   "      // amount of time passed was less than a minute:\n"
   "      result.seconds =\n"
   "         static_cast< ::Int_t >( std::fmod( secs, 60.0 ) );\n"
   "      secs -= result.seconds;\n"
   "      if( std::abs( secs ) < 0.5 ) return result;\n\n"
   "      // Calculate the number of minutes passed, and finish if the\n"
   "      // amount of time passed was less than an hour:\n"
   "      result.minutes =\n"
   "         static_cast< ::Int_t >( std::fmod( secs, 3600.0 ) / 60.0 );\n"
   "      secs -= result.minutes * 60.0;\n"
   "      if( std::abs( secs ) < 0.5 ) return result;\n\n"
   "      // Calculate the number of hours passed, and finish if the\n"
   "      // amount of time passed was less than a day:\n"
   "      result.hours =\n"
   "         static_cast< ::Int_t >( std::fmod( secs, 86400.0 ) / 3600.0 );\n"
   "      secs -= result.hours * 3600.0;\n"
   "      if( std::abs( secs ) < 0.5 ) return result;\n\n"
   "      // Calculate the number of days passed. The function should\n"
   "      // not expect to have to express a larger order of magnitude...\n"
   "      result.days = static_cast< ::Int_t >( secs / 86400.0 );\n\n"
   "      return result;\n"
   "   }\n\n"
   "} // private namespace\n\n"
   "namespace D3PDReader {\n\n"
   "   /**\n"
   "    * Since I wasn't able to find a nice function printing elapsed times\n"
   "    * in a human-readable format, I ended up writing one. This function\n"
   "    * is used in printing the statistics about an analysis.\n"
   "    *\n"
   "    * @param secs An amount of time passed, expressed in seconds\n"
   "    * @returns A formatted, human-readable version of the amount of time passed\n"
   "    */\n"
   "   ::TString TimeToString( ::Double_t secs ) {\n\n"
   "      const TimeStruct ts = TimeToStruct( secs );\n"
   "      ::TString result;\n"
   "      if( ts.days ) {\n"
   "         result += ::TString::Format( \"%id \", ts.days );\n"
   "      }\n"
   "      if( ts.hours ) {\n"
   "         result += ::TString::Format( \"%ih \", ts.hours );\n"
   "      }\n"
   "      if( ts.minutes ) {\n"
   "         result += ::TString::Format( \"%im \", ts.minutes );\n"
   "      }\n"
   "      if( ts.seconds ) {\n"
   "         result += ::TString::Format( \"%is \", ts.seconds );\n"
   "      }\n"
   "      result += ::TString::Format( \"%ims\", ts.miliseconds );\n\n"
   "      return result;\n"
   "   }\n\n"
   "   /**\n"
   "    * This function is used to produce nicely readable printouts for\n"
   "    * amounts of data.\n"
   "    *\n"
   "    * @param bytes The amount of data expressed in bytes\n"
   "    * @returns A human-readable printout of the data size\n"
   "    */\n"
   "   ::TString SizeToString( ::Long64_t bytes ) {\n\n"
   "      if( ::fabs( bytes ) > 1e12 ) {\n"
   "         return ::TString::Format( \"%g TB\", bytes * 1e-12 );\n"
   "      } else if( ::fabs( bytes ) > 1e9 ) {\n"
   "         return ::TString::Format( \"%g GB\", bytes * 1e-9 );\n"
   "      } else if( ::fabs( bytes ) > 1e6 ) {\n"
   "         return ::TString::Format( \"%g MB\", bytes * 1e-6 );\n"
   "      } else if( ::fabs( bytes ) > 1e3 ) {\n"
   "         return ::TString::Format( \"%g kB\", bytes * 1e-3 );\n"
   "      } else {\n"
   "         return ::TString::Format( \"%lli bytes\", bytes );\n"
   "      }\n"
   "   }\n\n"
   "   /**\n"
   "    * @param bytespersec The speed expressed in bytes / seconds\n"
   "    * @returns A human-readable printout of the data processing speed\n"
   "    */\n"
   "   ::TString SpeedToString( ::Double_t bytespersec ) {\n\n"
   "      if( ::fabs( bytespersec ) > 1e12 ) {\n"
   "         return ::TString::Format( \"%g TB/s\", bytespersec * 1e-12 );\n"
   "      } else if( ::fabs( bytespersec ) > 1e9 ) {\n"
   "         return ::TString::Format( \"%g GB/s\", bytespersec * 1e-9 );\n"
   "      } else if( ::fabs( bytespersec ) > 1e6 ) {\n"
   "         return ::TString::Format( \"%g MB/s\", bytespersec * 1e-6 );\n"
   "      } else if( ::fabs( bytespersec ) > 1e3 ) {\n"
   "         return ::TString::Format( \"%g kB/s\", bytespersec * 1e-3 );\n"
   "      } else {\n"
   "         return ::TString::Format( \"%g B/s\", bytespersec );\n"
   "      }\n"
   "   }\n\n"
   "} // namespace D3PDReader";

static const char* USERD3PDOBJECT_HEADER_NAME = "UserD3PDObject.h";
static const char* USERD3PDOBJECT_HEADER =
   "// Dear emacs, this is -*- c++ -*--\n"
   "// $Id: CodeGenerator_v2_constants.h 600807 2014-06-08 15:26:51Z krasznaa $\n"
   "#ifndef D3PDREADER_UserD3PDObject_H\n"
   "#define D3PDREADER_UserD3PDObject_H\n\n"
   "// STL include(s):\n"
   "#include <map>\n"
   "#include <vector>\n\n"
   "// ROOT include(s):\n"
   "#include <TNamed.h>\n"
   "#include <TString.h>\n\n"
   "// Local include(s):\n"
   "#include \"D3PDObjectBase.h\"\n"
   "#include \"D3PDReadStats.h\"\n"
   "#include \"VarHandle.h\"\n"
   "#include \"VarProxy.h\"\n\n"
   "// Forward declaration(s):\n"
   "class TTree;\n\n"
   "namespace D3PDReader {\n\n"
   "   // Forward declaration(s):\n"
   "   class UserD3PDObject;\n\n"
   "   /**\n"
   "    *  @short Special class for handling user variables\n"
   "    *\n"
   "    *         This proxy class can be used to handle user-defined vector\n"
   "    *         variables in a fancy way. It is also used by all of the regular\n"
   "    *         proxy classes as base class, so they could handle user defined\n"
   "    *         variables as well. (For instance for adding a new property to\n"
   "    *         electrons in the analysis.)\n"
   "    *\n"
   "    *         The class doesn't inherit from TObject on purpose, in order to\n"
   "    *         avoid ending up with a diamond in the inheritance structure.\n"
   "    *         (Python *really* doesn't like that...)\n"
   "    *\n"
   "    * @author Attila Krasznahorkay <Attila.Krasznahorkay@cern.ch>\n"
   "    *\n"
   "    * $Revision: 600807 $\n"
   "    * $Date: 2014-06-08 17:26:51 +0200 (Sun, 08 Jun 2014) $\n"
   "    */\n"
   "   class UserD3PDObjectElement : public ::TNamed {\n\n"
   "      friend class UserD3PDObject;\n\n"
   "   protected:\n"
   "      /// Constructor only visible to children and UserD3PDObject\n"
   "      UserD3PDObjectElement( size_t index, const UserD3PDObject& parent );\n\n"
   "   public:\n"
   "      /// Copy constructor\n"
   "      UserD3PDObjectElement( const UserD3PDObjectElement& parent );\n"
   "      /// Destructor, cleaning up the created objects\n"
   "      virtual ~UserD3PDObjectElement();\n\n"
   "      /// Index of the object inside its container\n"
   "      virtual size_t GetIndex() const;\n\n"
   "      /// Access a variable\n"
   "      template< typename T >\n"
   "      VarProxy< T >& Variable( const TString& name );\n"
   "      /// Access a variable (constant version)\n"
   "      template< typename T >\n"
   "      const VarProxy< T >& Variable( const TString& name ) const;\n\n"
   "   private:\n"
   "      /// Reference to the parent of this object\n"
   "      const UserD3PDObject* fParent;\n"
   "      /// The index of this object inside the parent container\n"
   "      size_t fIndex;\n"
   "      /// Book-keeper of the VarProxy members\n"
   "      mutable std::map< ::TString, VarProxyBase* > fProxies;\n\n"
   "      ClassDef( UserD3PDObjectElement, 0 )\n\n"
   "   }; // class UserD3PDObjectElement\n\n"
   "   /**\n"
   "    *  @short Special class for handling user variables\n"
   "    *\n"
   "    *         This class is used to handle user defined variables. It can be\n"
   "    *         used on its own to read/write any sort of variable, but it also\n"
   "    *         acts as a base class for all the other D3PDObject classes, to\n"
   "    *         make it possible to decorate the information stored by them.\n"
   "    *\n"
   "    *         While the class fully implements the D3PDObjectBase interface,\n"
   "    *         it doesn't inherit from it, in order to avoid creating a diamond\n"
   "    *         in the inheritance structure. Python is not able to handle such\n"
   "    *         an inheritance structure correctly.\n"
   "    *\n"
   "    * @author Attila Krasznahorkay <Attila.Krasznahorkay@cern.ch>\n"
   "    *\n"
   "    * $Revision: 600807 $\n"
   "    * $Date: 2014-06-08 17:26:51 +0200 (Sun, 08 Jun 2014) $\n"
   "    */\n"
   "   class UserD3PDObject : public D3PDObjectBase {\n\n"
   "   public:\n"
   "      /// Constructor used when reading from a TTree\n"
   "      UserD3PDObject( const ::Long64_t& master, const char* prefix = \"\" );\n"
   "      /// Constructor when the object is only used for writing data out\n"
   "      UserD3PDObject( const char* prefix = \"\" );\n"
   "      /// Destructor, cleaning up the created objects\n"
   "      virtual ~UserD3PDObject();\n\n"
   "      /// Get the currently configured prefix value\n"
   "      virtual const char* GetPrefix() const;\n"
   "      /// Set the prefix for the variables\n"
   "      virtual void SetPrefix( const char* prefix );\n\n"
   "      /// Connect the object to an input TTree\n"
   "      virtual void ReadFrom( ::TTree* tree );\n"
   "      /// Connect the object to an output TTree\n"
   "      virtual void WriteTo( ::TTree* tree );\n\n"
   "      /// Turn (selected) branches either on or off\n"
   "      virtual void SetActive( ::Bool_t active = kTRUE,\n"
   "                              const ::TString& pattern = \".*\" );\n"
   "      /// Read in all the variables that we need to write out as well\n"
   "      virtual void ReadAllActive();\n\n"
   "      /// Get the D3PD reading statistics\n"
   "      virtual D3PDReadStats GetStatistics() const;\n\n"
   "      /// Set the contents of the object according to another object\n"
   "      UserD3PDObject& Set( const UserD3PDObject& parent );\n\n"
   "      /// Clear the container. Useful when writing new branches.\n"
   "      void Clear( Option_t* option = \"\" );\n"
   "      /// Add one element to an output collection\n"
   "      UserD3PDObject& Add( const UserD3PDObjectElement& el );\n\n"
   "      /// Access a proxy class describing one element of the container\n"
   "      UserD3PDObjectElement& operator[]( size_t index );\n"
   "      /// Access a proxy class describing one element of the container (constant version)\n"
   "      const UserD3PDObjectElement& operator[]( size_t index ) const;\n"
   "      /// Add one element to an output collection\n"
   "      UserD3PDObject& operator+=( const UserD3PDObjectElement& el );\n\n"
   "      /// Declare a new variable for writing\n"
   "      template< typename T >\n"
   "      void DeclareVariable( const TString& name );\n"
   "      /// Access a variable\n"
   "      template< typename T >\n"
   "      VarHandle< T >& Variable( const TString& name );\n"
   "      /// Access a variable (constant version)\n"
   "      template< typename T >\n"
   "      const VarHandle< T >& Variable( const TString& name ) const;\n\n"
   "   private:\n"
   "      const ::Long64_t* fMaster; ///< Pointer to the master entry number\n"
   "      ::TString fPrefix; ///< Prefix to the branch names\n"
   "      ///< Internal list of proxy objects\n"
   "      mutable std::vector< UserD3PDObjectElement* > fProxies;\n"
   "      /// Book-keeper of the VarHandle members\n"
   "      mutable std::map< ::TString, VarHandleBase* > fHandles;\n"
   "      /// Book-keeper of VarHandle objects needed for technical reasons\n"
   "      mutable std::vector< VarHandleBase* > fExtraHandles;\n"
   "      /// Flag specifying if object is used for D3PD reading\n"
   "      const ::Bool_t fFromInput;\n"
   "      /// TTree that is being read currently\n"
   "      ::TTree* fInTree;\n\n"
   "      ClassDef( UserD3PDObject, 0 )\n\n"
   "   }; // class UserD3PDObject\n\n"
   "} // namespace D3PDReader\n\n"
   "// Include the template implementation:\n"
   "#ifndef __CINT__\n"
   "#include \"UserD3PDObject.icc\"\n"
   "#endif // __CINT__\n\n"
   "#endif // D3PDREADER_UserD3PDObject_H";

static const char* USERD3PDOBJECT_IMPL_NAME = "UserD3PDObject.icc";
static const char* USERD3PDOBJECT_IMPL =
   "// Dear emacs, this is -*- c++ -*-\n"
   "// $Id: CodeGenerator_v2_constants.h 600807 2014-06-08 15:26:51Z krasznaa $\n"
   "#ifndef D3PDREADER_UserD3PDObject_ICC\n"
   "#define D3PDREADER_UserD3PDObject_ICC\n\n"
   "namespace D3PDReader {\n\n"
   "   /**\n"
   "    * This function accesses a user-defined variable for modification.\n"
   "    * The template type needs to follow the type of the underlying\n"
   "    * TTree branch's type, without the outermost vector. So for instance\n"
   "    * to access a <code>std::vector<float></code> variable from here, you\n"
   "    * need to call the function with a <code>float</code> template argument.\n"
   "    *\n"
   "    * The function also takes care of extending the underlying vector variable\n"
   "    * to the needed size. This makes the decoration of existing objects in\n"
   "    * a container with new variables much easier.\n"
   "    *\n"
   "    * If you're decorating elements that you are reading from an input D3PD,\n"
   "    * you must have already called <code>DeclareVariable(...)</code> on the\n"
   "    * parent object before calling thig function.\n"
   "    *\n"
   "    * @param name The name of the user variable\n"
   "    * @returns The VarProxy object handling the requested variable\n"
   "    */\n"
   "   template< typename T >\n"
   "   VarProxy< T >& UserD3PDObjectElement::Variable( const TString& name ) {\n\n"
   "      // Try to find the variable:\n"
   "      std::map< ::TString, VarProxyBase* >::const_iterator itr =\n"
   "         fProxies.find( name );\n"
   "      if( itr != fProxies.end() ) {\n"
   "         // If it's already known, let's see if it's the right type:\n"
   "         VarProxy< T >* result =\n"
   "            dynamic_cast< VarProxy< T >* >( itr->second );\n"
   "         if( ! result ) {\n"
   "            // Create a dummy object. The code will crash soon\n"
   "            // anyway...\n"
   "            VarProxy< T >* dummy =\n"
   "               new VarProxy< T >( fParent->Variable< std::vector< T >* >( name ),\n"
   "                                  fIndex );\n"
   "            fProxies[ name ] = dummy;\n"
   "            // Tell the user what happened:\n"
   "            Error( \"Variable\",\n"
   "                   \"Variable with name '%s' requested with wrong type\",\n"
   "                   name.Data() );\n"
   "            return *dummy;\n"
   "         }\n"
   "         // Check if the underlying vector is large enough:\n"
   "         const VarHandle< std::vector< T >* >& vh = \n"
   "            fParent->Variable< std::vector< T >* >( name );\n"
   "         if( vh.IsAvailable() && ( ! vh.GetMaster() ) &&\n"
   "             ( vh()->size() <= fIndex ) ) {\n"
   "            UserD3PDObject* ncparent = const_cast< UserD3PDObject* >( fParent );\n"
   "            ncparent->Variable< std::vector< T >* >( name )()->resize( fIndex + 1 );\n"
   "         }\n"
   "         // Return the proxy:\n"
   "         return *result;\n"
   "      }\n\n"
   "      // Add the new proxy variable:\n"
   "      VarProxy< T >* result =\n"
   "         new VarProxy< T >( fParent->Variable< std::vector< T >* >( name ),\n"
   "                            fIndex );\n"
   "      fProxies[ name ] = result;\n\n"
   "      // Check if the underlying vector is large enough:\n"
   "      const VarHandle< std::vector< T >* >& vh = \n"
   "         fParent->Variable< std::vector< T >* >( name );\n"
   "      if( vh.IsAvailable() && ( ! vh.GetMaster() ) &&\n"
   "          ( vh()->size() <= fIndex ) ) {\n"
   "         UserD3PDObject* ncparent = const_cast< UserD3PDObject* >( fParent );\n"
   "         ncparent->Variable< std::vector< T >* >( name )()->resize( fIndex + 1 );\n"
   "      }\n\n"
   "      // Return the proxy:\n"
   "      return *result;\n"
   "   }\n\n"
   "   /**\n"
   "    * This function accesses a user-defined variable for reading.\n"
   "    * The template type needs to follow the type of the underlying\n"
   "    * TTree branch's type, without the outermost vector. So for instance\n"
   "    * to access a <code>std::vector<float></code> variable from here, you\n"
   "    * need to call the function with a <code>float</code> template argument.\n"
   "    *\n"
   "    * If you're decorating elements that you are reading from an input D3PD,\n"
   "    * you must have already called <code>DeclareVariable(...)</code> on the\n"
   "    * parent object before calling thig function.\n"
   "    *\n"
   "    * @param name The name of the user variable\n"
   "    * @returns The VarProxy object handling the requested variable\n"
   "    */\n"
   "   template< typename T >\n"
   "   const VarProxy< T >& UserD3PDObjectElement::Variable( const TString& name ) const {\n\n"
   "      // Try to find the variable:\n"
   "      std::map< ::TString, VarProxyBase* >::const_iterator itr =\n"
   "         fProxies.find( name );\n"
   "      if( itr != fProxies.end() ) {\n"
   "         // If it's already known, let's see if it's the right type:\n"
   "         VarProxy< T >* result =\n"
   "            dynamic_cast< VarProxy< T >* >( itr->second );\n"
   "         if( ! result ) {\n"
   "            // Create a dummy object. The code will crash soon\n"
   "            // anyway...\n"
   "            VarProxy< T >* dummy =\n"
   "               new VarProxy< T >( fParent->Variable< std::vector< T >* >( name ),\n"
   "                                  fIndex );\n"
   "            fProxies[ name ] = dummy;\n"
   "            // Tell the user what happened:\n"
   "            Error( \"Variable\",\n"
   "                   \"Variable with name '%s' requested with wrong type\",\n"
   "                   name.Data() );\n"
   "            return *dummy;\n"
   "         }\n"
   "         // Return the proxy:\n"
   "         return *result;\n"
   "      }\n\n"
   "      // Add the new proxy variable:\n"
   "      VarProxy< T >* result =\n"
   "         new VarProxy< T >( fParent->Variable< std::vector< T >* >( name ),\n"
   "                            fIndex );\n"
   "      fProxies[ name ] = result;\n\n"
   "      // Return the proxy:\n"
   "      return *result;\n"
   "   }\n\n"
   "   /**\n"
   "    * This function can be used to add a new variable to an output D3PD.\n"
   "    * When reading an input D3PD that the user wants to write out a part of,\n"
   "    * extended with some additional variables, this function should be used.\n"
   "    *\n"
   "    * @param name The name of the new variable to create\n"
   "    */\n"
   "   template< typename T >\n"
   "   void UserD3PDObject::DeclareVariable( const TString& name ) {\n\n"
   "      // Check if the variable with this name is already in place:\n"
   "      std::map< ::TString, VarHandleBase* >::const_iterator itr =\n"
   "         fHandles.find( name );\n"
   "      if( itr != fHandles.end() ) {\n"
   "         Warning( \"DeclareVariable\",\n"
   "                  \"Variable with name '%s' already declared\",\n"
   "                  ( fPrefix + name ).Data() );\n"
   "         return;\n"
   "      }\n\n"
   "      // Declare the new variable:\n"
   "      fHandles[ name ] = new VarHandle< T >( fPrefix + name, 0 );\n\n"
   "      return;\n"
   "   }\n\n"
   "   /**\n"
   "    * This function can be used to access a user-defined variable for\n"
   "    * modification. It should mostly be used when writing a D3PD with the\n"
   "    * additional user variable.\n"
   "    *\n"
   "    * @param name The name of the user-defined variable\n"
   "    * @returns The VarHandle object handling the user variable\n"
   "    */\n"
   "   template< typename T >\n"
   "   VarHandle< T >& UserD3PDObject::Variable( const TString& name ) {\n\n"
   "      // Try to find the variable:\n"
   "      std::map< ::TString, VarHandleBase* >::const_iterator itr =\n"
   "         fHandles.find( name );\n"
   "      if( itr != fHandles.end() ) {\n"
   "         // It's already known, so let's see if it's of the right type:\n"
   "         VarHandle< T >* result =\n"
   "            dynamic_cast< VarHandle< T >* >( itr->second );\n"
   "         if( ! result ) {\n"
   "            // Add a dummy object for technical reasons. The user code\n"
   "            // will anyway probably die after this.\n"
   "            VarHandle< T >* dummy = new VarHandle< T >();\n"
   "            fExtraHandles.push_back( dummy );\n"
   "            // Tell the user what happened:\n"
   "            Error( \"Variable\",\n"
   "                   \"Variable with name '%s' is of type '%s', \"\n"
   "                   \"not of type '%s'\",\n"
   "                   ( fPrefix + name ).Data(), itr->second->GetType(),\n"
   "                   dummy->GetType() );\n"
   "            // Return the dummy:\n"
   "            return *dummy;\n"
   "         }\n"
   "         // Return the object:\n"
   "         return *result;\n"
   "      }\n\n"
   "      // If it doesn't exist yet, let's add it:\n"
   "      VarHandle< T >* result = new VarHandle< T >( fPrefix + name, fMaster );\n"
   "      if( fInTree ) result->ReadFrom( fInTree );\n"
   "      fHandles[ name ] = result;\n"
   "      return *result;\n"
   "   }\n\n"
   "   /**\n"
   "    * This function can be used to access a user-defined variable for\n"
   "    * reading. It can be used both when reading or writing a D3PD.\n"
   "    *\n"
   "    * @param name The name of the user-defined variable\n"
   "    * @returns The VarHandle object handling the user variable\n"
   "    */\n"
   "   template< typename T >\n"
   "   const VarHandle< T >& UserD3PDObject::Variable( const TString& name ) const {\n\n"
   "      // Try to find the variable:\n"
   "      std::map< ::TString, VarHandleBase* >::const_iterator itr =\n"
   "         fHandles.find( name );\n"
   "      if( itr != fHandles.end() ) {\n"
   "         // It's already known, so let's see if it's of the right type:\n"
   "         VarHandle< T >* result =\n"
   "            dynamic_cast< VarHandle< T >* >( itr->second );\n"
   "         if( ! result ) {\n"
   "            // Add a dummy object for technical reasons. The user code\n"
   "            // will anyway probably die after this.\n"
   "            VarHandle< T >* dummy = new VarHandle< T >();\n"
   "            fExtraHandles.push_back( dummy );\n"
   "            // Tell the user what happened:\n"
   "            Error( \"Variable\",\n"
   "                   \"Variable with name '%s' is of type '%s', \"\n"
   "                   \"not of type '%s'\",\n"
   "                   ( fPrefix + name ).Data(), itr->second->GetType(),\n"
   "                   dummy->GetType() );\n"
   "            // Return the dummy:\n"
   "            return *dummy;\n"
   "         }\n"
   "         // Return the object:\n"
   "         return *result;\n"
   "      }\n\n"
   "      // If it doesn't exist yet, let's add it:\n"
   "      VarHandle< T >* result = new VarHandle< T >( fPrefix + name, fMaster );\n"
   "      if( fInTree ) result->ReadFrom( fInTree );\n"
   "      fHandles[ name ] = result;\n"
   "      return *result;\n"
   "   }\n\n"
   "} // namespace D3PDReader\n\n"
   "#endif // D3PDREADER_UserD3PDObject_ICC";

static const char* USERD3PDOBJECT_CXX_NAME = "UserD3PDObject.cxx";
static const char* USERD3PDOBJECT_CXX =
   "// $Id: CodeGenerator_v2_constants.h 600807 2014-06-08 15:26:51Z krasznaa $\n\n"
   "// ROOT include(s):\n"
   "#include <TPRegexp.h>\n\n"
   "// Local include(s):\n"
   "#include \"UserD3PDObject.h\"\n\n"
   "namespace D3PDReader {\n\n"
   "   UserD3PDObjectElement::UserD3PDObjectElement( size_t index,\n"
   "                                                 const UserD3PDObject& parent )\n"
   "      : ::TNamed(), fParent( &parent ), fIndex( index ), fProxies() {\n\n"
   "   }\n\n"
   "   UserD3PDObjectElement::\n"
   "   UserD3PDObjectElement( const UserD3PDObjectElement& parent )\n"
   "      : TNamed( parent ), fParent( parent.fParent ), fIndex( parent.fIndex ),\n"
   "        fProxies() {\n\n"
   "   }\n\n"
   "   UserD3PDObjectElement::~UserD3PDObjectElement() {\n\n"
   "      // Delete the allocated objects:\n"
   "      std::map< ::TString, VarProxyBase* >::iterator itr = fProxies.begin();\n"
   "      std::map< ::TString, VarProxyBase* >::iterator end = fProxies.end();\n"
   "      for( ; itr != end; ++itr ) {\n"
   "         delete itr->second;\n"
   "      }\n"
   "   }\n\n"
   "   size_t UserD3PDObjectElement::GetIndex() const {\n\n"
   "      return fIndex;\n"
   "   }\n\n"
   "   UserD3PDObject::UserD3PDObject( const ::Long64_t& master,\n"
   "                                   const char* prefix )\n"
   "      : D3PDObjectBase(), fMaster( &master ), fPrefix( prefix ), fProxies(),\n"
   "        fHandles(), fExtraHandles(), fFromInput( kTRUE ),\n"
   "        fInTree( 0 ) {\n\n"
   "   }\n\n"
   "   UserD3PDObject::UserD3PDObject( const char* prefix )\n"
   "      : D3PDObjectBase(), fMaster( 0 ), fPrefix( prefix ), fProxies(),\n"
   "        fHandles(), fExtraHandles(), fFromInput( kFALSE ),\n"
   "        fInTree( 0 ) {\n\n"
   "   }\n\n"
   "   UserD3PDObject::~UserD3PDObject() {\n\n"
   "      // Delete the allocated objects:\n"
   "      std::map< ::TString, VarHandleBase* >::iterator itr = fHandles.begin();\n"
   "      std::map< ::TString, VarHandleBase* >::iterator end = fHandles.end();\n"
   "      for( ; itr != end; ++itr ) {\n"
   "         delete itr->second;\n"
   "      }\n"
   "      // Although the code almost certainly crashes when such dummy objects\n"
   "      // are created, there's still some chance that they need to be cleaned:\n"
   "      std::vector< VarHandleBase* >::iterator eitr = fExtraHandles.begin();\n"
   "      std::vector< VarHandleBase* >::iterator eend = fExtraHandles.end();\n"
   "      for( ; eitr != eend; ++eitr ) {\n"
   "         delete *eitr;\n"
   "      }\n"
   "   }\n\n"
   "   /**\n"
   "    * @returns The branch name prefix used by the object\n"
   "    */\n"
   "   const char* UserD3PDObject::GetPrefix() const {\n\n"
   "      return fPrefix;\n"
   "   }\n\n"
   "   /**\n"
   "    * @param prefix The prefix that should be used for the variables\n"
   "    */\n"
   "   void UserD3PDObject::SetPrefix( const char* prefix ) {\n\n"
   "      fPrefix = prefix;\n\n"
   "      // Set all the variable names:\n"
   "      std::map< TString, VarHandleBase* >::const_iterator itr = fHandles.begin();\n"
   "      std::map< TString, VarHandleBase* >::const_iterator end = fHandles.end();\n"
   "      for( ; itr != end; ++itr ) {\n"
   "         itr->second->SetName( ::TString( prefix ) + itr->first );\n"
   "      }\n\n"
   "      return;\n"
   "   }\n\n"
   "   /**\n"
   "    * This function should be called every time a new TFile is opened\n"
   "    * by your analysis code.\n"
   "    *\n"
   "    * @param tree Pointer to the TTree with the variables\n"
   "    */\n"
   "   void UserD3PDObject::ReadFrom( TTree* tree ) {\n\n"
   "      // Check if the object will be able to read from the TTree:\n"
   "      if( ! fFromInput ) {\n"
   "         Error( \"ReadFrom\",\n"
   "                \"The object was not created with the correct\" );\n"
   "         Error( \"ReadFrom\",\n"
   "                \"constructor to read data from a D3PD!\" );\n"
   "         return;\n"
   "      }\n\n"
   "      // Call ReadFrom(...) on all the variables:\n"
   "      std::map< TString, VarHandleBase* >::const_iterator itr = fHandles.begin();\n"
   "      std::map< TString, VarHandleBase* >::const_iterator end = fHandles.end();\n"
   "      for( ; itr != end; ++itr ) {\n"
   "         // Ignore the variables that are created only now:\n"
   "         if( ! itr->second->GetMaster() ) continue;\n"
   "         itr->second->ReadFrom( tree );\n"
   "      }\n\n"
   "      // Remember the pointer:\n"
   "      fInTree = tree;\n\n"
   "      return;\n"
   "   }\n\n"
   "   /**\n"
   "    * This function can be called to connect the active variables of the object\n"
   "    * to an output TTree. It can be called multiple times, then the variables\n"
   "    * will be written to multiple TTrees.\n"
   "    *\n"
   "    * @param tree Pointer to the TTree where the variables should be written\n"
   "    */\n"
   "   void UserD3PDObject::WriteTo( TTree* tree ) {\n\n"
   "      // Call WriteTo(...) on all the variables:\n"
   "      std::map< TString, VarHandleBase* >::const_iterator itr = fHandles.begin();\n"
   "      std::map< TString, VarHandleBase* >::const_iterator end = fHandles.end();\n"
   "      for( ; itr != end; ++itr ) {\n"
   "         itr->second->WriteTo( tree );\n"
   "      }\n\n"
   "      return;\n"
   "   }\n\n"
   "   /**\n"
   "    * This is a convenience function for turning the branches active or\n"
   "    * inactive conveniently. If the parameter is set to <code>kTRUE</code>\n"
   "    * then the branches available from the input which match the given\n"
   "    * pattern are turned active.\n"
   "    * When it's set to <code>kFALSE</code> then all the variables matching\n"
   "    * the pattern are turned inactive.\n"
   "    *\n"
   "    * @param active Flag behaving as explained above\n"
   "    * @param pattern Regular expression specifying which branches to modify\n"
   "    */\n"
   "   void UserD3PDObject::SetActive( ::Bool_t active, const ::TString& pattern ) {\n\n"
   "      ::TPRegexp re( pattern );\n\n"
   "      std::map< TString, VarHandleBase* >::const_iterator itr = fHandles.begin();\n"
   "      std::map< TString, VarHandleBase* >::const_iterator end = fHandles.end();\n"
   "      for( ; itr != end; ++itr ) {\n"
   "         if( ! re.Match( fPrefix + itr->first ) ) continue;\n"
   "         if( active ) {\n"
   "            if( itr->second->IsAvailable() ) itr->second->SetActive( active );\n"
   "         } else {\n"
   "            itr->second->SetActive( active );\n"
   "         }\n"
   "      }\n\n"
   "      return;\n"
   "   }\n\n"
   "   /**\n"
   "    * This function can be used to read in all the branches from the input\n"
   "    * TTree which are set active for writing out. This can simplify writing\n"
   "    * event selector codes immensely. Remember to set the desired variable\n"
   "    * active before calling this function.\n"
   "    */\n"
   "   void UserD3PDObject::ReadAllActive() {\n\n"
   "      // Check if it makes sense to call this function:\n"
   "      if( ! fFromInput ) {\n"
   "         static ::Bool_t wPrinted = kFALSE;\n"
   "         if( ! wPrinted ) {\n"
   "            Warning( \"ReadAllActive\",\n"
   "                     \"Function only meaningful when used on objects\" );\n"
   "            Warning( \"ReadAllActive\",\n"
   "                     \"which are used to read information from a D3PD\" );\n"
   "            wPrinted = kTRUE;\n"
   "         }\n"
   "      }\n\n"
   "      // Read in the current entry for each active variable:\n"
   "      std::map< TString, VarHandleBase* >::const_iterator itr = fHandles.begin();\n"
   "      std::map< TString, VarHandleBase* >::const_iterator end = fHandles.end();\n"
   "      for( ; itr != end; ++itr ) {\n"
   "         if( ! itr->second->IsActive() ) continue;\n"
   "         itr->second->ReadCurrentEntry();\n"
   "      }\n\n"
   "      return;\n"
   "   }\n\n"
   "   /**\n"
   "    * This function can be used to get information about the access\n"
   "    * pattern/statistics of the job. It should be called at the end of\n"
   "    * an analysis job to get the information about the performance of the\n"
   "    * analysis.\n"
   "    *\n"
   "    * @returns An object describing the D3PD access statistics\n"
   "    */\n"
   "   D3PDReadStats UserD3PDObject::GetStatistics() const {\n\n"
   "      // The result object:\n"
   "      D3PDReadStats result;\n\n"
   "      // Add the statistics from each variable to the result:\n"
   "      std::map< ::TString, VarHandleBase* >::const_iterator itr = fHandles.begin();\n"
   "      std::map< ::TString, VarHandleBase* >::const_iterator end = fHandles.end();\n"
   "      for( ; itr != end; ++itr ) {\n"
   "         result.AddVariable( itr->second->GetStatistics() );\n"
   "      }\n\n"
   "      return result;\n"
   "   }\n\n"
   "   /**\n"
   "    * User variables can't be copied like this at the moment.\n"
   "    */\n"
   "   UserD3PDObject& UserD3PDObject::Set( const UserD3PDObject& parent ) {\n\n"
   "      if( parent.fHandles.size() ) {\n"
   "         Error( \"Set\",\n"
   "                \"User variables can not be copied usig this function!\" );\n"
   "      }\n"
   "      return *this;\n"
   "   }\n\n"
   "   /**\n"
   "    * This function makes it easier to clear out the object completely.\n"
   "    * It cleares all the vector variables, and sets the element number\n"
   "    * variable to 0. Very useful when performing object selection.\n"
   "    * The option argument is not used at the moment for anything.\n"
   "    * It's only there because the <code>Clear</code> function defined in\n"
   "    * TObject has this parameter as well.\n"
   "    *\n"
   "    * @param option Ignored at the moment\n"
   "    */\n"
   "   void UserD3PDObject::Clear( Option_t* ) {\n\n"
   "      // Clear each variable:\n"
   "      std::map< ::TString, VarHandleBase* >::const_iterator itr = fHandles.begin();\n"
   "      std::map< ::TString, VarHandleBase* >::const_iterator end = fHandles.end();\n"
   "      for( ; itr != end; ++itr ) {\n"
   "         itr->second->Clear();\n"
   "      }\n\n"
   "      return;\n"
   "   }\n\n"
   "   /**\n"
   "    * User variables can't be copied like this at the moment.\n"
   "    */\n"
   "   UserD3PDObject& UserD3PDObject::Add( const UserD3PDObjectElement& el ) {\n\n"
   "      if( el.fProxies.size() ) {\n"
   "         Error( \"Add\",\n"
   "                \"User variables can not be copied usig this function!\" );\n"
   "      }\n"
   "      return *this;\n"
   "   }\n\n"
   "   /**\n"
   "    * This operator can be used to get access to one element in the\n"
   "    * collection. This element can then be passed around between parts\n"
   "    * of the analysis code easily.\n"
   "    *\n"
   "    * This version is useful when modifying the variable contents through\n"
   "    * the proxy objects.\n"
   "    *\n"
   "    * @param index Index of the element inside the collection\n"
   "    */\n"
   "   UserD3PDObjectElement& UserD3PDObject::operator[]( size_t index ) {\n\n"
   "      while( fProxies.size() <= index ) {\n"
   "         fProxies.push_back( new UserD3PDObjectElement( fProxies.size(), *this ) );\n"
   "      }\n"
   "      return *fProxies[ index ];\n"
   "   }\n\n"
   "   /**\n"
   "    * This operator can be used to get access to one element in the\n"
   "    * collection. This element can then be passed around between parts\n"
   "    * of the analysis code easily.\n"
   "    *\n"
   "    * This version is useful when only reading the variables.\n"
   "    *\n"
   "    * @param index Index of the element inside the collection\n"
   "    */\n"
   "   const UserD3PDObjectElement& UserD3PDObject::operator[]( size_t index ) const {\n\n"
   "      while( fProxies.size() <= index ) {\n"
   "         fProxies.push_back( new UserD3PDObjectElement( fProxies.size(), *this ) );\n"
   "      }\n"
   "      return *fProxies[ index ];\n"
   "   }\n\n"
   "   /**\n"
   "    * A convenience operator for adding an 'element' to this collection.\n"
   "    *\n"
   "    * @see Add\n"
   "    * @param el The 'element' that should be added to the collection\n"
   "    */\n"
   "   UserD3PDObject& UserD3PDObject::operator+=( const UserD3PDObjectElement& el ) {\n\n"
   "      return this->Add( el );\n"
   "   }\n\n"
   "} // namespace D3PDReader";

#endif // D3PDMAKERREADER_ROOTREADERD3PD_V2_CONSTANTS_H
