// This file's extension implies that it's C, but it's really -*- C++ -*-.

/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

// $Id$
/**
 * @file AthLinks/tools/ElementLinkTraits.h
 * @author scott snyder <snyder@bnl.gov>
 * @date Dec, 2013
 * @brief Determine dependent types for @c ElementLink classes.
 *
 * An @c ElementLink class needs to store the index of the referenced
 * element; it also caches a copy of the element itself.  In general,
 * these can be arbitrary types, and so the data members for them
 * must be in a templated class.
 *
 * However, by far the most common use of @c ElementLink is to refer
 * to an element in a vector-like container of pointers.  In that case,
 * we can get away with storing the persistent data in a non-templated
 * class, and in fact that makes direct ROOT I/O much easier.
 *
 * So, what we do is factor out all the state of @c ElementLink into a base
 * class.  For the generic case, we use the templated @c GenericElementLinkBase
 * class.  However, for the case of a vector of pointers, we use instead
 * the non-templated class @c ElementLinkBase.  The choice of which
 * base class to use is made by the traits class defined here,
 * @c ElementLinkTraits.
 *
 * An @c ElementLink must also be associated with an indexing policy class.
 * The traits class also provides the appropriate indexing policy;
 * in general, this is generated by @c GenerateIndexingPolicy,
 * but for the specialized case, we always use @c ForwardIndexingPolicy.
 *
 * See below for the interfaces that must be supplied by the @c ElementLink
 * base classes and by the indexing policy.
 */


#ifndef ATHLINKS_ELEMENTLINKTRAITS_H
#define ATHLINKS_ELEMENTLINKTRAITS_H


#include "AthLinks/ElementLinkBase.h"
#include "AthLinks/tools/IsSTLSequence.h"
#include "AthLinks/tools/ForwardIndexingPolicy.h"
#include "AthLinks/tools/GenerateIndexingPolicy.h"
#include "AthLinks/GenericElementLinkBase.h"
#if __cplusplus > 201100
# include <type_traits>
namespace SG_STD_OR_BOOST = std;
#else
# include "boost/type_traits/is_pointer.hpp"
namespace SG_STD_OR_BOOST = boost;
#endif


namespace SG { 


// This is the interface that must be supplied by the ElementLink base class.
//  typedef index_type --- The type of the index supplied to and returned
//                         from ElementLink.
//  typedef sgkey_t --- Type of hashed  keys.
//  typedef ID_type --- Type of string keys.
//  typedef casefn_t --- Function casting from DataProxy to pointer.
//
//  Should have a valid copy constructor and assignment operator.
//
//  bool isDefaultIndex() const
//   Test the index validity.
//  bool hasCachedElement() const
//   Test to see if this link has a cached element pointer.
//  bool isDefault() const
//   Test to see if this link is in the default state.
//  index_type index() const
//   Return the index of the link.
//  ID_type dataID() const
//   Return the SG key that we reference, as a string.
//  sgkey_t key() const
//   Return the SG key that we reference, as a hash.
//  IProxyDict* source() const
//   Return the data source for the reference.
//  void reset()
//   Reset the link to a null state.
//  bool toTransient (IProxyDict*)
//   Finish initialization after link has been read.
//  bool doPersistent()
//   Prepare this link for writing.
//
// protected:
//  Base()
//   Makes a null link.
//  Base(const ID_type&, CLID, index_type, IProxyDict*)
//   Make link from string key and index.
//  Base(sgkey_t, CLID, index_type, IProxyDict*)
//   Make link from hashed key and index.
//  Base(const ID_type&, CLID, index_type, const void*, IProxyDict*)
//   Make link from string key, index, and element pointer.
//  Base(sgkey_t, CLID, index_type, const void*, IProxyDict*)
//   Make link from hashed key, index, and element pointer.
//  Base(const_pointer_t, CLID, index_type, IProxyDict*)
//   Make link from an index and a pointer to the container.
//  Base(const ElementLink<OTHER>&, FROM_TRAITS*, TO_TRAITS*)
//   Derived->base link conversion.
//  SG::DataProxy* proxy() const
//   Return the SG proxy for the container holding the element.
//  void* storableBase(castfn_t*, CLID)
//   Return a pointer to the currently-referenced container object.
//  bool setStorableObject (const_pointer_t, CLID, bool, IProxyDict*)
//   Set the container referenced by the link to a pointer.
//  bool toIndexedElement (const_pointer_t, CLID, index_type,IProxyDict*)
//   Set the to an element given by index and pointer to container.
//  resetWithKeyAndIndex (const ID_type&, CLID, index_type, IProxyDict*)
//   Set the link to an element given by string key and index.
//  resetWithKeyAndIndex (sgkey_t, CLID, index_type, IProxyDict*)
//   Set the link to an element given by string key and index.
//  void setIndex(index_type)
//   Set the index part of the link.
//  const stored_index_type& storedIndex() const
//   Return the stored representation of the link index.
//  void setCachedElement(element_t)
//   Set the cached element stored in the link.
//  bool getCachedElement (const T* &) const
//   Retrieve the cached element from the link.
//  const SG::DataProxyHolder& proxyHolder() const
//   Return a reference to the internal proxy holder object.



// This is the interface that must be supplied by an indexing policy.
// All methods are static; instances of this class are never
// actually created.
//  typedef ElementType --- The type returned when the link is dereferenced.
//  typedef ElementConstReference --- Derived from ElementType.
//  typedef ElementConstPointer --- Derived from ElementType.
//  typedef index_type --- The type of the index supplied to and returned
//                         from ElementLink.
//  typedef stored_index_type --- The type of the index actually stored
//                                within the ElementLink.  Should
//                                be implicitly convertable to index_type
//                                (if not identical).
//  static bool isValid (stored_index_type index);
//    Test to see if an index has been set.
//  static index_type storedToExternal (stored_index_type index)
//    Convert from stored to external index.
//  static void reset (stored_index_type& index);
//    Reset an index to an invalid state.
//  static ElementType lookup (index_type index, const CONT& data);
//    Return the element identified by INDEX in DATA.
//    May throw an exception if the index is not valid.
//  static void reverseLookup(const CONT& data,
//                            ElementConstReference element,
//                            index_type& index);
//    Find the (first) index for ELEMENT in DATA.
//    Throw SG::ExcElementNotFound if the element is not in the container.
//



/**
 * @brief ElementLink classes for the generic case.
 */
template <class STORABLE,
          class VALUE_TYPE = typename STORABLE::value_type,
          bool IS_SEQUENCE = IsSTLSequence<STORABLE>::value>
class ElementLinkTraits1
{
public:
  typedef STORABLE Storable;
  typedef typename SG::GenerateIndexingPolicy<STORABLE>::type IndexingPolicy;
  typedef typename SG::GenericElementLinkBase<IndexingPolicy> Base;
};


/**
 * @brief ElementLink classes for the case of a vector-like container
 *        of pointers.
 */
template <class STORABLE, class BASE_VALUE_TYPE>
class ElementLinkTraits1<STORABLE, BASE_VALUE_TYPE*, true>
{
public:
  typedef STORABLE Storable;
  typedef ElementLinkBase Base;
  typedef ForwardIndexingPolicy<STORABLE> IndexingPolicy;
};



/**
 * @brief ElementLinkTraits class to specialize.
 *
 * This is split out from @c ElementLinkTraits1 to allow specializing
 * this class on a container class with an incomplete definition.
 */
template <class STORABLE>
class ElementLinkTraits
  : public ElementLinkTraits1<STORABLE>
{
public:
  typedef STORABLE Storable;
  typedef typename ElementLinkTraits1<STORABLE>::Base Base;
  typedef typename ElementLinkTraits1<STORABLE>::IndexingPolicy IndexingPolicy;
};


} // namespace SG



/**
 * @brief Forward declaration helper for ElementLink.
 *
 * This macro helps in declaring an ElementLink to a container with
 * an incomplete definition (that has been forward declared).
 * Restriction: The container _must_ be a vector-like container of pointers.
 * Must not be used inside a namespace.
 *
 * See comments in ElementLink.h for a usage example.
 */
#define ELEMENTLINK_FWD(TYPE, VALUE_TYPE)                               \
namespace SG {                                                          \
template<>                                                              \
class ElementLinkTraits<TYPE>                                           \
{                                                                       \
public:                                                                 \
  typedef TYPE Storable;                                                \
  typedef ElementLinkBase Base;                                         \
  typedef ForwardIndexingPolicy<TYPE, VALUE_TYPE*> IndexingPolicy;      \
};                                                                      \
}                                                                       \
class elementlink_fwd_dummy



#endif // not ATHLINKS_ELEMENTLINKTRAITS_H
