#!/bin/bash

# use this to enable bash script debugging:
#set -x

PROGNAME=${0##*/}
PROGVERSION=0.0.0
#GPERFTOOLSPKG="External/AtlasGPerfTools"  OBSOLETE
#CMT=`which cmt.exe`  OBSOLETE

# the preincludes used for the differend possible profilerModes
EVENTLOOP_PREINCLUDE="PerfMonGPerfTools/ProfileEventLoop_preInclude.py"
JOB_PREINCLUDE="PerfMonGPerfTools/ProfileJob_preInclude.py"

# using this post-include makes the GPT more stable
POSTINCLUDE="PerfMonGPerfTools/DisableCoreDumpSvc_postInclude.py"


#
# help output function
#
usage()
{ 
  echo "Usage: $PROGNAME [options]"
  echo ""
  echo "Options:"
  echo " -h|--help                 show this output"
  echo " -v|--profilerVersion      display version of PerfMonGPerfTools used for profiling"
  echo " --trf \"TRFCMD\"          run on a job transform script"
  echo " --tf \"TFCMD\"            run on a new job transform script"
  echo " --profilerMode MODE       defines which part of the program will be profiled"
  echo "                           Allowed values for MODE are:"
  echo "                             eventLoop  for profiling on the Athena eventLoop (default)"
  echo "                             job        run profiling on the whole Athena job"
  echo " --profilerInitEvent EVT   in 'eventLoop' Mode, define the event number after which profiling starts"
  echo " --profilerOutput OUT      pofiler output file"
}



# by default, run profiling on the event loop
# (will be overwritten in case a --profilerMode argument is given)
PREINCLUDE=${EVENTLOOP_PREINCLUDE}


#########################
# 
# loop over all command line arguments
#
#########################
NUM_ATHENA_ARGS=0
set -- "$@"
while [ $# -gt 0 ]; do 

  case $1 in 
    -h|--help)
      # call the 'usage' function to print the help output
      usage 
      exit 0 
      ;; 

    -v|--profilerVersion)
      echo "$PROGVERSION" 
      exit 0
      ;; 

    --profilerInitEvent)
      shift 
      INITEVENT=${1}
      ;; 

    --profilerOutput)
      shift 
      OUTPUTFILE=${1}
      ;; 

    --profilerMode)
      shift 
      MODE=${1}
      # choose the right jobOptions fragment which adds GPerfTool to athena run
      case $MODE in
        eventLoop)
          PREINCLUDE=${EVENTLOOP_PREINCLUDE}
          ;;
        job)
          PREINCLUDE=${JOB_PREINCLUDE}
          ;;
        *)
          echo "PerfMonGPerfTools: ERROR: Unknown profilerMode given!"
          exit 1
          break
          ;;
      esac
      ;; 

    --trf)
      shift 
      TRFCOMMAND=${1}
      ;; 

    --tf)
      shift 
      TFCOMMAND=${1}
      ;; 

    *)
      # the current argument is not recognized as a gathena argument
      # -> pass it to athena later on (store in ATHENAARGS)
      ATHENAARGS[NUM_ATHENA_ARGS]=$1
      ((NUM_ATHENA_ARGS++))
      ;; 

  esac 
  shift 
done

# remove all remaining arguments form the ${@} variable
#  -> required because they would be picked up later by the source command
for dummy in ${@}; do
  shift
done

###########################
#
# create a local file, used as jobOptions fragment
#
###########################
JOFRAGMENT=gathena_preInclude_autoGen.py
echo "# this jobOptions fragment is automatically generated by ${PROGNAME}" > $JOFRAGMENT
echo "# this file will be automatically deleted after the Athena job is finished" >> $JOFRAGMENT
echo "include ('${PREINCLUDE}')" >> $JOFRAGMENT
# output filename was set by a command line argument
if [ -n "${OUTPUTFILE}" ]; then
  echo "ServiceMgr.ProfilerService.ProfileFileName='${OUTPUTFILE}'" >> $JOFRAGMENT
fi
# init event was set by a command line argument and event loop profiling is activated
if [[ -n "${INITEVENT}" && "${PREINCLUDE}" == "${EVENTLOOP_PREINCLUDE}" ]]; then
  echo "ServiceMgr.ProfilerService.InitEvent=${INITEVENT}" >> $JOFRAGMENT
fi


###########################
#
# if non-empty TRFCOMMAND string -> prepare running on a jobTransform
#
###########################
if [ -n "${TRFCOMMAND}" ]; then
  echo "PerfMonGPerfTools: Preparing PerfMonGPerfTools for running with a job transform script"

  # if TRFCOMMAND contains a preInclude already -> prepend PerfMonGPerfTools preinclude
  if [[ ${TRFCOMMAND} == *" preInclude="* ]]; then
    TRFCOMMAND=${TRFCOMMAND/ preInclude=/ preInclude=${JOFRAGMENT},}
  # no preInclude argument given by the user -> add preInclude argument
  else
    TRFCOMMAND="${TRFCOMMAND} preInclude=${JOFRAGMENT}"
  fi

  # if TRFCOMMAND contains a posInclude already -> prepend PerfMonGPerfTools postinclude
  if [[ ${TRFCOMMAND} == *" postInclude="* ]]; then
    TRFCOMMAND=${TRFCOMMAND/ postInclude=/ postInclude=${POSTINCLUDE},}
  # no postInclude argument given by the user -> add postInclude argument
  else
    TRFCOMMAND="${TRFCOMMAND} postInclude=${POSTINCLUDE}"
  fi
fi


###########################
#
# if non-empty TFCOMMAND string -> prepare running on a jobTransform
#
###########################
if [ -n "${TFCOMMAND}" ]; then
  echo "PerfMonGPerfTools: Preparing PerfMonGPerfTools for running with a job transform script"

  # if TFCOMMAND contains a preInclude already -> prepend PerfMonGPerfTools preinclude
  if [[ ${TFCOMMAND} == *" --preInclude="* ]]; then
    TFCOMMAND=${TFCOMMAND/ --preInclude=/ --preInclude=${JOFRAGMENT},}
  # no preInclude argument given by the user -> add preInclude argument
  else
    TFCOMMAND="${TFCOMMAND} --preInclude=${JOFRAGMENT}"
  fi

  # if TFCOMMAND contains a posInclude already -> prepend PerfMonGPerfTools postinclude
  if [[ ${TFCOMMAND} == *" --postInclude="* ]]; then
    TFCOMMAND=${TFCOMMAND/ --postInclude=/ --postInclude=${POSTINCLUDE},}
  # no postInclude argument given by the user -> add postInclude argument
  else
    TFCOMMAND="${TFCOMMAND} --postInclude=${POSTINCLUDE}"
  fi
fi


#########################
#
# setup TCMALLOCDIR & LD_LIBRARY_PATH
#
# (OBSOLETE due to new AtlasGPerfTools package setup)
#
#########################
## find all active versions of the AtlasGPerfTools package
#PKGVERSIONS=`${CMT} show versions ${GPERFTOOLSPKG} 2>&1 `> /dev/null
## 'cmt show versions' returned exit code 0 -> found a package version that is in use
#if [ $? -eq 0 ]; then
#  # parse the versions string
#  #   the string as a format like:
#  #   Control/PerfMonGPerfTools PerfMonGPerfTools-00-00-99 /afs/cern.ch/.../17.2.0.3 Control/PerfMonGPerfTools PerfMonGPerfTools-00-00-88 /afs/cern.ch/../17.2.0
#  #   and the parsing cuts out this part:                  ^^^^^^^^^^^^^^^^^^^^^^^^^
#
#  # 1.) cut away the pieces on the left side of the string
#  #     until the second space
#  PKGVERSIONS=${PKGVERSIONS#* }
#  PKGVERSIONS=${PKGVERSIONS#* }
#  # 2.) cut away the pieces on the right side of the string until one character before
#  #     the left end of the left-most appearance of ${GPERFTOOLSPKG}
#  PKGVERSIONS=${PKGVERSIONS%%?${GPERFTOOLSPKG}*}
#  # 3). what remains in ${PKGVERSIONS} is the path to the build where ${GPERFTOOLSPKG}
#  #     is taken from
#  GPERFTOOLSPKGDIR=${PKGVERSIONS}/${GPERFTOOLSPKG}
#
## 'cmt show versions' returned exit code !=0 -> unable to locate active package
#else
#  echo "PerfMonGPerfTools: ERROR: 'cmt show versions ${GPERFTOOLSPKG}' returned an error"
#  # TODO: check out package in tmp and do source on it
#  exit 1
#fi
#
## source setup.sh of glue package in oder to set correct paths
#if [ -d ${GPERFTOOLSPKGDIR} ]; then
#  echo "PerfMonGPerfTools: Setting up environment variables (local to this script only)"
#  source ${GPERFTOOLSPKGDIR}/cmt/setup.sh
#else
#  echo "PerfMonGPerfTools: ERROR: ${GPERFTOOLSPKG} glue package not found in:"
#  echo "PerfMonGPerfTools:   -> ${GPERFTOOLSPKGDIR}"
#fi


#########################
#
# execute the actual athena job / jobTransform
#
#########################
echo "PerfMonGPerfTools: Will now run PerfMonGPerfTools on the defined Athena job:"

# (a) run job transform
if [ -n "${TRFCOMMAND}" ]; then
  echo "PerfMonGPerfTools:  -> ${TRFCOMMAND}"
  ${TRFCOMMAND}
  EXITCODE=$?

# (b) run new job transform
elif [ -n "${TFCOMMAND}" ]; then
  echo "PerfMonGPerfTools:  -> ${TFCOMMAND}"
  ${TFCOMMAND}
  EXITCODE=$?

# (c) run athena.py directly
else
  echo PerfMonGPerfTools:  "->" athena.py ${JOFRAGMENT} "${ATHENAARGS[@]}" ${POSTINCLUDE}
  athena.py ${JOFRAGMENT} "${ATHENAARGS[@]}" ${POSTINCLUDE}
  EXITCODE=$?
fi

# remove the temporary local jobOptions fragment
rm ${JOFRAGMENT}

# make sure this script retuns with the same exit code as the athena job
exit ${EXITCODE}
