#!/bin/env python

# Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
##
# @file DozerGraph.py
# @author Krzysztof Daniel Ciba (Krzysztof.Ciba@NOSPAMgmail.com)
# @brief Classes to produce ROOT.TGraph or ROOT.TH1D with long-term monitoring data 
#

import DozerObject
from DozerUtils import  DozerLogger, DozerError, DozerSingleton
from DozerChannel import DozerChannel
from DozerData import DozerData
from DozerIOV import DozerIOV
from array import array
from types import *

import unittest
import sys

## run ROOT in batch mode
sys.argv.append("-b")
import ROOT

##
# @class DozerStyle
# @author Krzysztof Daniel Ciba (Krzysztof.Ciba@NOSPAMgmail.com)
# @brief Sets up various ROOT.TStyles for DozerGraph.
#
# @htmlinclude cool_dozer_api.css
# <h3>Usage</h3>
#
# <ul>
# <li> <h4>Purpose</h4>
#
# DozerStyle instance setting up various ROOT.TStyles for plots generated by DozerGraph. 
#
# <li> <h4>Interface</h4>
# 
#<div><div class="dozerCode"><div class="dozerCodeLabel"> Example </div>  <div class="dozerCodeText"> 
#<b><pre>
#[lxplus207] ~/scratch2/CoolDozer/python % python 
#Python 2.5 (r25:51908, Oct 18 2007, 16:04:48) 
#[GCC 3.4.6 20060404 (Red Hat 3.4.6-8)] on linux2
#Type "help", "copyright", "credits" or "license" for more information.
#>>> import ROOT
#>>> import DozerGraph
#>>> stylist = DozerGraph.DozerStyle()                        # [1] create DozerStyle
#>>> stylist.styles()
#['Dozer', 'Default', 'Dolphin', 'Seal', 'Seagull', 'Orca']   # [2] list avalable styles
#>>> "Orca" in stylist                                        # [3] check if style is defined  
#True
#>>> "Whale" in stylist                                       # [4] ...or not
#False
#>>> stylist.setStyle("Orca")                                 # [5] set ROOT.gStyle to Orca
#>>> stylist.saveStyle("Orca")                                # [6] save style to ROOT macro file
#Info in <TStyle::SaveAs>: C++ Macro file: DozerStyle_Orca.C has been generated
#</pre></b>
#</div></div></div>
#
#
# <li> <h4>List of available styles</h4>
# <ul>
# <li> <i>Dozer</i> (<i>Default</i>)<br> 
# @image html trend_default.png "Trend plot using Dozer (Default) DozerStyle"
# @image html histogram_default.png "Histogram plot using Dozer (Default) DozerStyle"
# <li> <i>Orca</i><br> 
# @image html trend_orca.png "Trend plot using Orca DozerStyle"
# @image html histogram_orca.png "Histogram plot using Orca DozerStyle"
# <li> <i>Dolphin</i><br>
# @image html trend_dolphin.png "Trend plot using Dolphin DozerStyle"
# @image html histogram_dolphin.png "Histogram plot Dolphin Orca DozerStyle"
# <li> <i>Seagull</i><br>
# @image html trend_seagull.png "Trend plot using Seagull DozerStyle"
# @image html histogram_seagull.png "Histogram plot using Seagull DozerStyle"
# <li> <i>Seal</i><br>
# @image html trend_seal.png "Trend plot using Seal DozerStyle"
# @image html histogram_seal.png "Histogram plot using Seal DozerStyle"
# </ul>
# </ul>
class DozerStyle( DozerObject.DozerObject ):

    __metaclass__ = DozerSingleton

    ## c'tor
    # @param self "Me, myself and Irene"
    # @param style a style name 
    # @param log DozerLoger instance or None
    def __init__( self, style="Default", log=None ):

        super( DozerStyle, self ).__init__( log )

        self.__styles = { "Orca"      : self.__orcaStyle,
                          "Dolphin"   : self.__dolphinStyle, 
                          "Seagull"   : self.__seagullStyle, 
                          "Dozer"     : self.__dozerStyle,
                          "Seal"     : self.__sealStyle,
                          "Default"   : self.__dozerStyle }

        self.setStyle( style )
    
    ## ROOT.TStyle setter
    # @param self "Me, myself and Irene"
    # @param name DozerStyle style name 
    def setStyle( self, name ):
        self.debug("setting ROOT TStyle to %s" % str(name) )
        if ( name in self.__styles.keys() ):
            self.__styles[name].__call__()
        else:
            self.warn("style name='%s' not found, using default")
            self.__styles["Default"].__call__()
        

    ## style's names  getter
    # @param self "Me, myself and Irene"
    def styles( self ):
        return self.__styles.keys() 

    ## style's names 
    # @param self "Me, myself and Irene"
    def keys( self ):
        return self.__styles.keys()

    ## in operator
    # @param self "Me, myself and Irene"
    # @param name style name to check
    def __contains__( self, name ):
        if ( name in self.__styles.keys() ): return True
        return False 

    ##
    # @param self "Me, myself and Irene"
    # @param name DozerStyle name to save
    def saveStyle( self, name=None ):
        if ( name and name in self ):  
            self.setStyle( name )
            style = ROOT.TStyle ( ROOT.gStyle )
            style.SetName( name )
            style.SetTitle( "DozerStyle %s" % name )
            style.SaveAs("DozerStyle_%s.C" % name )
        else:
            self.error("style not saved, unknown DozerStyle name=%s" % name)

    ## common style for all DozerStyle supported styles 
    # @param self "Me, myself and Irene"
    def __common( self ):

        ROOT.gStyle.SetOptTitle(0)
        ROOT.gStyle.SetOptStat(0)
        ROOT.gStyle.SetOptFit(0)
  
        ROOT.gStyle.SetFillStyle(1001)

        ROOT.gStyle.SetMarkerSize(1.1)
        ROOT.gStyle.SetMarkerStyle( ROOT.kOpenCircle )

        ROOT.gStyle.SetLineWidth( 2 )
        
        ROOT.gStyle.SetLabelFont(102, "xyz")  
        ROOT.gStyle.SetLabelSize(0.03, "xyz")
        
        ROOT.gStyle.SetTitleFont(102, "xyz")
        ROOT.gStyle.SetTitleFontSize(0.04)
        
        ROOT.gStyle.SetTitleFont(102, "a")   

        ROOT.gStyle.SetFuncStyle(1)
        ROOT.gStyle.SetFuncWidth(2)
        
        ROOT.gStyle.SetHistLineColor(602)
        ROOT.gStyle.SetHistLineWidth(1)

        ROOT.gStyle.SetPadBorderSize(1)
        ROOT.gStyle.SetPadBorderMode(0)
                
        ROOT.gStyle.SetPadLeftMargin( 0.1 )
        ROOT.gStyle.SetPadBottomMargin( 0.1 )
        ROOT.gStyle.SetPadRightMargin( 0.1 )
        ROOT.gStyle.SetPadTopMargin( 0.1 )
            
        ROOT.gStyle.SetCanvasBorderSize(1)
        ROOT.gStyle.SetCanvasBorderMode(0)
  
        ROOT.gStyle.SetGridStyle(3)
        ROOT.gStyle.SetGridWidth(1)
        
        ROOT.gStyle.SetOptDate(21)
        ROOT.gStyle.GetAttDate().SetTextFont(102)
        ROOT.gStyle.GetAttDate().SetTextSize(0.025)
        
        ROOT.gROOT.ForceStyle(1)


    ## Orca style, black, white, gray 
    # @param self "Me, myself and Irene"
    def __orcaStyle( self ):
        self.__common()
        ROOT.gStyle.SetTextColor(0)
        ROOT.gStyle.GetAttDate().SetTextColor(0)
        ROOT.gStyle.SetLabelColor(0, "xyz")
        ROOT.gStyle.SetTitleColor(0, "xyz")
        ROOT.gStyle.SetFillColor(920)
        ROOT.gStyle.SetMarkerColor(12)
        ROOT.gStyle.SetLineColor(12)
        ROOT.gStyle.SetCanvasColor(1)    
        ROOT.gStyle.SetFrameFillColor(0)
        ROOT.gStyle.SetPadColor(920)
        ROOT.gStyle.SetTitleColor(920, "a")
        ROOT.gStyle.SetFuncColor(14)
        ROOT.gStyle.SetHistLineColor(1)
        ROOT.gStyle.SetHistFillColor(12)
        ROOT.gStyle.SetGridColor(1)
        
    ## Dolphin style, blue, cyan, green 
    # @param self "Me, myself and Irene"
    def __dolphinStyle( self ):
        self.__common()
        ROOT.gStyle.SetTextColor(604)
        ROOT.gStyle.GetAttDate().SetTextColor(604)
        ROOT.gStyle.SetLabelColor(604, "xyz")
        ROOT.gStyle.SetTitleColor(604, "xyz")
        ROOT.gStyle.SetFillColor(593)
        ROOT.gStyle.SetMarkerColor(604)
        ROOT.gStyle.SetLineColor(604)
        ROOT.gStyle.SetCanvasColor(426)    
        ROOT.gStyle.SetFrameFillColor(406)
        ROOT.gStyle.SetPadColor(593)
        ROOT.gStyle.SetTitleColor(593, "a")
        ROOT.gStyle.SetFuncColor(436)
        ROOT.gStyle.SetHistLineColor(593)
        ROOT.gStyle.SetHistFillColor(593)
        ROOT.gStyle.SetGridColor(604)

    ## Seagull style =  white, gray, black  
    # @param self "Me, myself and Irene"
    def __seagullStyle( self ):
        self.__common()
        ROOT.gStyle.SetTextColor(1)
        ROOT.gStyle.GetAttDate().SetTextColor(1)
        ROOT.gStyle.SetLabelColor(1, "xyz")
        ROOT.gStyle.SetTitleColor(1, "xyz")
        ROOT.gStyle.SetFillColor(0)
        ROOT.gStyle.SetMarkerColor(1)
        ROOT.gStyle.SetLineColor(1)
        ROOT.gStyle.SetCanvasColor(0)    
        ROOT.gStyle.SetFrameFillColor(920)
        ROOT.gStyle.SetPadColor(0)
        ROOT.gStyle.SetTitleColor(0, "a")
        ROOT.gStyle.SetFuncColor(14)
        ROOT.gStyle.SetHistLineColor(1)
        ROOT.gStyle.SetHistFillColor(12)
        ROOT.gStyle.SetGridColor(1)
        

    ## Seal style, brown, orange
    # @param self "Me, myself and Irene"
    def __sealStyle( self ):
        self.__common()
        ROOT.gStyle.SetTextColor(1)
        ROOT.gStyle.GetAttDate().SetTextColor(1)
        ROOT.gStyle.SetLabelColor(1, "xyz")
        ROOT.gStyle.SetTitleColor(1, "xyz")
        ROOT.gStyle.SetFillColor(791)
        ROOT.gStyle.SetMarkerColor(636)
        ROOT.gStyle.SetLineColor(636)
        ROOT.gStyle.SetCanvasColor(793)    
        ROOT.gStyle.SetFrameFillColor(390)
        ROOT.gStyle.SetPadColor(0)
        ROOT.gStyle.SetTitleColor(0, "a")
        ROOT.gStyle.SetFuncColor(631)
        ROOT.gStyle.SetHistLineColor(806)
        ROOT.gStyle.SetHistFillColor(806)
        ROOT.gStyle.SetGridColor(1)



    ## Albatross style 
    #
    def __albatrossStyle( self ):
        pass

    ## Crane style, 
    #
    def __craneStyle( self ):
        pass


    ## Dozer style, yellow and blue
    # @param self "Me, myself and Irene"
    def __dozerStyle( self ):
        self.__common( )
        ROOT.gStyle.SetTextColor(1)
        ROOT.gStyle.GetAttDate().SetTextColor(1)
        ROOT.gStyle.SetLabelColor(1, "xyz")
        ROOT.gStyle.SetTitleColor(1, "xyz")
        ROOT.gStyle.SetFillColor(796)
        ROOT.gStyle.SetMarkerColor(602)
        ROOT.gStyle.SetLineColor(602)
        ROOT.gStyle.SetCanvasColor(796)    
        ROOT.gStyle.SetFrameFillColor(390)
        ROOT.gStyle.SetPadColor(390)
        ROOT.gStyle.SetTitleColor(390, "a")
        ROOT.gStyle.SetFuncColor(632)
        ROOT.gStyle.SetHistLineColor(602)
        ROOT.gStyle.SetHistFillColor(602)
        ROOT.gStyle.SetGridColor(0)
        pass
##
# @class DozerGraph 
# @author Krzysztof Daniel Ciba (Krzysztof.Ciba@NOSPAMgmail.com)
# @brief Class for plotting data from DozerRecordSet.
# @htmlinclude cool_dozer_api.css
# <h3>Usage</h3>
#
#<div><div class="dozerTrick"><div class="dozerTrickLabel"> Trick? </div> <div class="dozerTrickText"> 
# DozerGraph should be constructed by calling python::DozerRecordSet::getDozerGraph function.
#</div></div></div>
#
# Once you have got DozerGraph instance you can make:
# <ul>
# <li> trend plot by calling DozerGraph::trend 
# @image html trend_default.png "Example trend plot"
# <li> histogram plot by calling DozerGraph::histogram
# @image html histogram_default.png "Example histogram plot" 
# </ul>
#
#<div><div class="dozerInfo"><div class="dozerInfoLabel">Notice</div><div class="dozerInfoText">
# Browse documentation for DozerStyle for changing plots style.
#</div></div></div>
#
class DozerGraph( DozerObject.DozerObject ):

    __since = None

    __until = None

    __linearFitReady  = False 

    __gaussianFitReady = False

    __style = None

    ## c'tor
    # @param self "Me, myself and Irene"
    # @param package package name
    # @param framework test framework name
    # @param nightly nightly name
    # @param install instal name
    # @param cmtconfig CMTCONFIG value
    # @param project Atlas project name
    # @param jobId job id
    # @param pointsInTime points in time ( since, until, DozerData )
    # @param log DozerLogger instance
    def __init__( self, 
                  package, 
                  framework, 
                  nightly, 
                  install, 
                  cmtconfig, 
                  project,
                  jobId, 
                  pointsInTime, 
                  log=None ):

        super( DozerGraph, self ).__init__( log )

        self.__package = package

        self.__channel = None

        self.__framework = framework

        self.__nightly = nightly
        
        self.__install = install

        self.__cmtconfig = cmtconfig

        self.__project = project

        self.__jobId = jobId

        self.__plotable = [ ]

        self.pointsInTime = { }

        self.__prepareData( pointsInTime )
       

        self.__style = "Dozer"
        self.__styles = DozerStyle()

    ## package name getter
    # @param self "Me, myself and Irene"
    def package( self ):
        return self.__package


    ## chanel name getter
    # @param self "Me, myself and Irene"
    def channel( self ):
        return self.__channel

    ## framework name getter
    # @param self "Me, myself and Irene"
    def framework( self ):
        return self.__framework

    ## nightly name getter
    # @param self "Me, myself and Irene"
    def nightly( self ):
        return self.__nightly

    ## install name getter
    # @param self "Me, myself and Irene" 
    def install( self ):
        return self.__install

    ## CMTCONFIG value getter
    # @param self "Me, myself and Irene"
    def cmtconfig( self ):
        return self.__cmtconfig

    ## project name getter
    # @param self "Me, myself and Irene"
    def project( self ):
        return self.__project

    ## job id getter
    # @param self "Me, myself and Irene"
    def jobId( self ):
        return self.__jobId
    
    ## style setter
    # @param self "Me, myself and Irene"
    # @param name style name 
    def setStyle( self, name=None ):
        if ( name in self.__styles ):
            self.__style = name 
                    
    ## current style getter 
    # @param self "Me, myself and Irene"
    def getStyle( self ):
        return self.__style
            
    ## style getter
    # @param self "Me, myself and Irene" 
    def style( self ):
        return self.__style

    ## internal DozerStyle setter
    # @param self "Me, myself and Irene"
    # @param name style name
    def __applyStyle( self , name ):
        self.__styles.setStyle( name  )

    ## preparation of data points 
    # @param self "Me, myself and Irene"
    # @param pointsInTime tuple( since, until, DozerChannel)
    def __prepareData( self, pointsInTime ):

        for pointInTime in pointsInTime:
            if ( ( type(pointInTime) is TupleType ) and
                 ( len(pointInTime) == 3 ) ):

                since = None
                until = None
                channel = None 
        
                if ( isinstance( pointInTime[0], DozerIOV ) ):
                    since = pointInTime[0]  
                elif ( type( pointInTime[0] ) is LongType ):
                    since = DozerIOV( pointInTime[0] )
            
                if ( self.__since == None ): self.__since = since 
                elif ( self.__since and 
                     self.__since > since ):
                    self.__since = since
              
                if ( isinstance( pointInTime[1], DozerIOV ) ):
                    until = pointInTime[1]
                elif ( type(pointInTime[1]) is LongType ):
                    until = DozerIOV(pointInTime)

                if ( self.__until == None ): self.__until = until
                elif ( self.__until and 
                       self.__until < until ):
                    self.__until = until
               
                dataDict = None
                
                if ( type(pointInTime[2]) is DozerChannel ):
                    channel = pointInTime[2]
                    if ( self.__channel == None ): self.__channel = channel.name()
                    dataDict = { }
                    for key, data in channel.iteritems():
                        if ( data.type() in ( "Int", "Long", "Float", "Double") ):
                            dataDict[ data.name() ] = data
                            self.debug("adding data name='%s' type='%s' value='%s' since='%s' to plotter " % ( data.name(),
                                                                                                               data.type(),
                                                                                                               str( data.value() ),
                                                                                                               since.AsISO() ) )
                            if ( data.name() not in self.__plotable ):
                                self.__plotable.append( data.name() )
                        else:
                            self.debug("skipping data name='%s' type='%s', unable to plot" % ( data.name(),
                                                                                               data.type() ) )

                if ( None not in ( since, until, channel, dataDict) ):
                    self.pointsInTime[ (since.AsCool() , until.AsCool() ) ] = dataDict


    ## len() operator
    # @param self "Me, myself and Irene"
    # @return number of points to plot
    def __len__( self ):
        return len( self.pointsInTime )

    ## checks if channel or its data member is able to plot  
    # @param self "Me, myself and Irene"
    # @param name data name or None
    # @return True if channel consists numeric data types 
    def isPlotable( self, name=None ):
        if ( name ):
            if ( name in self.__plotable ): return True
        else:
            if ( len(self.__plotable) > 0 ): return True
        return False 

    ## return list of plotable DozerData names
    # @param self "Me, myself and Irene"
    def plotables( self ):
        return self.__plotable

    ## since DozerIOV getter
    # @param self "Me, myself and Irene"
    def since( self ):
        return self.__since 

    ## until DozerIOV getter
    # @param self "Me, myself and Irene"
    def until( self ):
        return self.__until


    ## gaussian function getter
    # @param self "Me, myself and Irene"
    # @param xmin minimal x
    # @param xmax maximal x
    # @return ROOT.TF1 instance
    def __gaussianFcn( self, xmin, xmax ):
        gaussFit = ROOT.TF1("normal fit", "[0]*exp(-0.5*((x-[1])/[2])**2)", xmin, xmax )
        gaussFit.SetParName(0, "N")
        gaussFit.SetParName(1, "#mu")
        gaussFit.SetParName(2, "#sigma" )
        return gaussFit


    ## linear function getter
    # @param self "Me, myself and Irene"
    # @param xmin minimal x
    # @param xmax maximal x
    # @return ROOT.TF1 instance
    def __linearFcn( self, xmin, xmax ):
        linearFit = ROOT.TF1("linear fit", "[0]*x+[1]", xmin, xmax )
        linearFit.SetParName(0, "a")
        linearFit.SetParName(1, "b")
        return linearFit
    

    ##
    # @param self "Me, myself and Irene"
    # @param name name of DozerData to plot
    # @param fit flag to trigger gaussin fit
    def __histo( self, name, fit=False ):
        
        if ( not self.isPlotable(name) ): return None
        
        min = self.min( name )
        max = self.max( name )
        dx = 10.0
        if ( None not in ( min, max ) ): 
            dx = 0.2 * abs(max - min)
        else:
            self.error("cannot plot histogram for data: '"+name+
                       ", unable to determine range of histogram, one of xmin="+
                       str(min)+" xmax="+str(max)+" isn't a number" )
            return None

        unit = self.pointsInTime[ self.pointsInTime.keys()[0] ][name].unit()

        bins = int( len( self )/4 ) + 4 
        self.debug( "bins %d" % bins )
        
        histo = ROOT.TH1D( "DozerHisto " + name,
                           name + "; " + name + " [" + unit + "]; entries",
                           bins, 
                           min-dx,
                           max+dx ) 
        
        for k, dataDict in self.pointsInTime.iteritems():
            if ( name in dataDict.keys() ):
                value = dataDict[name].value()
                histo.Fill( value, 1 )
                
        if ( fit and histo.GetEntries() > 1.0 ):
            fitFcn = self.__gaussianFcn( min-dx, max+dx )
            fitFcn.SetParameter(0, histo.GetEntries() )
            fitFcn.SetParameter(1, histo.GetMean() )
            fitFcn.SetParameter(2, histo.GetRMS() )
            histo.Fit( fitFcn, "R+")

        return histo
        

    ## makes trend plot
    # @param self "Me, myself and Irene"
    # @param name DozerData name to plot
    # @param fit flag to trigger linear fit
    # @param errors list of names of DozerData treated as +/- error 
    def __trend( self, name, fit, errors ):

        upErrorKey = errors[0]
        downErrorKey = errors[1]

        graph = ROOT.TGraphAsymmErrors()

        xmax = float ( ( self.until().AsUnix() - self.since().AsUnix()  ) / 84600 )

        days = int(xmax)
        
        offset = self.since().AsUnix()  

        unit = ""
        
        points = [ ]
        
        for ( since, until ), data in sorted( self.pointsInTime.iteritems() ):

            value = None
            upError = None
            downError = None
            
            since = abs( ( DozerIOV( since ).AsUnix() - offset ) / 84600 )
            until = abs( ( DozerIOV( until ).AsUnix() - offset ) / 84600 )
            
            if name in data.keys():
                unit = data[name].unit()
                value = data[name].value()
                
                if ( upErrorKey in data.keys() ):
                    upError = data[upErrorKey].value()
                if ( downErrorKey in data.keys() ):
                    downError = data[downErrorKey].value()
                
            points.append( ( since, value, upError, downError ) )

        i = 0
        ymin = None
        ymax = None
        for (x, y, ue, de) in points:
            
            self.debug("point i=%s x=%s y=%s uerr=%s derr=%s" % ( str(i), str(x), str(y), str(ue), str(de) ) )
            if ( None not in ( x, y ) and y != ""  ):
                graph.SetPoint( i, x+0.5, y )
                if ( not ue ): ue = 0.0
                if ( not de ): de = 0.0
                if ( errors[0] == errors[1] ):
                    de = ue
                    graph.SetPointError(i, 0.0, 0.0, ue, ue ) 
                else:
                    graph.SetPointError(i, 0.0, 0.0, ue, de )

                if ( not ymin ):
                    ymin = y - de

                if ( not ymax ):
                    ymax = y + ue

                if ( ymax < ( y + ue ) ):
                    ymax = y + ue 

                if ( ymin > ( y - de ) ):
                    ymin = y - de
           
                i += 1
            else:
                self.error( "skipping point, x=%s y=%s" % ( str(x), str(y) ) )
              
        self.nbPoints = i
        #self.info("number of points %d" % self.nbPoints )

        if ( None not in (ymax, ymin) ):
            dy = 1.2 * abs(ymax - ymin) 
            graph.SetMinimum( ymin-dy )
            graph.SetMaximum( ymax+dy )


        timeAxis = graph.GetXaxis()
        
        timeAxis.Set( days+1, 0, days+1 )
        timeAxis.SetNdivisions( days+1 , False ) 
    
        for i in range( 0, days+1 ):
            label = DozerIOV ( self.since().lastNDays( days-i ) ).AsISO().split(" ")[0]
            timeAxis.SetBinLabel( i+1, label )
           
        timeAxis.SetLabelOffset(0.005)
        timeAxis.SetTitleOffset(2.1)
        timeAxis.LabelsOption("v")
        timeAxis.SetTitle("days")
        

        graph.GetYaxis().SetTitle( name + "[" + unit + "]" )

        if ( fit and self.nbPoints > 1 ):
            fitFcn = self.__linearFcn( 0, days+1 )
            graph.Fit( fitFcn, "R+")

        return graph

    ## ROOT.TCanvas with histogram plot getter
    # @param self "Me, myself and Irene"
    # @param name DozerData name 
    # @param fit flag to trigger gaussian fit on plot (defaut - no fit)
    # @param saveAs name of plot file 
    # @param style DozerStyle name 
    # @return None if DozerData isn't plotable (unit not in not "Int", "Long", "Double") or
    # ROOT.TCanvas with plot 
    def histogram( self, name, fit=False, saveAs=None, style=None ):
        if ( not self.isPlotable( name ) ): 
            self.error("cannot plot DozerData name='%s'" % str(name) )
            return False

        if ( not saveAs ):
            saveAs = name.replace(" ", "_") + ".png"
        
        if ( style != None ): self.setStyle( style )
        
        self.__applyStyle( self.__style )

        canvas = self.getCanvas()
        canvas.cd()

        histo = self.__histo( name, fit )
        if ( not histo ): return False
        histo.SetMaximum( 1.5 * histo.GetMaximum() )
        histo.Draw()

        titlePave = self.__titlePave( name )
        titlePave.Draw()

        configPave = self.__configPave( name )
        configPave.Draw()

        statPave = ROOT.TPaveText( 0.62, 0.9, 0.9, 0.84, "NDC")
        statPave.SetBorderSize( 1 )
        statPave.SetTextColor( 1 )
        statPave.SetTextSize( 0.02 )
        statPave.SetTextFont( 102 )
        statPave.SetTextAlign( 12 )
        statPave.SetLineColor( ROOT.kBlack )
        
        statPave.AddText("entries  %d" % histo.GetEntries() )
        statPave.AddText("   mean  %+4.3e #pm %+4.3e" % ( histo.GetMean(), histo.GetMeanError() ) )
        statPave.AddText("    rms  %+4.3e #pm %+4.3e" % ( histo.GetRMS(),  histo.GetRMSError() ) )
        statPave.Draw()
       
        if ( fit ):
            if ( histo.GetEntries() > 1.0 ):
                fitPave = ROOT.TPaveText( 0.62, 0.84, 0.9, 0.70, "NDC" )
                fitPave.SetBorderSize( 1 )
                fitPave.SetTextColor( 1 )
                fitPave.SetTextSize( 0.02 )
                fitPave.SetTextFont( 102 )
                fitPave.SetTextAlign( 12 )
                fitPave.SetLineColor( ROOT.kBlack )

                fitFcn = histo.GetFunction("normal fit")

                chi2 =  fitFcn.GetChisquare()
                ndf   = fitFcn.GetNDF()
                fitPave.AddText( "fit fcn  'gaussian'")
                fitPave.AddText( "ndf      %d" % ndf )

                chi2norm = "nan"
                if ( ndf ):
                    chi2norm = chi2 / float( ndf )
                    fitPave.AddText( "#chi^{2}(/ndf) %+4.3e (%+4.3e)" % ( chi2, chi2norm ) )
                else:
                    fitPave.AddText( "#chi^{2}(/ndf) %+4.3e (%s)" % ( chi2, chi2norm ) )

                for  i in range( 0, fitFcn.GetNpar() ):
                    fitPave.AddText( "%s        %+4.3e #pm %+4.3e" % ( fitFcn.GetParName(i),
                                                                       fitFcn.GetParameter(i),
                                                                       fitFcn.GetParError(i) ) )
                    
          
                fitPave.Draw()
            else:
                self.debug("fit disabled, only one entry in histogram")
      
        canvas.SaveAs( saveAs )
        canvas.SaveAs( saveAs ) 
        self.info("image %s has been created" % saveAs )

        return True



    ## ROOT.TCanvas with trend plot getter
    # @param self "Me, myself and Irene"
    # @param name DozerData name to plot
    # @param fit flag to trigger linear fit on plot
    # @param saveAs plot file name
    # @param style DozerStyle name
    def trend( self, name, fit=False, saveAs=None, style=None ):
        
        if ( not self.isPlotable( name ) ): 
            self.error("cannot plot DozerData name='%s'" % str(name) )
            return False

        stdError = name + ";error"
        stdUpError = name + ";uperror"
        stdDownError = name + ";downerror"

        errors = ( None, None )
        if ( self.isPlotable( stdError ) ):
            self.debug("will use DozerData '%s' as +/- error" % stdError )
            errors = ( stdError, stdError )
        else:
            if ( self.isPlotable( stdUpError ) and self.isPlotable( stdDownError ) ):
                self.debug("will use DozerData '%s' as +error and DozerData '%s' as -error" % ( stdUpError, stdDownError) )
                errors = ( stdUpError, stdDownError ) 

        #self.debug( "errors" + str(errors) )

        if ( not saveAs ):
            saveAs = name.replace(" ", "_") + ".png"
            self.debug("will save TCanvas to file %s" % saveAs )
            
        if ( style != None ):
            self.setStyle( style )

        self.__applyStyle( self.__style ) 

        ROOT.gStyle.SetPadBottomMargin(0.2)
        canvas = self.getCanvas()
        canvas.cd()
        
        ymin = self.min( name ) 
        ymax = self.max( name )
        dy = 10.0
        if ( None not in ( ymin, ymax ) ):
            dy = 1.2 * abs(ymax - ymin) 
        else:
            self.error("cannot plot trend for data: '"+name+
                       "', unable to determine range of plot, one of ymin="+
                       str(ymin)+" ymax="+str(ymax)+" isn't a number"  )
            return False

        xmax = float ( ( self.until().AsUnix() - self.since().AsUnix()  ) / 84600 )
        
        days = int(xmax)

        ROOT.gPad.DrawFrame( 0, ymin - dy, xmax, ymax + dy )

        trend = self.__trend( name, fit, errors )
        if ( not trend ): return False
       
        trend.Draw("ap")

        titlePave = self.__titlePave(name)
        titlePave.Draw()

        configPave = self.__configPave( name )
        configPave.Draw()

        statPave = ROOT.TPaveText( 0.62, 0.9, 0.9, 0.84, "NDC")
        statPave.SetBorderSize( 1 )
        statPave.SetTextColor( 1 )
        statPave.SetTextSize( 0.02 )
        statPave.SetTextFont( 102 )
        statPave.SetTextAlign( 12 )
        statPave.SetLineColor( ROOT.kBlack )

        self.info( "number of points: %d" % trend.GetN() )

        statPave.AddText("       points  %d" % trend.GetN() )
        statPave.AddText("      mean(y)  %+4.3e" %  trend.GetMean(2) )
        statPave.AddText("       rms(y)  %+4.3e" % trend.GetRMS(2) ) 
        statPave.Draw()

        if ( fit ):
            if ( trend.GetN() > 1 ):
                fitPave = ROOT.TPaveText( 0.62, 0.84, 0.9, 0.72, "NDC" )
                fitPave.SetBorderSize( 1 )
                fitPave.SetTextColor( 1 )
                fitPave.SetTextSize( 0.02 )
                fitPave.SetTextFont( 102 )
                fitPave.SetTextAlign( 12 )
                fitPave.SetLineColor( ROOT.kBlack )
                
                fitFcn = trend.GetFunction("linear fit")

                chi2 =  fitFcn.GetChisquare()
                ndf = fitFcn.GetNDF()
        
                fitPave.AddText( "fit fcn  'y = ax + b'")
                fitPave.AddText( "ndf      %d" % ndf )

                chi2norm = "nan"
                if ( ndf ):
                    chi2norm = chi2 / float( ndf )
                    fitPave.AddText( "#chi^{2}(/ndf) %+4.3e (%+4.3e)" % ( chi2, chi2norm ) )
                else:
                    fitPave.AddText( "#chi^{2}(/ndf) %+4.3e (%s)" % ( chi2, chi2norm ) )

                for  i in range( 0, fitFcn.GetNpar() ):
                    fitPave.AddText( "%s        %+4.3e #pm %+4.3e" % ( fitFcn.GetParName(i), 
                                                                       fitFcn.GetParameter(i) ,
                                                                       fitFcn.GetParError(i) ) )
                fitPave.Draw()
            else:
                self.debug("fit disabled, only one point of graph")

        canvas.SaveAs( saveAs )
        canvas.SaveAs( saveAs ) 
        self.info("image %s has been created" % saveAs )

        return True


    ## prepares canvas title 
    # @param self "Me, myself and Irene"
    # @param name DozerData name
    def __titlePave( self, name ):
        titlePave = ROOT.TPaveText( 0.0, 1.0, 1.0, 0.95 , "NDC")
        titlePave.SetBorderSize( 0 )
        titlePave.SetTextColor(1)
        titlePave.SetTextSize( 0.04 )
        titlePave.SetTextFont( 102 )
        titlePave.AddText( "'%s' from %s to %s" % ( name, 
                                                    self.since().AsISO().split(" ")[0],
                                                    self.until().AsISO().split(" ")[0] ) )
        return titlePave



    ## ROOT.TPaveText with configuration 
    # @param self "Me, myself and Irene"
    # @param name DozerData name 
    def __configPave( self, name ):
        configPave = ROOT.TPaveText( 0.1, 0.9, 0.4, 0.70, "NDC" )
        configPave.SetBorderSize( 1 )
        configPave.SetTextColor( 1 )
        configPave.SetTextSize( 0.02 )
        configPave.SetTextFont( 102 )
        configPave.SetTextAlign( 12 )
        configPave.SetLineColor( ROOT.kBlack )
        configPave.AddText( " package  " + self.package()   )
        configPave.AddText( " channel  " + self.channel()   )
        configPave.AddText( "    data  " + name  )
        configPave.AddText( "database  " + self.framework() )
        configPave.AddText( "  branch  " + self.nightly()   )
        configPave.AddText( " install  " + self.install()   )
        configPave.AddText( "     cmt  " + self.cmtconfig() )
        configPave.AddText( " project  " + self.project()   )
        configPave.AddText( "   jobId  " + self.jobId()   )
        return configPave
   

    ## ROOT.TCanvas getter
    # @param self "Me, myself and Irene"
    # @param name canvas name
    # @param title canvas title
    # @param width canvas width in pixels
    # @param height canvas height in pixels
    # @return ROOT.TCanvas instance
    def getCanvas( self, name=None, title=None, width=1024, height=768):
        if ( name == None ): name = "DozerCanvas"
        if ( title == None ): title = "DozerCanvas"
        canv = ROOT.TCanvas( str(name), str(title), int(width), int(height) )
        canv.SetGrid(1)
        return canv


    ## finds minimal value for DozerData
    # @param self "Me, myself and Irene"
    # @param name DozerData name
    # @return minimal value for DozerData set or None
    def min( self, name ):
        minimal = None
        if ( self.isPlotable( name ) ):
            for k, dataDict in self.pointsInTime.iteritems():
                if ( name in dataDict ):
                    if ( dataDict[name].value() not in ( None, "" ) ):
                        if ( minimal == None ): minimal = dataDict[name].value()
                        if ( dataDict[name].value() <= minimal ):
                            minimal = dataDict[name].value()
        try:
            minimal = float( str(minimal) )
        except ValueError:
            minimal = None
        return minimal
                
    ## finds maximal value for DozerData
    # @param self "Me, myself and Irene"
    # @param name DozerData name 
    # @return maximal value for DozerData set or None
    def max( self, name ):
        maximal = None
        if ( self.isPlotable( name ) ):
            for k, dataDict in self.pointsInTime.iteritems():
                if ( name in dataDict ):
                    if ( dataDict[name].value() not in ( None, "" ) ):
                        if ( maximal == None ): maximal = dataDict[name].value()
                        if ( dataDict[name].value() >= maximal ):
                            maximal = dataDict[name].value()
        try:
            maximal = float( str(maximal) )
        except ValueError:
            maximal = None
        return maximal

##
# @class test_DozerGraph
# @author Krzysztof Daniel Ciba (Krzysztof.Ciba@NOSPAMgmail.com)
# @brief Test case class for DozerGraph class.
class test_DozerGraph( unittest.TestCase ):

    ## test setup
    # @param self "Me, myself and Irene"
    def setUp( self ):

        self.__log =  DozerLogger( "DozerGraph_unittest.log", "test_DozerGraph", toConsole=True )

        self.package = "DummyTestPackage"
        self.framework = "RTT"
        self.nightly = "dev"
        self.install = "build"
        self.cmtconfig = "i686-slc4-gcc34-opt"
        self.project = "AtlasProduction"
        self.jobId = "job_1"

        self.channel = DozerChannel("test channel", "test channel description" )
        self.channel += DozerData("double test data", "Double", "GeV")
        self.channel += DozerData("double test data;error", "Double", "GeV")
        self.channel += DozerData("int test data", "Int", "counts")
        self.channel += DozerData("int test data;uperror", "Double", "counts" )
        self.channel += DozerData("int test data;downerror", "Double", "counts")
        
        today = DozerIOV()

        self.pointsInTime = [ ]
       
        try:
            import random
        except ImportError:
            exit(0)

        for i in range(0, 30):
            
            since = today.lastNDays( i )
            until = today.lastNDays( i-1 )

            
            if ( i in ( 5, 10 ) ): continue
            
            chan = DozerChannel.fromXMLDoc( self.channel.xml() )

            if ( i in ( 15, 20, 25 ) ):
                self.pointsInTime.append( (since, until,  chan ) )
            else:    
            
            
                chan["double test data"].setValue( i + random.gauss( 0.0, 3.0 ) )
                chan["double test data;error"].setValue( random.gauss( 5.0, 5.0 ) )
            
                chan["int test data"].setValue( i + random.randrange(10, 20) )
                chan["int test data;uperror"].setValue( random.randrange( 10, 15 ) )
                chan["int test data;downerror"].setValue( random.randrange(10, 15) )
                
                self.pointsInTime.append( (since, until,  chan ) )
            print i

            
        self.graph = DozerGraph( self.package,
                                 self.framework,
                                 self.nightly,
                                 self.install,
                                 self.cmtconfig,
                                 self.project,
                                 self.jobId,
                                 self.pointsInTime )
        self.graph.style()



    ## c'tor
    # @param self "Me, myself and Irene"
    def test_01_constructor( self ):

        try:
            self.graph = DozerGraph( self.package,
                                     self.framework,
                                     self.nightly,
                                     self.install,
                                     self.cmtconfig,
                                     self.project,
                                     self.jobId,
                                     self.pointsInTime )
        except:
            pass

        self.assertEqual( isinstance(self.graph, DozerGraph ) , True )

    ## isPlotable(), min(), max(), since(), until()
    # @param self "Me, myself and Irene"
    def test_02_varia( self ):

        self.assertEqual(  self.graph.isPlotable(), True )
        self.assertEqual(  self.graph.isPlotable("double test data"), True )

        self.assertEqual( self.graph.min( "double test data") <= self.graph.max( "double test data" ), True )

        self.assertEqual( self.graph.since() < self.graph.until(), True )

    ## setStyle(), histogram(), trend() 
    # @param self "Me, myself and Irene"
    def test_03_plot( self ):

        self.graph.histogram("double test data", True, "histogram_default.png")
        self.graph.trend("int test data", True, "trend_default.png")

        self.graph.setStyle("Orca")
        self.graph.histogram("double test data", True, "histogram_orca.png")
        self.graph.trend("double test data", True, "trend_orca.png")

        self.graph.setStyle("Dolphin")
        self.graph.histogram("double test data", True, "histogram_dolphin.png")
        self.graph.trend("double test data", True, "trend_dolphin.png")

        self.graph.setStyle("Seagull")
        self.graph.histogram("double test data", True, "histogram_seagull.png")
        self.graph.trend("double test data", True, "trend_seagull.png")

        self.graph.setStyle("Seal")
        self.graph.histogram("double test data", True, "histogram_seal.png")
        self.graph.trend("double test data", True, "trend_seal.png")
        
## test suite execution
if __name__ == "__main__":

    testLoader = unittest.TestLoader()
    suite = testLoader.loadTestsFromTestCase( test_DozerGraph )      
    unittest.TextTestRunner(verbosity=3).run(suite)
    
