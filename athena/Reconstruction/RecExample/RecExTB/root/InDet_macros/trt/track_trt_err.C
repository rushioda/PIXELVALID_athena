/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

void track_trt_err(int SaveOpt=0) {  gStyle->SetCanvasBorderMode(0);  gStyle->SetPadBorderMode(0);  // Enabling only tracking branches  tree->SetBranchStatus("*",0);  tree->SetBranchStatus("trk_*",1);  // Get number of entries  int entries = tree->GetEntries();  cout<<entries<<" entries"<<endl;  // Get pointer to data  int event, ntracks=0;  int trt_nhits[MAX_TRACKS];  float trt_errtrk[MAX_TRACKS][MAX_TRT_HITS];  float trt_errhit[MAX_TRACKS][MAX_TRT_HITS];  tree->SetBranchAddress("trk_nTracks", &ntracks);  tree->SetBranchAddress("trk_nTrtHits", trt_nhits);  tree->SetBranchAddress("trk_TrtErrTrk", trt_errtrk);  tree->SetBranchAddress("trk_TrtErrHit", trt_errhit);  TCanvas *c11 = new TCanvas("c11","Tracking Offline Monitor: TRT Errors");  c11->Divide(1,2);    TH1F *histoTrk;  sprintf(name,"TRT Error Track");  sprintf(name2,"TrtErrTrk");  histoTrk = new TH1F(name2,name,100,0.,0.04);  TH1F *histoHit;  sprintf(name,"TRT Error Hit");  sprintf(name2,"TrtErrHit");  histoHit = new TH1F(name2,name,100,0.1,0.2);  int hit;  for (event=0; event<entries; event++) {    // Get data for current event    tree->GetEntry(event);        // loop over all tracks    for (int track=0; track<ntracks; track++) {      // loop over all pixel hits of current track      for (hit=0; hit<trt_nhits[track]; hit++) {        histoTrk->Fill(trt_errtrk[track][hit]);	histoHit->Fill(trt_errhit[track][hit]);      }    }  }  c11->cd(1);  histoTrk->DrawCopy();  c11->Update();  delete histoTrk;  c11->cd(2);  histoHit->DrawCopy();  c11->Update();  delete histoHit;  if (SaveOpt==1) c11->Print("TRT_track_err.ps");  else if(SaveOpt==2) {sprintf(sname,"TRT_track_err.gif"); c11->Print(sname); }  else if(SaveOpt==3) c11->Print(psfilename);}