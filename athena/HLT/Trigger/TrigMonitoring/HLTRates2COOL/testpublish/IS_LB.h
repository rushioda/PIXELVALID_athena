/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

#ifndef IS_LB_H
#define IS_LB_H

#include <is/info.h>

#include <string>
#include <vector>
#include <iostream>

#include <ctime>

using std::cout;
using std::endl;

/**
 * IS class to contain luminosity block information from the CTPCORE
 * 
 * @author  generated by the IS tool
 * @version 07/08/07
 */

class IS_LB : public ISInfo {
public:

    /**
     * Run number
     */
    unsigned long                 runnumber;

    /**
     * Luminosity block number
     */
    unsigned short                LBN;

    /**
     * 0: IS entry not yet completed: still waiting for final update 1: IS entry complete for this luminosity block
     */
    bool                          Completed;

    /**
     * Starttime (second) human readable
     */
    std::string                   Starttime;
    
	/**
     * Starttime (second)
     */
    unsigned long                 Starttime_sec;

    /**
     * Starttime (nanosecond)
     */
    unsigned long                 Starttime_ns;

    /**
     * Stoptime (second) human readable
     */
    std::string                   Stoptime;
    
	/**
     * Stoptime (second)
     */
    unsigned long                 Stoptime_sec;

    /**
     * Stoptime (nanosecond)
     */
    unsigned long                 Stoptime_ns;

    /**
     * First L1ID seen by CTP
     */
    unsigned long                 Start_L1ID;

    /**
     * Last L1ID seen by CTP
     */
    unsigned long                 Stop_L1ID;

    /**
     * Number of L1A
     */
    unsigned long                 L1A_counter;

    /**
     * Number of LHC turns corresponding to the L1A counter
     */
    unsigned long                 L1A_turns;

    /**
     * Overflow bit for the L1A counter. True means: an overflow has occurred at least once for this counter False means: ok
     */
    bool                          L1A_overflow;

    /**
     * Mask of the 256 trigger items: true=enabled, false=disabled
     */
    std::vector<bool>             TriggerMask;

    /**
     * Values of the 256 pre-scale division factors (24-bit)
     */
    std::vector<unsigned long>    Prescale_dividers;

    /**
     * Array of 176 pattern-in-time counter values (31-bit)
     */
    std::vector<unsigned long>    PIT_counters;

    /**
     * Array of 256 trigger-before-prescale counter values (31-bit)
     */
    std::vector<unsigned long>    TBP_counters;

    /**
     * Array of 256 trigger-after-prescale counter values (31-bit)
     */
    std::vector<unsigned long>    TAP_counters;

    /**
     * Array of 256 trigger-after-veto counter values (31-bit)
     */
    std::vector<unsigned long>    TAV_counters;

    /**
     * 176 overflow bits for the PIT counters. True means: an overflow has occurred at least once for this counter False means: ok
     */
    std::vector<bool>             PIT_overflows;

    /**
     * 256 overflow bits for the TBP counters. True means: an overflow has occurred at least once for this counter False means: ok
     */
    std::vector<bool>             TBP_overflows;

    /**
     * 256 overflow bits for the TAP counters. True means: an overflow has occurred at least once for this counter False means: ok
     */
    std::vector<bool>             TAP_overflows;

    /**
     * 256 overflow bits for the TAV counters. True means: an overflow has occurred at least once for this counter False means: ok
     */
    std::vector<bool>             TAV_overflows;

    /**
     * Number of LHC turns corresponding to the set of PIT_counter values
     */
    unsigned long                 PIT_turns;

    /**
     * Number of LHC turns corresponding to the set of TBP_counter values
     */
    unsigned long                 TBP_turns;

    /**
     * Number of LHC turns corresponding to the set of TAP_counter values
     */
    unsigned long                 TAP_turns;

    /**
     * Number of LHC turns corresponding to the set of TAV_counter values
     */
    unsigned long                 TAV_turns;


    static const ISType & type() {
	static const ISType type_ = IS_LB( ).ISInfo::type();
	return type_;
    }

    IS_LB()
    : ISInfo( "IS_LB" )
    {
		initialize();
    }
    
	IS_LB( const std::string & type )
    : ISInfo( type )
    {
		initialize();
    }

    ~IS_LB()
	{
// <<BeginUserCode>>

// <<EndUserCode>>
    }

	void initialize()
    {
		LBN = 0;
		Completed = 0;
		PIT_overflows.resize( 1 );
		PIT_overflows[0] = 0;
		TBP_overflows.resize( 1 );
		TBP_overflows[0] = 0;
		TAP_overflows.resize( 1 );
		TAP_overflows[0] = 0;
		TAV_overflows.resize( 1 );
		TAV_overflows[0] = 0;

		
// <<BeginUserCode>>
		TBP_counters.reserve(256);
		TAP_counters.reserve(256);
		TAV_counters.reserve(256);
		
		for (int ii=0;ii<256;ii++)
		{
			int ihelp = 0; //ii * 256;
			TBP_counters.push_back( ihelp );
			TAP_counters.push_back( ihelp );
			TAV_counters.push_back( ihelp );
		}
		
		Starttime_sec = std::time(0);
		Stoptime_sec = std::time(0) + 2;
		
		L1A_counter = rand()%20;
// <<EndUserCode>>
    }


// <<BeginUserCode>>

    void increase_counters(int factor)
	{
		cout << "LB: " << LBN << endl;
	
      	cout<<" for testing increase TBP, TAP, TAV counters and turns  by adding "<<factor<<endl;
      
	  	for (int ii=0;ii<256;ii++)
		{
			TBP_counters[ii] += factor + rand()%40;
			TAP_counters[ii] += factor/2 + rand()%40;
			TAV_counters[ii] += factor/4 + rand()%40;
      	}
		
		L1A_counter = rand()%75000;

		Starttime_sec = std::time(0);
		Stoptime_sec = std::time(0) + 2;
		cout << " TIME: start - stop: " << Starttime_sec << " - " << Stoptime_sec << endl;
    }

	void setLB( int pLB )
	{
		LBN = pLB;
	}

protected:
	
    void publishGuts( ISostream & out )
	{
		out << runnumber << LBN << Completed << Starttime << Starttime_sec << Starttime_ns;
		out << Stoptime << Stoptime_sec << Stoptime_ns << Start_L1ID << Stop_L1ID << L1A_counter;
		out << L1A_turns << L1A_overflow << TriggerMask << Prescale_dividers << PIT_counters;
		out << TBP_counters << TAP_counters << TAV_counters << PIT_overflows << TBP_overflows;
		out << TAP_overflows << TAV_overflows << PIT_turns << TBP_turns << TAP_turns << TAV_turns;
    }

    void refreshGuts( ISistream & in )
	{
		in >> runnumber >> LBN >> Completed >> Starttime >> Starttime_sec >> Starttime_ns;
		in >> Stoptime >> Stoptime_sec >> Stoptime_ns >> Start_L1ID >> Stop_L1ID >> L1A_counter;
		in >> L1A_turns >> L1A_overflow >> TriggerMask >> Prescale_dividers >> PIT_counters;
		in >> TBP_counters >> TAP_counters >> TAV_counters >> PIT_overflows >> TBP_overflows;
		in >> TAP_overflows >> TAV_overflows >> PIT_turns >> TBP_turns >> TAP_turns >> TAV_turns;
    }

// <<EndUserCode>>
};

// <<BeginUserCode>>

// <<EndUserCode>>
#endif // IS_LB_H
