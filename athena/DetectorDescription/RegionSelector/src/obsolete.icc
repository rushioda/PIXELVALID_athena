// emacs: this is -*- c++ -*-

/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

///////////////////////////////////////////////////////////////////////
/// obsolete HashID methods
///////////////////////////////////////////////////////////////////////


// calorimeter

void RegSelSvc::DetROBIDListUint(DETID detectorID, 
				 long sampling, 
				 double etaMin, double etaMax,
				 double phiMin, double phiMax, 
				 std::vector<uint32_t>& outputROBIDList) {

  static bool first = true;
  if ( first ) { 
    first = false;
    (*m_log) << MSG::WARNING << __func__ << " - This method is obsolete DO NOT USE" << endmsg;	
  }

  if(m_msgOutputLevel <= MSG::DEBUG && outputROBIDList.size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input outputROBIDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  outputROBIDList.clear();

  if ( !checkinput(etaMin, etaMax, phiMin, phiMax) ) { 
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " bad roi parameter to regionselector" 
	       << "\tetaMin=" << etaMin << "\tetaMax=" << etaMax 
	       << "\tphiMin=" << phiMin << "\tphiMax=" << phiMax << endmsg;
    
    return;
  }


  switch(detectorID){
  case PIXEL: 
  case SCT:   
    return DetROBIDListUint(detectorID, sampling, -m_DeltaZ, m_DeltaZ, etaMin, etaMax, phiMin, phiMax, outputROBIDList); 
    break;
  case TRT:   
    break;
  case LAR: // Liquid Argon Calorimeter
    verifyInputs(LAR, etaMin, etaMax, phiMin, phiMax);
    m_larData.regionSelectorRobIdUint(sampling, etaMin, etaMax, phiMin, phiMax, outputROBIDList);
    //log<< MSG::DEBUG << "LAR verifyOutput" << endmsg; larData.verifyOutput(ROBID, sampling, etaMin, etaMax, phiMin, phiMax,outputROBIDList);
    break;
  case TTEM: // Liquid Argon Trigger Tower EM Calorimeter
    verifyInputs(TTEM, etaMin, etaMax, phiMin, phiMax);
    m_ttemData.regionSelectorRobIdUint(sampling, etaMin, etaMax, phiMin, phiMax, outputROBIDList);
    //log<< MSG::DEBUG << "TTEM verifyOutput" << endmsg; ttemData.verifyOutput(ROBID, sampling, etaMin, etaMax, phiMin, phiMax,outputROBIDList);
    break;
  case TTHEC: // Liquid Argon Trigger Tower HEC Calorimeter
    verifyInputs(TTHEC, etaMin, etaMax, phiMin, phiMax);
    m_tthecData.regionSelectorRobIdUint(sampling, etaMin, etaMax, phiMin, phiMax, outputROBIDList);
    //log<< MSG::DEBUG << "TTHEC verifyOutput" << endmsg; tthecData.verifyOutput(ROBID, sampling, etaMin, etaMax, phiMin, phiMax,outputROBIDList);
    break;
  case FCALEM: // Liquid Argon Trigger Tower FCALEM Calorimeter
    verifyInputs(FCALEM, etaMin, etaMax, phiMin, phiMax);
    m_ttfcalemData.regionSelectorRobIdUint(sampling, etaMin, etaMax, phiMin, phiMax, outputROBIDList);
    //log<< MSG::DEBUG << "FCALEM verifyOutput" << endmsg; ttfcalemData.verifyOutput(ROBID, sampling, etaMin, etaMax, phiMin, phiMax,outputROBIDList);
    break;
  case FCALHAD: // Liquid Argon Trigger Tower FCALHAD Calorimeter
    verifyInputs(FCALHAD, etaMin, etaMax, phiMin, phiMax);
    m_ttfcalhadData.regionSelectorRobIdUint(sampling, etaMin, etaMax, phiMin, phiMax, outputROBIDList);
    //log<< MSG::DEBUG << "FCALHAD verifyOutput" << endmsg; ttfcalhadData.verifyOutput(ROBID, sampling, etaMin, etaMax, phiMin, phiMax,outputROBIDList);
    break;
  case TILE: // Tile Calorimeters
    break;
  case MDT: // MDT Calorimeter
    break;
  case RPC: // RPC Calorimeters
    break;
  case TGC: // TGC Calorimeters
    break;
  case CSC: // CSC Calorimeters
    break;
  default:
    break;
  }

  if(m_msgOutputLevel <= MSG::DEBUG){
    (*m_log) << MSG::DEBUG << "DetROBIDListUint for detector " << detectorID 
	<< " got " << outputROBIDList.size() << " ROB IDs" << endmsg;
  }

}














// Combiner inner detector rob id and hash id methods

void RegSelSvc::DetROBHashIDList(DETID detectorID,
				 double zMin,   double zMax,
				 double etaMin, double etaMax,
				 double phiMin, double phiMax,
				 std::vector<uint32_t>&      outputROBIDList,
				 std::vector<IdentifierHash> *IDList) 
{

  static bool first = true;
  if ( first ) { 
    first = false;
    (*m_log) << MSG::WARNING << __func__ << " - This method is obsolete DO NOT USE" << endmsg;	
  }

  //  std::cout << "RegSelSvc::DetROBHashIDList() new map " << detectorID << std::endl; 

  //  if(m_msgOutputLevel <= MSG::WARNING ) 
  //    (*m_log) << MSG::WARNING << " This method is obsolete - please replace" << endmsg;


  if(m_msgOutputLevel <= MSG::DEBUG && outputROBIDList.size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input outputROBIDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  outputROBIDList.clear();

  if(m_msgOutputLevel <= MSG::DEBUG && IDList->size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input IDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  IDList->clear();

  if ( !checkinput(zMin, zMax, etaMin, etaMax, phiMin, phiMax) ) { 
    (*m_log) << MSG::WARNING << " bad roi parameter to regionselector" 
	     <<    "zMin=" <<   zMin <<   "\tzMax=" <<   zMax 
	     << "\tetaMin=" << etaMin << "\tetaMax=" << etaMax 
	     << "\tphiMin=" << phiMin << "\tphiMax=" << phiMax << endmsg;
    
    return;
  }

  RegSelRoI roi( zMin, zMax, phiMin, phiMax, etaMin, etaMax );

  switch(detectorID){
  case PIXEL: { // Pixel    
    if ( m_newpixel ) m_newpixel->getRobHashList(roi, outputROBIDList, *IDList); 
    break;
  }
  case SCT: { // Semiconductor Tracker (and pixel)
    if ( m_newsct ) m_newsct->getRobHashList(roi, outputROBIDList, *IDList); 
    break;
  }
  case TRT: { // TRT (obviously)
    if ( m_newtrt ) m_newtrt->getRobHashList(roi, outputROBIDList, *IDList); 
    break;
  }
  default:
    break;
  }

  if(m_msgOutputLevel <= MSG::DEBUG){
    (*m_log) << MSG::DEBUG << "DetROBHashIDList for detector " << detectorID 
	<< " got " << IDList->size() << " hash IDs" << endmsg;
  }

}



#if 1
void RegSelSvc::DetROBHashIDList(DETID detectorID,
				 const IRoiDescriptor& roi,
				 std::vector<uint32_t>&      outputROBIDList,
				 std::vector<IdentifierHash> *IDList) 
{
  //  std::cout << "RegSelSvc::DetROBHashIDList() new map " << detectorID << std::endl; 

  static bool first = true;
  if ( first ) { 
    first = false;
    (*m_log) << MSG::WARNING << __func__ << " - This method is obsolete DO NOT USE" << endmsg;	
  }

  if(m_msgOutputLevel <= MSG::DEBUG && outputROBIDList.size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input outputROBIDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  outputROBIDList.clear();

  if(m_msgOutputLevel <= MSG::DEBUG && IDList->size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input IDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  IDList->clear();

  RegSelRoI _roi( roi.zedMinus(), roi.zedPlus(), 
		  roi.phiMinus(), roi.phiPlus(),
		  roi.etaMinus(), roi.etaPlus() );

  switch(detectorID){
  case PIXEL: { // Pixel    
    if ( m_newpixel ) m_newpixel->getRobHashList(_roi, outputROBIDList, *IDList); 
    break;
  }
  case SCT: { // Semiconductor Tracker (and pixel)
    if ( m_newsct ) m_newsct->getRobHashList(_roi, outputROBIDList, *IDList); 
    break;
  }
  case TRT: { // TRT (obviously)
    if ( m_newtrt ) m_newtrt->getRobHashList(_roi, outputROBIDList, *IDList); 
    break;
  }
  default:
    break;
  }

  if(m_msgOutputLevel <= MSG::DEBUG){
    (*m_log) << MSG::DEBUG << "DetROBHashIDList for detector " << detectorID 
	<< " got " << IDList->size() << " hash IDs" << endmsg;
  }

}
#endif




// inner detector by layer  

void RegSelSvc::DetROBHashIDList(DETID detectorID, long layer,
				 double zMin,   double zMax,
				 double etaMin, double etaMax,
				 double phiMin, double phiMax,
				 std::vector<uint32_t>&      outputROBIDList,
				 std::vector<IdentifierHash> *IDList) 
{
  
  static bool first = true;
  if ( first ) { 
    first = false;
    (*m_log) << MSG::WARNING << __func__ << " - This method is obsolete DO NOT USE" << endmsg;	
  }

  //  std::cout << "RegSelSvc::DetROBHashIDList() new map " << detectorID << std::endl; 

  if(m_msgOutputLevel <= MSG::DEBUG && outputROBIDList.size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input outputROBIDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  outputROBIDList.clear();

  if(m_msgOutputLevel <= MSG::DEBUG && IDList->size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input IDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  IDList->clear();

  if ( !checkinput(zMin, zMax, etaMin, etaMax, phiMin, phiMax) ) { 
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " bad roi parameter to regionselector" 
	       <<    "zMin=" <<   zMin <<   "\tzMax=" <<   zMax 
	       << "\tetaMin=" << etaMin << "\tetaMax=" << etaMax 
	       << "\tphiMin=" << phiMin << "\tphiMax=" << phiMax << endmsg;
    
    return;
  }

  RegSelRoI roi( zMin, zMax, phiMin, phiMax, etaMin, etaMax );

  switch(detectorID){
  case PIXEL: { // Pixel    
    if ( m_newpixel ) m_newpixel->getRobHashList(roi, layer, outputROBIDList, *IDList); 
    break;
  }
  case SCT: { // Semiconductor Tracker (and pixel)
     if ( m_newsct ) m_newsct->getRobHashList(roi, layer, outputROBIDList, *IDList); 
    break;
  }
  case TRT: { // TRT (obviously)
     if ( m_newtrt ) m_newtrt->getRobHashList(roi, layer, outputROBIDList, *IDList); 
    break;
  }
  default:
    break;
  }

  if(m_msgOutputLevel <= MSG::DEBUG){
    (*m_log) << MSG::DEBUG << "DetROBHashIDList for detector " << detectorID 
	<< " got " << IDList->size() << " hash IDs" << endmsg;
  }

}


#if 1
void RegSelSvc::DetROBHashIDList(DETID detectorID, long layer,
				 const IRoiDescriptor& roi, 
				 std::vector<uint32_t>&      outputROBIDList,
				 std::vector<IdentifierHash> *IDList) 
{

  static bool first = true;
  if ( first ) { 
    first = false;
    (*m_log) << MSG::WARNING << __func__ << " - This method is obsolete DO NOT USE" << endmsg;	
  }

  //  std::cout << "RegSelSvc::DetROBHashIDList() new map " << detectorID << std::endl; 


  if(m_msgOutputLevel <= MSG::DEBUG && outputROBIDList.size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input outputROBIDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  outputROBIDList.clear();

  if(m_msgOutputLevel <= MSG::DEBUG && IDList->size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input IDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  IDList->clear();

  RegSelRoI _roi( roi.zedMinus(), roi.zedPlus(), 
		  roi.phiMinus(), roi.phiPlus(),
		  roi.etaMinus(), roi.etaPlus() );


  switch(detectorID){
  case PIXEL: { // Pixel    
    if ( m_newpixel ) m_newpixel->getRobHashList(_roi, layer, outputROBIDList, *IDList); 
    break;
  }
  case SCT: { // Semiconductor Tracker (and pixel)
    if ( m_newsct ) m_newsct->getRobHashList(_roi, layer, outputROBIDList, *IDList); 
    break;
  }
  case TRT: { // TRT (obviously)
    if ( m_newtrt ) m_newtrt->getRobHashList(_roi, layer, outputROBIDList, *IDList); 
    break;
  }
  default:
    break;
  }

  if(m_msgOutputLevel <= MSG::DEBUG){
    (*m_log) << MSG::DEBUG << "DetROBHashIDList for detector " << detectorID 
	<< " got " << IDList->size() << " hash IDs" << endmsg;
  }

}
#endif



// inner detector full scan

void RegSelSvc::DetROBHashIDList(DETID detectorID, 
				 std::vector<uint32_t>&       outputROBIDList,
				 std::vector<IdentifierHash>* IDList ) 
{ 

  static bool first = true;
  if ( first ) { 
    first = false;
    (*m_log) << MSG::WARNING << __func__ << " - This method is obsolete DO NOT USE" << endmsg;	
  }

  if(m_msgOutputLevel <= MSG::DEBUG && outputROBIDList.size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input outputROBIDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  outputROBIDList.clear();

  if(m_msgOutputLevel <= MSG::DEBUG && IDList->size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input IDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  IDList->clear();

  switch (detectorID) {
  case PIXEL: { // Pixel
    if ( m_newpixel ) m_newpixel->getRobHashList(outputROBIDList, *IDList); 
    break;
  }
  case SCT: {  // SCT
    if ( m_newsct ) m_newsct->getRobHashList(outputROBIDList, *IDList); 
    break;
  }
  case TRT: {  // TRT
    if ( m_newtrt ) m_newtrt->getRobHashList(outputROBIDList, *IDList); 
    break;
  }
  default:
    break;
  }
} 












// methods to return the list of disabled modules from the inner 
// within and roi in a given layer

void RegSelSvc::DetDisabledHashIDList(DETID detectorID, long layer, 
				      double zMin,   double zMax,
				      double etaMin, double etaMax,
				      double phiMin, double phiMax,
				      std::vector<IdentifierHash>* IDList) 
{ 

  static bool first = true;
  if ( first ) { 
    first = false;
    (*m_log) << MSG::WARNING << __func__ << " - This method is obsolete DO NOT USE" << endmsg;	
  }

  //  std::cout << "RegSelSvc::DetDisabledHashIDList() new map " << detectorID << std::endl; 

  if(m_msgOutputLevel <= MSG::DEBUG && IDList->size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input IDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  IDList->clear();

  if ( !checkinput(zMin, zMax, etaMin, etaMax, phiMin, phiMax) ) { 
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " bad roi parameter to regionselector" 
	       <<    "zMin=" <<   zMin <<   "\tzMax=" <<   zMax 
	       << "\tetaMin=" << etaMin << "\tetaMax=" << etaMax 
	       << "\tphiMin=" << phiMin << "\tphiMax=" << phiMax << endmsg;
    
    return;
  }

  RegSelRoI roi( zMin, zMax, phiMin, phiMax, etaMin, etaMax );
   
  switch(detectorID){
  case PIXEL: { // Pixel    
    if ( m_newpixel ) m_newpixel->getDisabledHashList(roi, layer, *IDList); 
    break;
  }
  case SCT: { // Semiconductor Tracker (and pixel)
    if ( m_newsct ) m_newsct->getDisabledHashList(roi, layer, *IDList); 
    break;
  }
  case TRT: { // TRT (obviously)
    if ( m_newtrt ) m_newtrt->getDisabledHashList(roi, layer, *IDList); 
    break;
  }
  default:
    break;
  }

  if(m_msgOutputLevel <= MSG::DEBUG){
    (*m_log) << MSG::DEBUG << "DetDisabledHashIDList for detector " << detectorID 
	<< " got " << IDList->size() << " hash IDs" << endmsg;
  }
  
}




void RegSelSvc::getDisabledLayers(DETID detectorID, 
				  int subdetector, 
				  double zMin,   double zMax,
				  double etaMin, double etaMax,
				  double phiMin, double phiMax,
				  std::vector<int>& layers) 
{ 

  static bool first = true;
  if ( first ) { 
    first = false;
    (*m_log) << MSG::WARNING << __func__ << " - This method is obsolete DO NOT USE" << endmsg;	
  }

  if(m_msgOutputLevel <= MSG::DEBUG && layers.size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input layers vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  layers.clear();

  if ( !checkinput(zMin, zMax, etaMin, etaMax, phiMin, phiMax) ) { 
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " bad roi parameter to regionselector" 
	       <<    "zMin=" <<   zMin <<   "\tzMax=" <<   zMax 
	       << "\tetaMin=" << etaMin << "\tetaMax=" << etaMax 
	       << "\tphiMin=" << phiMin << "\tphiMax=" << phiMax << endmsg;
    
    return;
  }

  RegSelRoI roi( zMin, zMax, phiMin, phiMax, etaMin, etaMax );

  switch(detectorID){
  case PIXEL: { // Pixel    
    if ( m_newpixel ) m_newpixel->getDisabledLayers(roi, subdetector, layers); 
    break;
  }
  case SCT: { // Semiconductor Tracker (and pixel)
    if ( m_newsct ) m_newsct->getDisabledLayers(roi, subdetector, layers); 
    break;
  }
  default:
    break;
  }

} 



void RegSelSvc::getDisabledLayers(DETID detectorID, 
				  double zMin,   double zMax,
				  double etaMin, double etaMax,
				  double phiMin, double phiMax,
				  std::vector<int>& barrellayers,
				  std::vector<int>& endAlayers,
				  std::vector<int>& endClayers)
{

  static bool first = true;
  if ( first ) { 
    first = false;
    (*m_log) << MSG::WARNING << __func__ << " - This method is obsolete DO NOT USE" << endmsg;	
  }

  if(m_msgOutputLevel <= MSG::DEBUG && barrellayers.size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input barrellayers vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  barrellayers.clear();


  if(m_msgOutputLevel <= MSG::DEBUG && endAlayers.size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input endAlayers vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  endAlayers.clear();
 
  if(m_msgOutputLevel <= MSG::DEBUG && endClayers.size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input endClayers vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  endClayers.clear();
 
  if ( !checkinput(zMin, zMax, etaMin, etaMax, phiMin, phiMax) ) { 
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " bad roi parameter to regionselector" 
	       <<    "zMin=" <<   zMin <<   "\tzMax=" <<   zMax 
	       << "\tetaMin=" << etaMin << "\tetaMax=" << etaMax 
	       << "\tphiMin=" << phiMin << "\tphiMax=" << phiMax << endmsg;
    
    return;
  }

  RegSelRoI roi( zMin, zMax, phiMin, phiMax, etaMin, etaMax );

  switch(detectorID){
  case PIXEL: { // Pixel    
    if ( m_newpixel ) { 
      m_newpixel->getDisabledLayers(roi,  0, barrellayers); 
      m_newpixel->getDisabledLayers(roi, -2, endAlayers); 
      m_newpixel->getDisabledLayers(roi,  2, endClayers); 
    }
    break;
  }
  case SCT: { // Semiconductor Tracker (and pixel)
    if ( m_newsct ) { 
      m_newsct->getDisabledLayers(roi,  0, barrellayers); 
      m_newsct->getDisabledLayers(roi, -2, endAlayers); 
      m_newsct->getDisabledLayers(roi,  2, endClayers);    
    }  
    break;
  }
  default:
    break;
  }

} 





#if 0
void RegSelSvc::DetDisabledHashIDList(DETID detectorID, long layer, 
				      const IRoiDescriptor& roi, 
				      std::vector<IdentifierHash>* IDList) 
{ 
  //  std::cout << "RegSelSvc::DetDisabledHashIDList() new map " << detectorID << std::endl; 

  if(m_msgOutputLevel <= MSG::DEBUG && IDList->size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input IDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  IDList->clear();

  RegSelRoI _roi( roi.zedMinus(), roi.zedPlus(), 
		  roi.phiMinus(), roi.phiPlus(),
		  roi.etaMinus(), roi.etaPlus() );


  switch(detectorID){
  case PIXEL: { // Pixel    
    if ( m_newpixel ) m_newpixel->getDisabledHashList(_roi, layer, *IDList); 
    break;
  }
  case SCT: { // Semiconductor Tracker (and pixel)
    if ( m_newsct ) m_newsct->getDisabledHashList(_roi, layer, *IDList); 
    break;
  }
  case TRT: { // TRT (obviously) 
    if ( m_newtrt ) m_newtrt->getDisabledHashList(_roi, layer, *IDList); 
    break;
  }
  default:
    break;
  }

  if(m_msgOutputLevel <= MSG::DEBUG){
    (*m_log) << MSG::DEBUG << "DetDisabledHashIDList for detector " << detectorID 
	<< " got " << IDList->size() << " hash IDs" << endmsg;
  }
  
}
#endif





// old Region Selector interface

void RegSelSvc::DetHashIDList(DETID detectorID, 
			      double etaMin,double etaMax,
			      double phiMin, double phiMax, 
			      std::vector<IdentifierHash>* IDList) {

  static bool first = true;
  if ( first ) { 
    first = false;
    (*m_log) << MSG::WARNING << __func__ << " - This method is obsolete DO NOT USE" << endmsg;	
  }

  //  if(m_msgOutputLevel <= MSG::WARNING ) 
  //   (*m_log) << MSG::WARNING << " THIS METHOD IS OBSOLETE - PLEASE REPLACE" << endmsg; 


  if(m_msgOutputLevel <= MSG::DEBUG && IDList->size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input IDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  IDList->clear();
  
  if ( !checkinput(etaMin, etaMax, phiMin, phiMax) ) { 
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " bad roi parameter to regionselector" 
	       << "\tetaMin=" << etaMin << "\tetaMax=" << etaMax 
	       << "\tphiMin=" << phiMin << "\tphiMax=" << phiMax << endmsg;
    
    return;
  }
  
  switch(detectorID){
  case PIXEL: 
  case SCT:   
  case TRT:   
  case MDT:   
  case RPC:   
  case TGC:   
  case CSC:   
    return DetHashIDList(detectorID, -m_DeltaZ, m_DeltaZ, etaMin, etaMax, phiMin, phiMax, IDList); 
    break;
  case LAR:  // Liquid Argon Calorimeter
    verifyInputs(LAR, etaMin, etaMax, phiMin, phiMax);
    m_larData.regionSelector(etaMin, etaMax, phiMin, phiMax,(*IDList));
    //log<< MSG::DEBUG << "LAR hashID verifyOutput" << endmsg; larDataIdentHash.verifyOutput(etaMin, etaMax, phiMin, phiMax,IDList);
    break;
  case TTEM: // Liquid Argon Trigger Tower EM Calorimeter
    verifyInputs(TTEM, etaMin, etaMax, phiMin, phiMax);
    m_ttemData.regionSelector(etaMin, etaMax, phiMin, phiMax,(*IDList));
    //log<< MSG::DEBUG << "TTEM hashID verifyOutput" << endmsg;  ttemDataIdentHash.verifyOutput(etaMin, etaMax, phiMin, phiMax,IDList);
    break;
  case TTHEC: // Liquid Argon Trigger Tower HEC Calorimeter
    verifyInputs(TTHEC, etaMin, etaMax, phiMin, phiMax);
    m_tthecData.regionSelector(etaMin, etaMax, phiMin, phiMax,(*IDList));
    //log<< MSG::DEBUG << "TTHEC hashID verifyOutput" << endmsg; tthecDataIdentHash.verifyOutput(etaMin, etaMax, phiMin, phiMax,IDList);
    break;
  case FCALEM: // Liquid Argon Trigger Tower HEC Calorimeter
    verifyInputs(FCALEM, etaMin, etaMax, phiMin, phiMax);
    m_ttfcalemData.regionSelector(etaMin, etaMax, phiMin, phiMax,(*IDList));
    //log<< MSG::DEBUG << "TTHEC hashID verifyOutput" << endmsg; ttfcalemDataIdentHash.verifyOutput(etaMin, etaMax, phiMin, phiMax,IDList);
    break;
  case FCALHAD: // Liquid Argon Trigger Tower HEC Calorimeter
    verifyInputs(FCALHAD, etaMin, etaMax, phiMin, phiMax);
    m_ttfcalhadData.regionSelector(etaMin, etaMax, phiMin, phiMax,(*IDList));
    //log<< MSG::DEBUG << "TTHEC hashID verifyOutput" << endmsg; ttfcalhadDataIdentHash.verifyOutput(etaMin, etaMax, phiMin, phiMax,IDList);
    break;
  case TILE: // Tile Calorimeters
    verifyInputs(TILE, etaMin, etaMax, phiMin, phiMax);
    m_tileData.regionSelector(TILE,etaMin, etaMax, phiMin, phiMax,(*IDList));
    break;
  default:
    break;
  }

  if(m_msgOutputLevel <= MSG::DEBUG){
    (*m_log) << MSG::DEBUG << "DetHashIDList for detector " << detectorID 
	<< " got " << IDList->size() << " hash IDs" << endmsg;
  }

}





// detector with new lookup tables

void RegSelSvc::DetHashIDList(DETID detectorID,
			      double zMin,   double zMax,
			      double etaMin, double etaMax,
			      double phiMin, double phiMax,
			      std::vector<IdentifierHash> *IDList) 
{

  static bool first = true;
  if ( first ) { 
    first = false;
    (*m_log) << MSG::WARNING << __func__ << " - This method is obsolete DO NOT USE" << endmsg;	
  }

  //  if(m_msgOutputLevel <= MSG::WARNING ) 
  //    (*m_log) << MSG::WARNING << " THIS METHOD IS OBSOLETE - PLEASE REPLACE" << endmsg; 

  //  std::cout << "RegSelSvc::DetHashIDList() new map " << detectorID << std::endl; 

  if(m_msgOutputLevel <= MSG::DEBUG && IDList->size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING )       
      (*m_log) << MSG::WARNING << " input IDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  IDList->clear();

  if ( !checkinput(zMin, zMax, etaMin, etaMax, phiMin, phiMax) ) { 
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " bad roi parameter to regionselector" 
	       <<    "zMin=" <<   zMin <<   "\tzMax=" <<   zMax 
	       << "\tetaMin=" << etaMin << "\tetaMax=" << etaMax 
	       << "\tphiMin=" << phiMin << "\tphiMax=" << phiMax << endmsg;
    
    return;
  }

  RegSelRoI roi( zMin, zMax, phiMin, phiMax, etaMin, etaMax );


  switch(detectorID){
  case PIXEL: { // Pixel    
    if ( m_newpixel ) m_newpixel->getHashList(roi, *IDList); 
    break;
  }
  case SCT: { // Semiconductor Tracker (and pixel)
    if ( m_newsct ) m_newsct->getHashList(roi, *IDList); 
    break;
  }
  case TRT: { // TRT (obviously)
    if ( m_newtrt ) m_newtrt->getHashList(roi, *IDList); 
    break;
  }
  case FTK: {
    if ( m_ftklut ) m_ftklut->getModules(roi, *IDList); 
    break;
  }
  case RPC: { // RPC (obviously)
    if ( m_newrpc ) m_newrpc->getHashList(roi, *IDList); 
    break;
  }
  case MDT: { // MDT (obviously)
    if ( m_newmdt ) m_newmdt->getHashList(roi, *IDList); 
    break;
  }
  case TGC: { // TGC (obviously)
    if ( m_newtgc ) m_newtgc->getHashList(roi, *IDList); 
    break;
  }
  case CSC: { // CSC (obviously)
    if ( m_newcsc ) m_newcsc->getHashList(roi, *IDList); 
    break;
  }
  default:
    break;
  }

  if(m_msgOutputLevel <= MSG::DEBUG){
    (*m_log) << MSG::DEBUG << "DetHashIDList for detector " << detectorID 
	<< " got " << IDList->size() << " hash IDs" << endmsg;
  }

}






void RegSelSvc::DetHashIDList(DETID detectorID,
			      double zMin,   double zMax,
			      double etaMin, double etaMax,
			      double phiMin, double phiMax, 
			      double xBeam,  double yBeam, 
			      std::vector<IdentifierHash> *IDList) 
{

  static bool first = true;
  if ( first ) { 
    first = false;
    (*m_log) << MSG::WARNING << __func__ << " - This method is obsolete DO NOT USE" << endmsg;	
  }

  //  if(m_msgOutputLevel <= MSG::WARNING ) 
  //    (*m_log) << MSG::WARNING << " THIS METHOD IS OBSOLETE - PLEASE REPLACE" << endmsg; 

  //  std::cout << "RegSelSvc::DetHashIDList() new map " << detectorID << std::endl; 

  if(m_msgOutputLevel <= MSG::DEBUG && IDList->size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input IDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  IDList->clear();

  if ( !checkinput(zMin, zMax, etaMin, etaMax, phiMin, phiMax) ) { 
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " bad roi parameter to regionselector" 
	       <<    "zMin=" <<   zMin <<   "\tzMax=" <<   zMax 
	       << "\tetaMin=" << etaMin << "\tetaMax=" << etaMax 
	       << "\tphiMin=" << phiMin << "\tphiMax=" << phiMax << endmsg;
    
    return;
  }

  RegSelRoI roi( zMin, zMax, phiMin, phiMax, etaMin, etaMax );

  switch(detectorID){
  case PIXEL: { // Pixel    
    if ( m_newpixel ) m_newpixel->getHashList(roi, *IDList, xBeam, yBeam ); 
    break;
  }
  case SCT: { // Semiconductor Tracker (and pixel)
    if ( m_newsct ) m_newsct->getHashList(roi, *IDList, xBeam, yBeam ); 
    break;
  }
  case TRT: { // TRT (obviously)
    if ( m_newtrt ) m_newtrt->getHashList(roi, *IDList, xBeam, yBeam ); 
    break;
  }
  case MDT: { 
    if ( m_newmdt ) m_newmdt->getHashList(roi, *IDList, xBeam, yBeam ); 
    break;
  }
  case RPC: { 
    if ( m_newrpc ) m_newrpc->getHashList(roi, *IDList, xBeam, yBeam ); 
    break;
  }
  case TGC: { 
    if ( m_newtgc ) m_newtgc->getHashList(roi, *IDList, xBeam, yBeam ); 
    break;
  }
  case CSC: { 
    if ( m_newcsc ) m_newcsc->getHashList(roi, *IDList, xBeam, yBeam ); 
    break;
  }
  default:
    break;
  }

  if(m_msgOutputLevel <= MSG::DEBUG){
    (*m_log) << MSG::DEBUG << "DetHashIDList for detector " << detectorID 
	<< " got " << IDList->size() << " hash IDs" << endmsg;
  }

}



#if 1
void RegSelSvc::DetHashIDList(DETID detectorID,
			      const IRoiDescriptor& roi,
			      std::vector<IdentifierHash> *IDList) 
{

  static bool first = true;
  if ( first ) { 
    first = false;
    (*m_log) << MSG::WARNING << __func__ << " - This method is obsolete DO NOT USE" << endmsg;	
  }

  if ( roi.isFullscan() ) return DetHashIDList( detectorID, IDList );

  //  std::cout << "RegSelSvc::DetHashIDList() new map " << detectorID << std::endl; 

  //  if(m_msgOutputLevel <= MSG::WARNING ) 
  //    (*m_log) << MSG::WARNING << " THIS METHOD IS OBSOLETE - PLEASE REPLACE" << endmsg; 


  if(m_msgOutputLevel <= MSG::DEBUG && IDList->size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input IDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  IDList->clear();

  RegSelRoI _roi( roi.zedMinus(), roi.zedPlus(), 
		  roi.phiMinus(), roi.phiPlus(),
		  roi.etaMinus(), roi.etaPlus() );


  switch(detectorID){
  case PIXEL: { // Pixel    
    if ( m_newpixel ) m_newpixel->getHashList(_roi, *IDList); 
    break;
  }
  case SCT: { // Semiconductor Tracker (and pixel)
    if ( m_newsct ) m_newsct->getHashList(_roi, *IDList); 
    break;
  }
  case TRT: { // TRT (obviously)
    if ( m_newtrt ) m_newtrt->getHashList(_roi, *IDList); 
    break;
  }
  case MDT: { 
    if ( m_newmdt ) m_newmdt->getHashList(_roi, *IDList); 
    break;
  }
  case RPC: { 
    if ( m_newrpc ) m_newrpc->getHashList(_roi, *IDList); 
    break;
  }
  case TGC: { 
    if ( m_newtgc ) m_newtgc->getHashList(_roi, *IDList); 
    break;
  }
  case CSC: { 
    if ( m_newcsc ) m_newcsc->getHashList(_roi, *IDList); 
    break;
  }
  default:
    break;
  }

  if(m_msgOutputLevel <= MSG::DEBUG){
    (*m_log) << MSG::DEBUG << "DetHashIDList for detector " << detectorID 
	<< " got " << IDList->size() << " hash IDs" << endmsg;
  }

}



// detector by layer

void RegSelSvc::DetHashIDList(DETID detectorID, long layer,
			      double zMin,   double zMax,
			      double etaMin, double etaMax,
			      double phiMin, double phiMax, 
			      std::vector<IdentifierHash> *IDList) 
{

  static bool first = true;
  if ( first ) { 
    first = false;
    (*m_log) << MSG::WARNING << __func__ << " - This method is obsolete DO NOT USE" << endmsg;	
  }

  //  std::cout << "RegSelSvc::DetHashIDList() new map " << detectorID << std::endl; 

  if(m_msgOutputLevel <= MSG::DEBUG && IDList->size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input IDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  IDList->clear();

  if ( !checkinput(zMin, zMax, etaMin, etaMax, phiMin, phiMax) ) { 
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " bad roi parameter to regionselector" 
	       <<    "zMin=" <<   zMin <<   "\tzMax=" <<   zMax 
	       << "\tetaMin=" << etaMin << "\tetaMax=" << etaMax 
	       << "\tphiMin=" << phiMin << "\tphiMax=" << phiMax << endmsg;
    
    return;
  }

  RegSelRoI roi( zMin, zMax, phiMin, phiMax, etaMin, etaMax );
   
  switch(detectorID){
  case PIXEL: { // Pixel    
    if ( m_newpixel ) m_newpixel->getHashList(roi, layer, *IDList); 
    break;
  }
  case SCT: { // Semiconductor Tracker 
    if ( m_newsct ) m_newsct->getHashList(roi, layer, *IDList); 
    break;
  }
  case TRT: { // TRT (obviously)
    if ( m_newtrt ) m_newtrt->getHashList(roi, layer, *IDList); 
    break;
  }
  case MDT: { 
    if ( m_newmdt ) m_newmdt->getHashList(roi, layer, *IDList); 
    break;
  }
  case RPC: { 
    if ( m_newrpc ) m_newrpc->getHashList(roi, layer, *IDList); 
    break;
  }
  case TGC: {
    if ( m_newtgc ) m_newtgc->getHashList(roi, layer, *IDList); 
    break;
  }
  case CSC: { 
    if ( m_newcsc ) m_newcsc->getHashList(roi, layer, *IDList); 
    break;
  }
  default:
    break;
  }

  if(m_msgOutputLevel <= MSG::DEBUG){
    (*m_log) << MSG::DEBUG << "DetHashIDList for detector " << detectorID 
	<< " got " << IDList->size() << " hash IDs" << endmsg;
  }

}


void RegSelSvc::DetHashIDList(DETID detectorID, long layer,
			      const IRoiDescriptor& roi,
			      std::vector<IdentifierHash> *IDList) 
{
  static bool first = true;
  if ( first ) { 
    first = false;
    (*m_log) << MSG::WARNING << __func__ << " - This method is obsolete DO NOT USE" << endmsg;	
  }

  if ( roi.isFullscan() ) return DetHashIDList( detectorID, layer, *IDList );

  //  std::cout << "RegSelSvc::DetHashIDList() new map " << detectorID << std::endl; 

  if(m_msgOutputLevel <= MSG::DEBUG && IDList->size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input IDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  IDList->clear();

  RegSelRoI _roi( roi.zedMinus(), roi.zedPlus(), 
		  roi.phiMinus(), roi.phiPlus(),
		  roi.etaMinus(), roi.etaPlus() );
  
  switch(detectorID){
  case PIXEL: { // Pixel    
    if ( m_newpixel ) m_newpixel->getHashList(_roi, layer, *IDList); 
    break;
  }
  case SCT: { // Semiconductor Tracker 
    if ( m_newsct ) m_newsct->getHashList(_roi, layer, *IDList); 
    break;
  }
  case TRT: { // TRT (obviously)
    if ( m_newtrt ) m_newtrt->getHashList(_roi, layer, *IDList); 
    break;
  }
  case MDT: { 
    if ( m_newmdt ) m_newmdt->getHashList(_roi, layer, *IDList); 
    break;
  }
  case RPC: { 
    if ( m_newrpc ) m_newrpc->getHashList(_roi, layer, *IDList); 
    break;
  }
  case TGC: {
    if ( m_newtgc ) m_newtgc->getHashList(_roi, layer, *IDList); 
    break;
  }
  case CSC: { 
    if ( m_newcsc ) m_newcsc->getHashList(_roi, layer, *IDList); 
    break;
  }
  default:
    break;
  }

  
  if(m_msgOutputLevel <= MSG::DEBUG){
    (*m_log) << MSG::DEBUG << "DetHashIDList for detector " << detectorID 
	<< " got " << IDList->size() << " hash IDs" << endmsg;
  }

}
#endif








// detector full scan

void RegSelSvc::DetHashIDList(DETID detectorID, 
			      std::vector<IdentifierHash>* IDList ) 
{ 
  static bool first = true;
  if ( first ) { 
    first = false;
    (*m_log) << MSG::WARNING << __func__ << " - This method is obsolete DO NOT USE" << endmsg;	
  }

  //  std::cout << "RegSelSvc::DetHashIDList() new map " << detectorID << std::endl;   

  if(m_msgOutputLevel <= MSG::DEBUG && IDList->size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input IDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  IDList->clear();

  switch(detectorID){
  case PIXEL: { // Pixel    
    if ( m_newpixel ) m_newpixel->getHashList(*IDList); 
    break;
  }
  case SCT: { // Semiconductor Tracker (and pixel)
    if ( m_newsct ) m_newsct->getHashList(*IDList); 
    break;
  }
  case TRT: { // TRT (obviously)
    if ( m_newtrt ) m_newtrt->getHashList(*IDList); 
    break;
  }
  case MDT: { 
    if ( m_newmdt ) m_newmdt->getHashList(*IDList); 
    break;
  }
  case RPC: { 
    if ( m_newrpc ) m_newrpc->getHashList(*IDList); 
    break;
  }
  case TGC: {
    if ( m_newtgc ) m_newtgc->getHashList(*IDList); 
    break;
  }
  case CSC: { 
    if ( m_newcsc ) m_newcsc->getHashList(*IDList); 
    break;
  }
  default:
    break;
  }
} 





// calorimeter

void RegSelSvc::DetHashIDList(DETID detectorID, 
			      long sampling, 
			      double etaMin, double etaMax ,
			      double phiMin, double phiMax, 
			      std::vector<IdentifierHash> *IDList) {

  static bool first = true;
  if ( first ) { 
    first = false;
    (*m_log) << MSG::WARNING << __func__ << " - This method is obsolete DO NOT USE" << endmsg;	
  }

  if(m_msgOutputLevel <= MSG::DEBUG && IDList->size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input IDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  IDList->clear();

  if ( !checkinput(etaMin, etaMax, phiMin, phiMax) ) { 
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " bad roi parameter to regionselector" 
	       << "\tetaMin=" << etaMin << "\tetaMax=" << etaMax 
	       << "\tphiMin=" << phiMin << "\tphiMax=" << phiMax << endmsg;
    
    return;
  }


  switch(detectorID){
  case PIXEL: 
  case SCT:    
  case TRT:
  case MDT: 
  case RPC:
  case TGC: 
  case CSC: 
    return DetHashIDList(detectorID, sampling, -m_DeltaZ, m_DeltaZ, etaMin, etaMax, phiMin, phiMax, IDList); 
    break;   
  case LAR: // Liquid Argon Calorimeter
    verifyInputs(LAR, etaMin, etaMax, phiMin, phiMax);
    m_larData.regionSelector(sampling, etaMin, etaMax, phiMin, phiMax,(*IDList));
    //log<< MSG::DEBUG << "LAR hashID verifyOutput sampling " << sampling << endmsg; larDataIdentHash.verifyOutput(sampling,etaMin, etaMax, phiMin, phiMax,IDList);
    break;
  case TTEM: // Liquid Argon Trigger Tower EM Calorimeter
    verifyInputs(TTEM, etaMin, etaMax, phiMin, phiMax);
    m_ttemData.regionSelector(sampling, etaMin, etaMax, phiMin, phiMax,(*IDList));
    //log<< MSG::DEBUG << "TTEM hashID verifyOutput sampling " << sampling << endmsg; ttemDataIdentHash.verifyOutput(sampling,etaMin, etaMax, phiMin, phiMax,IDList);
    break;
  case TTHEC: // Liquid Argon Trigger Tower HEC Calorimeter
    verifyInputs(TTHEC, etaMin, etaMax, phiMin, phiMax);
    m_tthecData.regionSelector(sampling, etaMin, etaMax, phiMin, phiMax,(*IDList));
    //log<< MSG::DEBUG << "TTEC hashID verifyOutput sampling " << sampling << endmsg;  tthecDataIdentHash.verifyOutput(sampling,etaMin, etaMax, phiMin, phiMax,IDList);
    break;
  case FCALEM: // Liquid Argon Trigger Tower FCALEM Calorimeter
    verifyInputs(FCALEM, etaMin, etaMax, phiMin, phiMax);
    m_ttfcalemData.regionSelector(sampling, etaMin, etaMax, phiMin, phiMax,(*IDList));
    //log<< MSG::DEBUG << "FCALEM hashID verifyOutput sampling " << sampling << endmsg;  ttfcalemDataIdentHash.verifyOutput(sampling,etaMin, etaMax, phiMin, phiMax,IDList);
    break;
  case FCALHAD: // Liquid Argon Trigger Tower FCALHAD Calorimeter
    verifyInputs(FCALHAD, etaMin, etaMax, phiMin, phiMax);
    m_ttfcalhadData.regionSelector(sampling, etaMin, etaMax, phiMin, phiMax,(*IDList));
    //log<< MSG::DEBUG << "FCALHAD hashID verifyOutput sampling " << sampling << endmsg;  ttfcalhadDataIdentHash.verifyOutput(sampling,etaMin, etaMax, phiMin, phiMax,IDList);
    break;
  case TILE: // Tile Calorimeters
    break;
  default:
    break;
  }

  if(m_msgOutputLevel <= MSG::DEBUG){
    (*m_log) << MSG::DEBUG << "DetHashIDList for detector " << detectorID 
	<< " got " << IDList->size() << " hash IDs" << endmsg;
  }

}


// muon 

void RegSelSvc::DetHashIDList(DETID detectorID, 
			      TYPEID typeID, 
			      double etaMin, double etaMax ,
			      double phiMin, double phiMax, 
			      std::vector<IdentifierHash> *IDList) 
{
  static bool first = true;
  if ( first ) { 
    first = false;
    (*m_log) << MSG::WARNING << __func__ << " - This method is obsolete DO NOT USE" << endmsg;	
  }

  if(m_msgOutputLevel <= MSG::DEBUG && IDList->size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input IDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  IDList->clear();

  if ( !checkinput(etaMin, etaMax, phiMin, phiMax) ) { 
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " bad roi parameter to regionselector" 
	       << "\tetaMin=" << etaMin << "\tetaMax=" << etaMax 
	       << "\tphiMin=" << phiMin << "\tphiMax=" << phiMax << endmsg;
    
    return;
  }

  if ( detectorID==MDT ) {   
    long layer = typeID;
    DetHashIDList(detectorID, layer, -m_DeltaZ, m_DeltaZ, etaMin, etaMax, phiMin, phiMax, IDList); 
  }
  
  
  if(m_msgOutputLevel <= MSG::DEBUG){
    (*m_log) << MSG::DEBUG << "DetHashIDList for detector " << detectorID 
	     << " got " << IDList->size() << " hash IDs" << endmsg;
  }
  
}





// Methods to retrieve the rob is list  

// old region selector interface

void RegSelSvc::DetROBIDListUint(DETID detectorID, 
				 double etaMin, double etaMax ,
				 double phiMin, double phiMax, 
				 std::vector<uint32_t>& outputROBIDList) 
{

  static bool first = true;
  if ( first ) { 
    first = false;
    (*m_log) << MSG::WARNING << __func__ << " - This method is obsolete DO NOT USE" << endmsg;	
  }

  if(m_msgOutputLevel <= MSG::DEBUG && outputROBIDList.size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input outputROBIDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  outputROBIDList.clear();

  if ( !checkinput(etaMin, etaMax, phiMin, phiMax) ) { 
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " bad roi parameter to regionselector" 
	       << "\tetaMin=" << etaMin << "\tetaMax=" << etaMax 
	       << "\tphiMin=" << phiMin << "\tphiMax=" << phiMax << endmsg;
    
    return;
  }


  switch(detectorID){
  case PIXEL: 
  case SCT:   
  case TRT:   
    return DetROBIDListUint(detectorID, -m_DeltaZ, m_DeltaZ, etaMin, etaMax, phiMin, phiMax, outputROBIDList); 
    break;
  case LAR: // Liquid Argon Calorimeter
    verifyInputs(LAR, etaMin, etaMax, phiMin, phiMax);
    m_larData.regionSelectorRobIdUint(etaMin, etaMax, phiMin, phiMax, outputROBIDList);
    //log<< MSG::DEBUG << "LAR verifyOutput" << endmsg; larData.verifyOutput(ROBID, etaMin, etaMax, phiMin, phiMax,outputROBIDList);
    break;
  case TTEM: // Liquid Argon Trigger Tower EM Calorimeter
    verifyInputs(TTEM, etaMin, etaMax, phiMin, phiMax);
    m_ttemData.regionSelectorRobIdUint(etaMin, etaMax, phiMin, phiMax, outputROBIDList);
    //log<< MSG::DEBUG << "TTEM verifyOutput" << endmsg; ttemData.verifyOutput(ROBID, etaMin, etaMax, phiMin, phiMax,outputROBIDList);
    break;
  case TTHEC: // Liquid Argon Trigger Tower HEC Calorimeter
    verifyInputs(TTHEC, etaMin, etaMax, phiMin, phiMax);
    m_tthecData.regionSelectorRobIdUint(etaMin, etaMax, phiMin, phiMax, outputROBIDList);
    //log<< MSG::DEBUG << "TTHEC verifyOutput" << endmsg; tthecData.verifyOutput(ROBID, etaMin, etaMax, phiMin, phiMax,outputROBIDList);
    break;
  case FCALEM: // Liquid Argon Trigger Tower FCALEM Calorimeter
    verifyInputs(FCALEM, etaMin, etaMax, phiMin, phiMax);
    m_ttfcalemData.regionSelectorRobIdUint(etaMin, etaMax, phiMin, phiMax, outputROBIDList);
    //log<< MSG::DEBUG << "FCALEM verifyOutput" << endmsg; ttfcalemData.verifyOutput(ROBID, etaMin, etaMax, phiMin, phiMax,outputROBIDList);
    break;
  case FCALHAD: // Liquid Argon Trigger Tower FCALHAD Calorimeter
    verifyInputs(FCALHAD, etaMin, etaMax, phiMin, phiMax);
    m_ttfcalhadData.regionSelectorRobIdUint(etaMin, etaMax, phiMin, phiMax, outputROBIDList);
    //log<< MSG::DEBUG << "FCALHAD verifyOutput" << endmsg; ttfcalhadData.verifyOutput(ROBID, etaMin, etaMax, phiMin, phiMax,outputROBIDList);
    break;
  case TILE: // Tile Calorimeters
    verifyInputs(TILE, etaMin, etaMax, phiMin, phiMax);
    m_tileData.regionSelectorRobIdUint(TILE,etaMin, etaMax, phiMin, phiMax, outputROBIDList);
    break;
  case MDT: // MDT Calorimeter
    //verifyInputs(MDT, etaMin, etaMax, phiMin, phiMax);
    //m_mdtData.regionSelectorRobIdUint(MDT,etaMin, etaMax, phiMin, phiMax, outputROBIDList);
    break;
  case RPC: // RPC Calorimeters
    //verifyInputs(RPC, etaMin, etaMax, phiMin, phiMax);
    //m_rpcData.regionSelectorRobIdUint(RPC,etaMin, etaMax, phiMin, phiMax, outputROBIDList);
    break;
  case TGC: // TGC Calorimeters
    //verifyInputs(TGC, etaMin, etaMax, phiMin, phiMax);
    //m_tgcData.regionSelectorRobIdUint(TGC,etaMin, etaMax, phiMin, phiMax, outputROBIDList);
    break;
  case CSC: // CSC Calorimeters
    //verifyInputs(CSC, etaMin, etaMax, phiMin, phiMax);
    //m_cscData.regionSelectorRobIdUint(CSC,etaMin, etaMax, phiMin, phiMax, outputROBIDList);
    break;
  default:
    break;
  }

  if(m_msgOutputLevel <= MSG::DEBUG){
    (*m_log) << MSG::DEBUG << "DetROBIDListUint for detector " << detectorID 
	<< " got " << outputROBIDList.size() << " ROB IDs" << endmsg;
  }

}




// inner detector

void RegSelSvc::DetROBIDListUint(DETID detectorID,
				 double zMin,   double zMax,
				 double etaMin, double etaMax,
				 double phiMin, double phiMax, 
				 std::vector<uint32_t>& outputROBIDList) 
{

  static bool first = true;
  if ( first ) { 
    first = false;
    (*m_log) << MSG::WARNING << __func__ << " - This method is obsolete DO NOT USE" << endmsg;	
  }

  //  std::cout << "RegSelSvc::DetROBIDListUint() new map " << detectorID << std::endl; 

  if(m_msgOutputLevel <= MSG::DEBUG && outputROBIDList.size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input outputROBIDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  outputROBIDList.clear();

  if ( !checkinput(zMin, zMax, etaMin, etaMax, phiMin, phiMax) ) { 
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " bad roi parameter to regionselector" 
	       <<    "zMin=" <<   zMin <<   "\tzMax=" <<   zMax 
	       << "\tetaMin=" << etaMin << "\tetaMax=" << etaMax 
	       << "\tphiMin=" << phiMin << "\tphiMax=" << phiMax << endmsg;
    
    return;
  }


  switch (detectorID) {
  case PIXEL: { // Pixel
    RegSelRoI roi( zMin, zMax, phiMin, phiMax, etaMin, etaMax );
    if ( m_newpixel ) m_newpixel->getRobList(roi, outputROBIDList); 
    break;
  }
  case SCT: {  // SCT
    RegSelRoI roi( zMin, zMax, phiMin, phiMax, etaMin, etaMax );
    if ( m_newsct ) m_newsct->getRobList(roi, outputROBIDList); 
    break;
  }
  case TRT: {  // TRT
    RegSelRoI roi( zMin, zMax, phiMin, phiMax, etaMin, etaMax );
    if ( m_newtrt ) m_newtrt->getRobList(roi, outputROBIDList); 
    break;
  }
  default:
    break;
  }
  
  if(m_msgOutputLevel <= MSG::DEBUG){
    (*m_log) << MSG::DEBUG << "DetROBIDListUint for detector " << detectorID 
	<< " got " << outputROBIDList.size() << " ROB IDs" << endmsg;
  }

}





void RegSelSvc::DetROBIDListUint(DETID detectorID,
				 double zMin,   double zMax,
				 double etaMin, double etaMax,
				 double phiMin, double phiMax, 
				 double xBeam,  double yBeam,
				 std::vector<uint32_t>& outputROBIDList) 
{

  static bool first = true;
  if ( first ) { 
    first = false;
    (*m_log) << MSG::WARNING << __func__ << " - This method is obsolete DO NOT USE" << endmsg;	
  }

  //  std::cout << "RegSelSvc::DetROBIDListUint() new map " << detectorID << std::endl; 

  if(m_msgOutputLevel <= MSG::DEBUG && outputROBIDList.size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input outputROBIDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  outputROBIDList.clear();

  if ( !checkinput(zMin, zMax, etaMin, etaMax, phiMin, phiMax) ) { 
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " bad roi parameter to regionselector" 
	       <<    "zMin=" <<   zMin <<   "\tzMax=" <<   zMax 
	       << "\tetaMin=" << etaMin << "\tetaMax=" << etaMax 
	       << "\tphiMin=" << phiMin << "\tphiMax=" << phiMax << endmsg;
    
    return;
  }


  switch (detectorID) {
  case PIXEL: { // Pixel
    RegSelRoI roi( zMin, zMax, phiMin, phiMax, etaMin, etaMax );
    if ( m_newpixel ) m_newpixel->getRobList(roi, outputROBIDList, xBeam, yBeam ); 
    break;
  }
  case SCT: {  // SCT
    RegSelRoI roi( zMin, zMax, phiMin, phiMax, etaMin, etaMax );
    if ( m_newsct ) m_newsct->getRobList(roi, outputROBIDList, xBeam, yBeam ); 
    break;
  }
  case TRT: {  // TRT
    RegSelRoI roi( zMin, zMax, phiMin, phiMax, etaMin, etaMax );
    if ( m_newtrt ) m_newtrt->getRobList(roi, outputROBIDList, xBeam, yBeam ); 
    break;
  }
  default:
    break;
  }
  
  if(m_msgOutputLevel <= MSG::DEBUG){
    (*m_log) << MSG::DEBUG << "DetROBIDListUint for detector " << detectorID 
	<< " got " << outputROBIDList.size() << " ROB IDs" << endmsg;
  }

}



// inner detector by layer

void RegSelSvc::DetROBIDListUint(DETID detectorID, long layer,
				 double zMin,   double zMax,
				 double etaMin, double etaMax,
				 double phiMin, double phiMax, 
				 std::vector<uint32_t>& outputROBIDList) 
{

  static bool first = true;
  if ( first ) { 
    first = false;
    (*m_log) << MSG::WARNING << __func__ << " - This method is obsolete DO NOT USE" << endmsg;	
  }

  //  std::cout << "RegSelSvc::DetROBIDListUint() new map " << detectorID << std::endl; 

  if(m_msgOutputLevel <= MSG::DEBUG && outputROBIDList.size()!=0 ){
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " input outputROBIDList vector not empty for RegSelSvc call for detectorID " << detectorID << endmsg; 
  }
  outputROBIDList.clear();

  if ( !checkinput(zMin, zMax, etaMin, etaMax, phiMin, phiMax) ) { 
    if(m_msgOutputLevel <= MSG::WARNING ) 
      (*m_log) << MSG::WARNING << " bad roi parameter to regionselector" 
	       <<    "zMin=" <<   zMin <<   "\tzMax=" <<   zMax 
	       << "\tetaMin=" << etaMin << "\tetaMax=" << etaMax 
	       << "\tphiMin=" << phiMin << "\tphiMax=" << phiMax << endmsg;
    
    return;
  }

  RegSelRoI roi( zMin, zMax, phiMin, phiMax, etaMin, etaMax );

  switch (detectorID) {
  case PIXEL: { // Pixel
    if ( m_newpixel ) m_newpixel->getRobList(roi, layer, outputROBIDList); 
    break;
  }
  case SCT: {  // SCT
    if ( m_newsct ) m_newsct->getRobList(roi, layer, outputROBIDList); 
    break;
  }
  case TRT: { // TRT
    if ( m_newtrt ) m_newtrt->getRobList(roi, layer, outputROBIDList); 
    break;
  }
  default:
    break;
  }
  
  if(m_msgOutputLevel <= MSG::DEBUG){
    (*m_log) << MSG::DEBUG << "DetROBIDListUint for detector " << detectorID 
	<< " got " << outputROBIDList.size() << " ROB IDs" << endmsg;
  }

}










