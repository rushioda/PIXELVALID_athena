/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

/**
 * @file   TRoot2Html.cxx
 * @brief  TRoot2Html implementation
 * @author Frank Winklmeier
 *
 * $Id: TRoot2Html.cxx,v 1.1 2008-07-28 11:02:00 fwinkl Exp $
 */

#include "TrigValTools/TRoot2Html.h"

#include <iostream>
#include <sstream>
#include "TError.h"
#include "TClass.h"
#include "TH1.h"
#include "TFile.h"
#include "TCanvas.h"
#include "TSystem.h"
#include "TKey.h"
#include "TPRegexp.h"

using namespace std;

TRoot2Html::TRoot2Html() :
  _nodeId(1),
  _showFullFileName(kFALSE)
{
  setOutputDir("./");
  setImageSize(400,400);
}

TRoot2Html::TRoot2Html(const TRoot2Html& other):
  TMultiFileLooper(other),
  _imgHeight(other._imgHeight),
  _imgWidth(other._imgWidth),
  _nodeId(other._nodeId),
  _showFullFileName(other._showFullFileName)
{
}

void TRoot2Html::beginJob()
{  
   _xml.open(_outDir+"/tree.xml");
  if (!_xml) {
    cout << "Cannot write to directory " << _outDir << endl;
    return;
  }
  
  _xml << "<?_xml version='1.0' encoding='iso-8859-1'?>" << endl;
  _xml << "<!-- This file was auto generated by root2html -->" << endl;
  _xml << "<!-- Use it with the dhtmlxTree component (http://www.scbr.com/docs/products/dhtmlxTree) -->" << endl;
  _xml << "<tree id=\"0\">" << endl;
  _nodeId = 1;
}

void TRoot2Html::endJob()
{
  _xml << "</tree>" << endl;
  _xml.close();
}


void TRoot2Html::beforeFile()
{
  TString treeNodeName;
  if (_showFullFileName) treeNodeName = file()->GetName();
  else treeNodeName = gSystem->BaseName(file()->GetName());
  
  _xml << "<!-- Start of " << treeNodeName << " -->" << endl;
  _xml << xmlTreeItem(treeNodeName) << endl;
  
  // Create output directory
  gSystem->mkdir(_outDir+"/img", true);
}

void TRoot2Html::afterFile()
{
  _xml << xmlTreeItemClose() << endl;
}


void TRoot2Html::beforeDir()
{
  TString s(getPathFromDir(*gDirectory));
  TString imgDir = TString(_outDir) + "/img/" + s;
  gSystem->mkdir(imgDir, true);

  _xml << xmlTreeItem(gDirectory->GetName()) << endl;
}

void TRoot2Html::afterDir()
{
  _xml << xmlTreeItemClose() << endl;
}


void TRoot2Html::processKey(TDirectory& dir, TKey& key)
{
  dir.cd();
  
  TObject* obj = key.ReadObj();
  if (obj->IsA()->InheritsFrom("TH1")) {
    _xml << xmlTreeItem(key.GetName()) << endl;
    TString imgPath = hist2Png(*gDirectory, key.GetName());
    if (imgPath!="") {
      _xml << xmlUserData("img",imgPath) << endl;
    }
    _xml << xmlTreeItemClose() << endl;
  }
}


// Save histogram 'name' from 'dir' in '_outDir/img'
// Return "" on error otherwise image path relative to _outDir
TString TRoot2Html::hist2Png(TDirectory& dir, const TString& name)
{  
  TH1* h = (TH1*)dir.Get(name);
  if (h==0) {
    cout << "hist2Png: Cannot load histogram " << name << endl;
    return "";
  }
  
  TCanvas c("c","c",_imgWidth,_imgHeight);
  TString options(getDrawOptions(*h));
  if (_verbose) cout << "Drawing histogram " << h->GetName()
                     << " (" << h->ClassName() << ") with options '"
                     << options << "'" << endl;
  h->Draw(options);
  TString s(getPathFromDir(dir));
  TString pngName = "img/" + s + "/" + name + ".png";

  // Suppress the info message when saving file
  Int_t oldIgnoreLevel = gErrorIgnoreLevel;
  if (!_verbose) gErrorIgnoreLevel = kWarning;
  c.SaveAs(_outDir+"/"+pngName);

  gErrorIgnoreLevel = oldIgnoreLevel;
  
  return pngName;
}


// Set draw options for all histograms matching re
void TRoot2Html::addDrawOptions(const char* regexp, const char* options)
{
  if (regexp && options) {
    TPRegexp* re = new TPRegexp(regexp);
    if (re) _drawOptions.push_back(std::pair<TPRegexp*,TString>(re,options));
  }
}

void TRoot2Html::addClassDrawOptions(const char* regexp, const char* options)
{
  if (regexp && options) {
    TPRegexp* re = new TPRegexp(regexp);
    if (re) _classDrawOptions.push_back(std::pair<TPRegexp*,TString>(re,options));
  }
}


// return draw options for specified histogram
TString TRoot2Html::getDrawOptions(const TH1& h)
{
  TString options("");
  
  // First check if we have class wide draw options for this histogram
  vector< pair<TPRegexp*,TString> >::iterator iter;
  for (iter=_classDrawOptions.begin(); iter!=_classDrawOptions.end(); iter++) {
    if (iter->first->Match(h.ClassName())>0) {
      options = iter->second;
      break;
    }
  }
  
  // Check if any regexp matches the histogram name
  for (iter=_drawOptions.begin(); iter!=_drawOptions.end(); iter++) {
    if (iter->first->Match(h.GetName())>0) {
      options = iter->second;
      break;
    }
  }
  
  return options;
}

// Tree node with text and id
const char* TRoot2Html::xmlTreeItem(const char* text)
{
  TString s;
  s.Form("<item text=\"%s\" id=\"%d\">",text,_nodeId);
  _nodeId++;
  return s.Data();
}

// Tree node close
const char* TRoot2Html::xmlTreeItemClose()
{
  return "</item>";
}

// User data for tree node
const char* TRoot2Html::xmlUserData(const char* name, const char* data)
{
  TString s;
  s.Form("<userdata name=\"%s\">%s</userdata>",name,data);
  return s.Data();
}
